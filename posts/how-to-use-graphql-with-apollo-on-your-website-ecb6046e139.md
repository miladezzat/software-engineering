---
card: "https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png"
tags: [GraphQL]
description: "In my previous article, I explained why it makes sense to dec"
author: "Milad E. Fahmy"
title: "How to Use GraphQL with Apollo on Your Website"
created: "2021-08-16T10:07:57+02:00"
modified: "2021-08-16T10:07:57+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-graphql tag-web-development tag-javascript tag-nodejs tag-apollo ">
<header class="post-full-header">
<h1 class="post-full-title">How to Use GraphQL with Apollo on Your Website</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*DQ22UoX0M8_mdFj3rkc5sQ@2x.png" alt="How to Use GraphQL with Apollo on Your Website">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>In my <a href="http://bit.ly/2TW60L6" rel="noopener nofollow">previous article</a>, I explained why it makes sense to decouple the front-end part of a website from its back-end services. I introduced GraphQL, Apollo and other tools that enable such abstraction and make maintenance of production websites a nice experience.</p><p>In this article, I will show you a boilerplate that already has all these tools set up and saves you a lot of time when starting the development.</p><p><a href="http://bit.ly/2GGHIB5" rel="noopener nofollow">Check out the live demo of the boilerplate</a></p><h1 id="boilerplate-to-speed-up-the-start">Boilerplate to Speed Up the Start</h1><p>Let’s start with the tools I used:</p><ul><li>Node.js — runtime</li><li>Express — web application framework</li><li>Apollo server — middleware service with GraphQL support</li><li>Apollo client — GraphQL client</li><li>Kentico Cloud tools — headless CMS</li><li>Pug — template engine</li></ul><h1 id="schema-and-resolvers-code">Schema and Resolvers Code</h1><p>The first step in building the site is to create or generate a schema. I already mentioned in the previous article that I am using <a href="http://bit.ly/2QzUALM" rel="noopener nofollow">Content-as-a-Service platform Kentico Cloud</a> for content storage. The content that is stored there is already structured within defined model structures. Therefore I can quickly generate the schema using the <a href="http://bit.ly/2SqEAju" rel="noopener nofollow">schema generator</a>:</p><p>kc-generate-gql-schema — projectId {projectID} — createModule</p><p>But it’s also possible to define all the models manually in the following syntax.</p><p>const TYPE_DEFINITION = `<br> &nbsp;<br> &nbsp;type SystemInfo {<br> &nbsp; &nbsp;id: String!<br> &nbsp; &nbsp;name: String!<br> &nbsp; &nbsp;codename: String!<br> &nbsp; &nbsp;language: String!<br> &nbsp; &nbsp;type: String!<br> &nbsp; &nbsp;lastModified: String!<br> &nbsp;}<br> &nbsp;<br> &nbsp;interface ContentItem {<br> &nbsp; &nbsp;system: SystemInfo!<br> &nbsp;}<br> &nbsp;...<br> &nbsp;type FactAboutUsContentType implements ContentItem {<br> &nbsp; &nbsp;system: SystemInfo!<br> &nbsp; &nbsp;description: RichTextElement<br> &nbsp; &nbsp;title: TextElement<br> &nbsp; &nbsp;image: AssetElement<br> &nbsp;}<br> &nbsp;...`module.exports = {<br> &nbsp;TYPE_DEFINITION<br>}</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/graphQL/types.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>The model generator lists all the system types including links, texts, datetime fields, images and others (<code>SystemInfo</code> above), followed by the data models of each of the custom content models (<code>FactAboutUsContentType</code>). We will need to use the type definition as a module, hence the last argument <code>createModule</code>.</p><p>The next step is to create GraphQL queries and resolvers. As the content API is read-only, the queries are quite simple and limited to fetch all items or items grouped by type:</p><p>const queryTypes = `<br> &nbsp;type Query {<br> &nbsp; &nbsp;items: [ContentItem],<br> &nbsp; &nbsp;itemsByType(type: String!, limit: Int, depth: Int, order: String): [ContentItem]<br> &nbsp;}<br>`;</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/graphQL/queries.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>And right after the definition, we can create a resolver for the headless CMS API:</p><p>const deliveryClient = new DeliveryClient(deliveryConfig);<br>const resolvers = {<br> &nbsp;...<br> &nbsp;Query: {<br> &nbsp; &nbsp;items: async () =&gt; {<br> &nbsp; &nbsp; &nbsp;const response = await deliveryClient.items()<br> &nbsp; &nbsp; &nbsp; &nbsp;.getPromise();<br> &nbsp; &nbsp; &nbsp;return response.items;<br> &nbsp; &nbsp;},<br> &nbsp; &nbsp;itemsByType: async (_, { type, limit, depth, order }) =&gt; {<br> &nbsp; &nbsp; &nbsp;const query = deliveryClient.items()<br> &nbsp; &nbsp; &nbsp; &nbsp;.type(type);<br> &nbsp; &nbsp; &nbsp;limit &amp;&amp; query.limitParameter(limit);<br> &nbsp; &nbsp; &nbsp;depth &amp;&amp; query.depthParameter(depth);<br> &nbsp; &nbsp; &nbsp;order &amp;&amp; query.orderParameter(order);<br> &nbsp; &nbsp; &nbsp;const response = await query.getPromise();<br> &nbsp; &nbsp; &nbsp;return response.items;<br> &nbsp; &nbsp;}<br> &nbsp;},<br>};</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/graphQL/queries.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>Did you notice that the queries always return generic type <code>ContentItem</code> even though there are more specific types like <code>FactAboutUsContentType</code> that inherit <code>ContentItem</code> defined? If you did, great job! Defining a specific query for every single type would be inefficient (there would be so many of them). Therefore both our queries return <code>ContentItem</code> data. But how do we ensure the right models are returned at runtime?</p><p>Every content item that comes from the headless CMS contains information about its type. You can see the string property <code>Type</code> in the definition of <code>SystemInfo</code> data model above.</p><p>{<br> &nbsp;"system": {<br> &nbsp; &nbsp;"type": "fact_about_us"<br> &nbsp; &nbsp;...<br> &nbsp;}<br>...<br>}</p><p>Now we know that the content item is of type <code>fact_about_us</code> which corresponds to generated data model <code>FactAboutUsContentType</code>. Therefore we need to translate the type name to pascal case and ensure that GraphQL uses the right data model. We can ensure this using a special resolver for the generic data model:</p><p>...<br>const resolvers = {<br> &nbsp;ContentItem: {<br> &nbsp; &nbsp;__resolveType(item, _context, _info) {<br> &nbsp; &nbsp;// fact_about_us -&gt; FactAboutUs<br> &nbsp; &nbsp;const type = convertSnakeCaseToPascalCase(item);<br> &nbsp; &nbsp;// FactAboutUs -&gt; FactAboutUsContentType<br> &nbsp; &nbsp;return type + 'ContentType';<br> &nbsp;}<br>},<br>...</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/graphQL/queries.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>And add a simple function to translate the type name to the data model name:</p><p>...<br>// fact_about_us -&gt; FactAboutUs<br>const convertSnakeCaseToPascalCase = (item) =&gt; {<br> &nbsp;return item.system.type<br> &nbsp; &nbsp;.split('_')<br> &nbsp; &nbsp;.map((str) =&gt; str.slice(0, 1).toUpperCase() + str.slice(1, str.length))<br> &nbsp; &nbsp;.join('');<br> &nbsp;}<br>...</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/graphQL/queries.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>You see that for the implementation of the resolver you need to know the target service API, or in this case the specifics of the SDK. The developer working on the front-end only needs to know the GraphQL schema regardless of the services you use.</p><h1 id="putting-it-all-together">Putting It All Together</h1><p>To bring our data models, queries and resolvers to life, we need to create the Apollo server instance in the main <code>app.js</code> file and connect it with Express and our GraphQL schema definitions:</p><p>const { TYPE_DEFINITION } = require('./graphQL/types');<br>const { queryTypes, resolvers } = require('./graphQL/queries');<br>const app = express();<br>const apolloServer = new ApolloServer({<br> &nbsp;introspection: true,<br> &nbsp;playground: true,<br> &nbsp;typeDefs: [<br> &nbsp; &nbsp;TYPE_DEFINITION,<br> &nbsp; &nbsp;queryTypes<br> &nbsp;],<br> &nbsp;resolvers<br>});<br>apolloServer.applyMiddleware({<br> &nbsp;app,<br> &nbsp;path: graphQLPath<br>});</p><p><em><em>(See the whole file on </em></em><a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/app.js" rel="noopener nofollow"><em><em>GitHub</em></em></a><em><em>.)</em></em></p><p>In this code, we are telling Apollo which schema to use. The definitions are provided in the <code>typeDefs</code> array and correspond to previously created queries and resolvers.</p><p>The rest of the code in <code>app.js</code> (omitted here, but you may take a look at the <a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/master/app.js" rel="noopener nofollow">whole file on GitHub</a>) is related to Pug templating and routing engine. Pug enables building pages and routes in MVC structure, so it’s easy and straightforward. Take a look at the <code>routes/index.js</code> file (<a href="https://github.com/Kentico/cloud-boilerplate-express-apollo/blob/routes/index.js" rel="noopener nofollow">file on GitHub</a>) that contains the definition of the only route in the boilerplate project:</p><p>...<br>router.get('/', async function (_req, res, _next) {<br> &nbsp;const result = await apolloClient.query({<br> &nbsp; &nbsp;query: gql`<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;itemsByType(type: "article", limit: 3, depth: 0, order: "elements.post_date") {<br> &nbsp; &nbsp; &nbsp; &nbsp;... on ArticleContentType {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;title {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;summary {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;teaser_image {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assets {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;url<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}`<br> &nbsp;});<br> &nbsp;res.render('index', {<br> &nbsp; &nbsp;articles: result.data.itemsByType,<br> &nbsp; &nbsp;...<br> &nbsp;});<br>});module.exports = router;</p><p>Yes! Finally, a GraphQL query. You see it requests all articles ordered by <code>post_date</code> and specifies which data fields should be provided in the response (<code>title</code>, <code>summary</code>, <code>teaser_image</code>).</p><p>Note here that in the query we need to specify which data model we are expecting because not all children of <code>ContentItem</code> must contain requested fields (for example <code>summary</code> or <code>teaser_image</code>). By <code>… on ArticleContentType</code> we are basically creating a <code>switch</code> case that will return defined fields (<code>title</code>, <code>summary</code> and <code>teaser_image</code>) if the returned content item is of type <code>ArticleContentType</code>.</p><p>The Apollo Client sends this request to the Apollo Server which forwards it to the Kentico Cloud resolver. The resolver translates the GraphQL query into the REST API. The content takes the same way back to Pug which renders the page according to template in <code>views/index.pug</code>.</p><p>How does it all work together? Take a look at the <a href="http://bit.ly/2GGHIB5" rel="noopener nofollow">live demo</a>.</p><h1 id="spare-some-time-for-a-beer">Spare Some Time for a Beer</h1><p>All the tools I’ve used and shown you are easy to put together, but why reinvent the wheel? When you want to start implementing a website using Apollo and React or any other JavaScript framework, remember this boilerplate to save yourself some time and effort. If you find anything missing or wish to enhance it, feel free to <a href="http://bit.ly/2ByzwiJ" rel="noopener nofollow">raise an issue</a> or <a href="http://bit.ly/2TGTmPW" rel="noopener nofollow">add it directly</a> to the code base.</p><p>Do you have experience using Apollo and GraphQL to separate concerns? Would you recommend it to others? Let me know in comments.</p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
