---
card: "https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png"
tags: [Ember]
description: "Welcome to ELI5 Full Stack: Breakthrough with Django & EmberJ"
author: "Milad E. Fahmy"
title: "ELI5 Full Stack Basics: breakthrough with Django & EmberJS"
created: "2021-08-16T15:40:25+02:00"
modified: "2021-08-16T15:40:25+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-ember tag-django tag-javascript tag-python tag-tech ">
<header class="post-full-header">
<h1 class="post-full-title">ELI5 Full Stack Basics: breakthrough with Django &amp; EmberJS</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*-YXdpMxaFFkY2QKdxgIsFQ.png" alt="ELI5 Full Stack Basics: breakthrough with Django &amp; EmberJS">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
- server
- server
- books
- api
- db.sqlite3
- manage.py
- client
- app
- adapters
- controllers
- models
- routes
- templates
- styles
router.js</code></pre><p>These aren’t all the folders and files that the project will contain, though they’re the main ones. You’ll notice quite a few autogenerated files that you can ignore. Though it would be useful for you to read documentation that explains their purpose.</p><p>The <code>my_library</code> directory contains folders for the back end and front end sub-projects. <code>server</code> refers to the Django back end, and <code>client</code> refers to the EmberJS front end.</p><h4 id="1-4-1-back-end">1.4.1 Back End</h4><ul><li><code>server</code> contains another folder called <code>server</code>. Inside are the top level configurations and settings for the back end.</li><li>The <code>books</code> folder will contain all the models, views, and other configuration for the book data.</li><li>Inside the <code>books/api</code> folder we’ll create the serializers, URLs, and views that make up our REST API.</li></ul><h4 id="1-4-2-front-end">1.4.2 Front End</h4><ul><li><code>client</code> is our EmberJS front end. It contains routes, templates, models, controllers, adapters, and styles. <code>router.js</code> describes all the application routes.</li></ul><p>Let’s go ahead and set up the main project directory <code>my_library</code>.</p><h3 id="1-5-project-directory-setup">1.5 Project Directory Setup</h3><h4 id="1-5-1-create-the-main-project-folder-my_library">1.5.1 Create the main project folder: my_library</h4><p>Now that we know what we’re going to build, let’s take a few minutes to set up the main project directory <code>my_library</code>:</p><pre><code># cd into desktop and create the main project folder
cd ~/desktop &amp;&amp; mkdir my_library</code></pre><p>Create a basic <code>README.md</code> file inside the folder with the following content:</p><pre><code># my_library
# check that it's been set, should display the origin
git remote -v</code></pre><p>Time to push our code to Github:</p><pre><code># check the status of our repo
# should show the new file README.md, no previous commits
git status
# add all changes
git add .
# create a commit with a message
git commit -m "[BASE] Project Start"
# push changes to the repo's master branch
cd ~/desktop
# download the pip Python script
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
# run the script
python get-pip.py
# once installation completes, verify that it's installed
pip —-version</code></pre><p>Full installation documentation is available <a href="https://pip.pypa.io/en/latest/installing/#installing-with-get-pip-py" rel="noopener">here</a>.</p><h4 id="2-1-3-virtualenv">2.1.3 virtualenv</h4><p>virtualenv is a ‘<em>tool to create isolated Python environments’. </em>These environments have their own installation directories. They don’t share libraries with others. Such silos protect the globally installed libraries from unwanted changes.</p><p>With it we can play with Python libraries without messing up the global environment. For example, you install <code>exampleSoftware 1.0</code> on your computer. With a virtual environment activated you can upgrade to <code>exampleSoftware 1.2</code> and use it. This won’t affect the global install of <code>exampleSoftware 1.0</code> at all.</p><p>For the development of a particular app you may want to use <code>1.2</code> and for other contexts <code>1.0</code> will be appropriate. Virtual environments give us the ability to separate these contexts. Full installation documentation is available <a href="https://virtualenv.pypa.io/en/stable/installation/" rel="noopener">here</a>.</p><p>Now, open up the terminal to install virtualenv:</p><pre><code># use pip to install virtualenv
pip install virtualenv
# verify that it's installed
virtualenv —-version</code></pre><p>Let’s create a directory to house our virtual environments:</p><pre><code># cd into the root directory
cd ~/
# create a hidden folder called .envs for virtual environments
mkdir .envs
# cd into the virtual environments directory
cd .envs</code></pre><p>We can now create a virtual environment for our project:</p><pre><code># create a virtual environment folder: my_library
virtualenv my_library
# activate the virtual environment from anywhere using
pip install Django==1.11
# verify that it's installed, open up the Python shell
python
# access the django library and get the version (should be 1.11)
import django
print(django.get_version())
# exit using keyboard shortcut ctrl+D or:
exit()</code></pre><p>Full installation documentation is available <a href="https://docs.djangoproject.com/en/1.11/topics/install/" rel="noopener">here</a>.</p><h3 id="2-2-start-a-django-project-server">2.2 Start a Django Project: server</h3><p>Let’s use the <a href="https://docs.djangoproject.com/en/2.1/ref/django-admin/" rel="noopener">django-admin </a>to generate a new Django project. This is Django’s ‘<em>command-line utility for administrative tasks</em>’:</p><pre><code># cd into the project folder
cd ~/desktop/my_library
# initialize the virtual environment
source ~/.envs/my_library/bin/activate
# use Django to create a project: server
django-admin startproject server
# cd into the new Django project
cd server
# synchronize the database
python manage.py migrate
# run the Django server
my_library/server/server/config.json</code></pre><p>Inside we’ll store our <code>SECRET_KEY</code> value from <code>settings.py</code> under <code>API_KEY</code>:</p><pre><code>{
"API_KEY" : "abcdefghijklmopqrstuvwxyz123456789"
}</code></pre><p>In <code>settings.py</code> import the <code>json</code> library and load the config variables:</p><pre><code class="language-py">import os
import json
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
with open(BASE_DIR + '/server/config.json', 'r') as config:
obj = json.load(config)
SECRET_KEY = obj["API_KEY"]
...</code></pre><p>So that <code>config.json</code> (with the secret key) isn’t pushed to the repository, create a <code>.gitignore</code> file in <code>my_library</code>. This ignores it (along with some other autogenerated files and the database):</p><pre><code>### Django ###
config.json
*.log
*.pot
*.pyc
__pycache__/
local_settings.py
db.sqlite3
python manage.py startapp books
# creates directory: my_library/server/books</code></pre><p>Now we’ll install the <code>books</code> app into the <code>server</code> project. Open the settings file: <code>my_library/server/server/settings.py</code>.</p><p>Scroll to the <code>INSTALLED_APPS</code> array. Django has installed it's own core apps by default. Install the <code>books</code> app at the end of the array:</p><pre><code>INSTALLED_APPS = [
...
'books'
]</code></pre><h3 id="2-4-describe-the-book-model">2.4 Describe the Book model</h3><p>Next we describe the <code>Book</code> model in the books app. Open the models file <code>my_library/server/books/models.py</code>.</p><p>Describe a <code>Book</code> model which tells Django that every book in the database will have:</p><ul><li>a <code>title</code> field up to 500 characters in length</li><li>an <code>author</code> field up to 100 characters</li><li>a <code>description</code> field with an open-ended number of characters</li></ul><pre><code class="language-py">from django.db import models
class Book(models.Model):
title = models.CharField(max_length=500)
author= models.CharField(max_length=100)
description = models.TextField()</code></pre><h3 id="2-5-register-the-book-model-with-the-admin">2.5 Register the Book model with the admin</h3><p>Now we register the <code>Book</code> model with the admin for our <code>books</code> app. This lets us view it in the admin site and manipulate the books data from there. Open the admin file <code>my_library/server/books/admin.py</code> and add:</p><pre><code class="language-py">from django.contrib import admin
from .models import Book
@admin.register(Book)
class bookAdmin(admin.ModelAdmin):
list_display = ['title', 'author', 'description']</code></pre><p>With a new model created we’ll have to make and run <a href="https://docs.djangoproject.com/en/2.1/ref/django-admin/#django-admin-makemigrations" rel="noopener">migrations</a> so that the database synchronizes:</p><pre><code>python manage.py makemigrations
cd ~/desktop/my_library
# activate the virtual environment
source ~/.envs/my_library/bin/activate
# install Django REST Framework
pip install djangorestframework
# install Markdown support for the browsable API
pip install markdown</code></pre><p>Now open up <code>my_library/server/server/settings.py</code>. Install DRF right above the <code>books</code> app in the <code>INSTALLED_APPS</code> array:</p><pre><code>INSTALLED_APPS = [
...
'rest_framework',
'books'
]</code></pre><p>Add the default settings at the bottom of the file as an object called <code>REST_FRAMEWORK</code>:</p><pre><code>REST_FRAMEWORK = {
'DEFAULT_PERMISSION_CLASSES': [
'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'
]
from books.models import Book
class bookSerializer(serializers.ModelSerializer):
class Meta:
model = Book
fields = (
'id',
'title',
'author',
'description',
)</code></pre><p>This serializer takes the data and transforms it into the JSON format. This ensures that it’s understandable to the front end.</p><h4 id="imports"><strong>Imports</strong></h4><p>We import built-in <code>serializers</code> from DRF, and the <code>Book</code> model from our <code>books</code> app.</p><pre><code>from rest_framework import serializers
from books.models import Book</code></pre><h4 id="the-bookserializer-class"><strong>The bookSerializer Class</strong></h4><p>For this project we want a <code>Serializer</code> class that ‘<em>corresponds to the Model fields</em>’. The serializer should map to the model fields <code>title</code>, <code>author</code>, and <code>description</code>. We can do this with the <code><a href="http://www.django-rest-framework.org/api-guide/serializers/#modelserializer" rel="noopener">ModelSerializer</a></code>. According to the documentation:</p><p>The <code>ModelSerializer</code> class is the same as a regular <code>Serializer</code> class, except that:</p><ul><li>It will generate a set of fields for you, based on the model.</li><li>It will generate validators for the serializer, such as unique_together validators.</li><li>It includes simple default implementations of <code>.create()</code> and <code>.update()</code>.</li></ul><p>The built-in tools are more than capable of handling our basic needs.</p><pre><code class="language-py">class bookSerializer(serializers.ModelSerializer):
class Meta:
model = Book
fields = (
'id',
'title',
'author',
'description',
)</code></pre><h3 id="3-4-create-a-view-to-get-and-post-books-data">3.4 Create a view to GET and POST books data</h3><p>View functions take in a web request and return web responses. A web request to <code>localhost:8000/api/books</code> for example elicits a response from the server.</p><p>This response can be ‘<em>HTML contents of a Web page, or a redirect, or a 404 error, or an XML document, or an image . . . or anything…</em>’ In our case we expect to get back books data structured in the JSON format.</p><p>Create the views file in <code>my_library/server/books/api/views.py</code>:</p><pre><code class="language-py">from rest_framework import generics, mixins
from books.models import Book
from .serializers import  bookSerializer
class bookAPIView(mixins.CreateModelMixin, generics.ListAPIView):
resource_name = 'books'
serializer_class = bookSerializer
def get_queryset(self):
return Book.objects.all()
def post(self, request, *args, **kwargs):
return self.create(request, *args, **kwargs)</code></pre><h4 id="imports-1"><strong>Imports</strong></h4><p>First we import <code><a href="http://www.django-rest-framework.org/api-guide/generic-views/#genericapiview" rel="noopener">generics</a></code> and <code><a href="http://www.django-rest-framework.org/api-guide/generic-views/#mixins" rel="noopener">mixins</a></code> from DRF. Then the <code>Book</code> model from our <code>books</code> app and the <code>bookSerializer</code> that we created.</p><p><code>generics</code> refers to API views that ‘<em>map to your database models</em>’. These are ‘<em>pre-built views that provide for common patterns</em>’. <code>mixins</code> are classes that ‘<em>provide the actions that used to provide the basic view behavior</em>’. Our book model is simplistic. It only has <code>title</code>, <code>author</code>, and <code>description</code> attributes so these provide us with the basics we need.</p><pre><code class="language-py">from rest_framework import generics, mixins
from books.models import Book
from .serializers import  bookSerializer</code></pre><h4 id="the-bookapi-view"><strong>The bookAPI View</strong></h4><p>We then create a <code>bookAPIView</code> which takes in the <code><a href="http://www.django-rest-framework.org/api-guide/generic-views/#createmodelmixin" rel="noopener">CreateModelMixin</a></code> and <code><a href="http://www.django-rest-framework.org/api-guide/generic-views/#listapiview" rel="noopener">ListAPIView</a></code>.</p><p><code>CreateModelMixin</code> provides a <code>.create(request, *args, **kwargs)</code> method<em>. </em>This<em> </em>implements the creation and persistence of a new model instance. When successful it returns a <code>201 Create</code> response. This comes with a serialized representation of the object that it created.</p><p>For example, we would make a POST request to create a new book record for the Steve Jobs book by Walter Isaacson. If successful we get back a response with the code <code>201</code>. The serialized representation of the book record like so:</p><pre><code class="language-py">{
"data": {
"type": "books",
"id":"10",
"attributes": {
"title": "Steve Jobs",
"author": "Walter Isaacson",
"description": "Based on more than forty interviews with Jobs conducted over two years—as..."
}
}
}</code></pre><p>When unsuccessful, we’ll get back a <code>400 Bad Request</code> response with errors details. For example, if we try to create a new book record but don’t provide any <code>title</code> information:</p><pre><code class="language-json">{
"errors":[
{
"status": "400",
"source": {
"pointer": "/data/attributes/title"
},
"detail": "This field may not be blank."
}
]
}</code></pre><p><code>ListAPIView</code> serves our read-only endpoints (GET). It represents ‘<em>a collection of model instances</em>’. We use it when we want to get all or many books.</p><p><code>bookAPIView</code> also takes in the recently created <code>bookSerializer</code> for its <code>serializer_class</code>.</p><p>We set the <code>resource_name</code> to ‘books’ to ‘<em>specify the</em> <em>type</em> <em>key in the json output</em>’. The front end client data store layer will have a <code>book</code> model that is case sensitive. We don’t want to <code>book</code> model in Ember and the <code>Book</code> model in Django to clash. Setting the <code>resource_name</code> here nips that issue in the bud.</p><pre><code class="language-py">class bookAPIView(mixins.CreateModelMixin, generics.ListAPIView):
resource_name = 'books'
serializer_class = bookSerializer</code></pre><h4 id="functions"><strong>Functions</strong></h4><p>The function <code>get_queryset</code> returns all the book objects in the database. <code>post</code> takes in the request and arguments and creates a new database record of a book if the request is valid.</p><pre><code class="language-py">def get_queryset(self):
return Book.objects.all()
def post(self, request, *args, **kwargs):
return self.create(request, *args, **kwargs)</code></pre><h3 id="3-5-create-urls-to-access-books-data">3.5 Create URLs to access books data</h3><p>URL patterns map a URL to views. For example, visiting <code>localhost:8000/api/books</code> should map to a URL pattern. That then returns the results of a query to that view.</p><p>Create the URLs file in <code>my_library/server/books/api/urls.py</code>:</p><pre><code class="language-py">from .views import bookAPIView
from django.conf.urls import url
urlpatterns = [
url(r'^$', bookAPIView.as_view(), name='book-create'),
]</code></pre><h4 id="imports-2"><strong>Imports</strong></h4><p>We import our view <code>bookAPIView</code> and <code>url</code>. We’ll use <code>url</code> to create a list of url instances.</p><pre><code class="language-py">from .views import bookAPIView
from django.conf.urls import url</code></pre><h4 id="booksapi-url-patterns"><strong>booksAPI URL patterns</strong></h4><p>In the <code>urlpatterns</code> array we create a URL pattern with the following structure:</p><ul><li>the pattern <code>r'^$'</code></li><li>the Python path to the view <code>bookAPIView.as_view()</code></li><li>the name <code>name='book-create'</code></li></ul><p>The pattern <code>r’^$’</code>is a regular expression that ‘<a href="https://stackoverflow.com/a/31057541/5513243" rel="noopener"><em>matches an empty line/string</em></a>’. This means it matches to <code>localhost:8000</code>. It matches to anything that comes after the base URL.</p><p>We call <code><a href="https://docs.djangoproject.com/en/1.11/ref/class-based-views/base/#django.views.generic.base.View.as_view" rel="noopener">.as_view()</a></code> on <code>bookAPIView</code> because to connect the view to the url. It ‘<a href="https://stackoverflow.com/a/31491074/5513243" rel="noopener"><em>is the function(class method) which will connect [the] class with its url</em></a>’. Visit a particular URL and the server attempts to match it to the URL pattern. That pattern will then return the <code>bookAPI</code> view results that we’ve told it to respond with.</p><p>The <code>name=’book-create’</code> attribute provides us with a <code>name</code> attribute. We use it to refer to our URL throughout the project. Let’s say you want to change the URL or the view it refers to. Change it here. Without <code>name</code> we would have to go through the entire project to update every reference. Check out <a href="https://stackoverflow.com/a/11241936/5513243" rel="noopener">this thread</a> to find out more.</p><pre><code>urlpatterns = [
url(r'^$', bookAPIView.as_view(), name='book-create'),
]</code></pre><h4 id="server-url-patterns"><strong>server URL patterns</strong></h4><p>Now let’s open up <code>server</code>’s URLs file <code>my_library/server/server/urls.py</code>:</p><pre><code class="language-py">from django.conf.urls import url, include
from django.contrib import admin
urlpatterns = [
url(r'^admin/', admin.site.urls),
url(r'^api/books', include('books.api.urls',
namespace='api-books'))
npm install -g ember-cli
# check that it's installed
cd ~/desktop/my_library
# create a new app: client
ember new client
# cd into the directory
cd client
# run the server
### Ember ###
/client/dist
/client/tmp
# dependencies
/client/node_modules
/client/bower_components
# misc
/client/.sass-cache
/client/connect.lock
/client/coverage/*
/client/libpeerconnection.log
/client/npm-debug.log
/client/testem.log
# ember-try
/client/.node_modules.ember-try/
/client/bower.json.ember-try
/client/package.json.ember-try</code></pre><h3 id="4-3-displaying-books-data">4.3 Displaying books data</h3><h4 id="4-3-1-setup-the-dom">4.3.1 Setup the DOM</h4><p>Now that we’ve generated a base project, let’s set up a basic DOM and styles. I’m not doing anything fancy here. It’s the least necessary to have our data displaying in a readable format.</p><p>Locate the file <code>client/app/templates/application.hbs</code>. Get rid of <code>{{welcome-page}}</code> and the comments .</p><p>Next, create a <code>div</code> with the class <code>.nav</code>. Use Ember’s built-in <code><a href="https://guides.emberjs.com/release/templates/links/" rel="noopener">{{#link-to}}</a></code> helper to create a link to the route <code>books</code>(we’ll create it later):</p><pre><code class="language-html">&lt;div class="nav"&gt;
{{#link-to 'books' class="nav-item"}}Home{{/link-to}}
&lt;/div&gt;</code></pre><p>Wrap everything including the<code><a href="https://guides.emberjs.com/release/routing/rendering-a-template/" rel="noopener">{{outlet}}</a></code> in a <code>div</code> with the <code>.container</code> class. Each route template will render inside <code>{{outlet}}</code>:</p><pre><code class="language-html">&lt;div class="container"&gt;
&lt;div class="nav"&gt;
{{#link-to 'books' class="nav-item"}}Home{{/link-to}}
&lt;/div&gt;
{{outlet}}
&lt;/div&gt;</code></pre><p>This is the template for the parent level <code>application</code> route. any sub-routes like <code>books</code> will render inside the <code>{{outlet}}</code>. This means that the <code>nav</code> will always be visible on screen.</p><h4 id="4-3-2-create-styles">4.3.2 Create styles</h4><p>I’m not going to get into the nitty-gritty of the CSS. It’s pretty simple to figure out. Locate the file <code>client/app/styles/app.css</code> and add the following styles:</p><p><strong>Variables and Utilities</strong></p><pre><code class="language-css">:root {
--color-white:  #fff;
--color-black:  #000;
--color-grey:   #d2d2d2;
--color-purple: #6e6a85;
--color-red:    #ff0000;
--font-size-st: 16px;
--font-size-lg: 24px;
--box-shadow: 0 10px 20px -12px rgba(0, 0, 0, 0.42),
0 3px  20px  0px  rgba(0, 0, 0, 0.12),
0 8px  10px -5px  rgba(0, 0, 0, 0.2);
}
.u-justify-space-between {
justify-content: space-between !important;
}
.u-text-danger {
color: var(--color-red) !important;
}</code></pre><p><strong>General</strong></p><pre><code class="language-css">body {
margin: 0;
padding: 0;
font-family: Arial;
}
.container {
display: grid;
grid-template-rows: 40px calc(100vh - 80px) 40px;
height: 100vh;
display: flex;
padding: 0 10px;
background-color: var(--color-purple);
box-shadow: var(--box-shadow);
z-index: 10;
}
.nav-item {
padding: 10px;
font-size: var(--font-size-st);
color: var(--color-white);
text-decoration: none;
}
.nav-item:hover {
background-color: rgba(255, 255, 255, 0.1);
padding: 10px 0;
font-size: var(--font-size-lg);
padding: 10px;
overflow-y: scroll;
}
.book {
display: flex;
justify-content: space-between;
padding: 15px 10px;
font-size: var(--font-size-st);
color: var(--color-black);
text-decoration: none;
cursor: pointer;
}
.book:hover {
background: var(--color-grey);
cursor: pointer;
}</code></pre><p><strong>Book Detail</strong></p><pre><code class="language-css">.book.book--detail {
flex-direction: column;
justify-content: flex-start;
max-width: 500px;
background: var(--color-white);
cursor: default;
}
.book-title {
font-size: var(--font-size-lg);
}
.book-title,
.book-author,
.book-description {
padding: 10px;
display: flex;
flex-direction: column;
padding: 10px 20px;
background: var(--color-white);
}
input[type='text'],
textarea {
margin: 10px 0;
padding: 10px;
max-width: 500px;
font-size: var(--font-size-st);
border: none;
border-bottom: 1px solid var(--color-grey);
outline: 0;
display: flex;
flex-direction: row;
justify-content: flex-end;
padding: 10px 20px;
background-color: var(--color-white);;
box-shadow: var(--box-shadow)
import config from './config/environment';
const Router = EmberRouter.extend({
location: config.locationType,
rootURL: config.rootURL
});
Router.map(function() {
this.route('books');
});
export default Router;</code></pre><h4 id="4-4-2-load-fake-data-in-the-model-hook"><strong>4.4.2 Load fake data in the model hook</strong></h4><p>Let’s edit the books route <code>client/app/routes/books.js</code> to load all books from the database.</p><pre><code class="language-js">import Route from '@ember/routing/route';
export default Route.extend({
model() {
return [
{title: 'Monkey Adventure'},
{title: 'Island Strife'},
{title: 'The Ball'},
{title: 'Simple Pleasures of the South'},
{title: 'Big City Monkey'}
]
}
});</code></pre><p>The model hook is returning an array of objects. This is fake data for demonstration purposes. We’ll come back here later and load the actual data from the database using Ember Data when we’re ready.</p><h4 id="4-4-3-update-the-books-route-template"><strong>4.4.3 Update the books route template</strong></h4><p>Let’s edit the books route template <code>client/app/templates/books.hbs</code>. We want to display the books returned in the model.</p><pre><code class="language-html">&lt;div class="book-list"&gt;
{{#each model as |book|}}
&lt;div class="book"&gt;
{{book.title}}
&lt;/div&gt;
{{/each}}
export default Route.extend({
redirect() {
this.transitionTo('books');
}
import { computed } from '@ember/object';
export default DS.JSONAPIAdapter.extend({
host: computed(function(){
return 'http://localhost:8000';
}),
namespace: 'api'
export default DS.Model.extend({
title: DS.attr(),
author: DS.attr(),
description: DS.attr()
});</code></pre><p>The attributes are the same as those we’ve defined in the back end. We define them again so that Ember Data knows what to expect from the structured data.</p><h4 id="4-5-3-update-the-books-route">4.5.3 Update the <code>books</code> route</h4><p>Let’s update the books route by importing the <code>store</code> service and using it to request data.</p><pre><code class="language-js">import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
export default Route.extend({
store: service(),
model() {
const store = this.get('store');
return store.findAll('book');
}
...
'books',
'corsheaders'
]</code></pre><p>Add it to the top of the <code>MIDDLEWARE</code> array:</p><pre><code>MIDDLEWARE = [
'corsheaders.middleware.CorsMiddleware',
...
{
"id": 1,
"title": "Conquistador",
"author": "Buddy Levy",
"description": "It was a moment unique in ..."
},
{
"id": 2,
"title": "East of Eden",
"author": "John Steinbeck",
"description": "In his journal, Nobel Prize ..."
}
]</code></pre><p>Although get an array of objects in JSON format, it’s still not in the format we want it to be. This is what Ember Data expects:</p><pre><code class="language-json">{
data: [
{
id: "1",
type: "book",
attributes: {
title: "Conquistador",
author: "Buddy Levy",
description: "It was a moment unique in ..."
}
},
{
id: "2",
type: "book",
attributes: {
title: "East of Eden",
author: "John Steinbeck",
description: "In his journal, Nobel Prize ..."
}
}
]
pip install djangorestframework-jsonapi</code></pre><p>Next, update DRF settings in <code>server/server/settings.py</code>:</p><pre><code>REST_FRAMEWORK = {
'PAGE_SIZE': 100,
'EXCEPTION_HANDLER':
'rest_framework_json_api.exceptions.exception_handler',
'DEFAULT_PAGINATION_CLASS':    'rest_framework_json_api.pagination.JsonApiPageNumberPagination',
'DEFAULT_PARSER_CLASSES': (
'rest_framework_json_api.parsers.JSONParser',
'rest_framework.parsers.FormParser',
'rest_framework.parsers.MultiPartParser'
),
'DEFAULT_RENDERER_CLASSES': (
'rest_framework_json_api.renderers.JSONRenderer',
'rest_framework.renderers.BrowsableAPIRenderer',
),
'DEFAULT_METADATA_CLASS': 'rest_framework_json_api.metadata.JSONAPIMetadata',
'DEFAULT_FILTER_BACKENDS': (
'rest_framework.filters.OrderingFilter',
),
'ORDERING_PARAM': 'sort',
'TEST_REQUEST_RENDERER_CLASSES': (
'rest_framework_json_api.renderers.JSONRenderer',
),
'TEST_REQUEST_DEFAULT_FORMAT': 'vnd.api+json'
}</code></pre><p>These override the default settings for DRF with defaults from the JSON API. I increased the <code>PAGE_SIZE</code> so we can get up to 100 books back in a response.</p><h3 id="5-2-working-with-individual-book-records">5.2 Working with individual book records</h3><h4 id="5-2-1-create-a-view">5.2.1 Create a view</h4><p>Let’s also update our <code>books</code> API so that we can retrieve single instances of a book record.</p><p>Create a new view called<code>bookRudView</code> in <code>server/books/api/views.py</code>:</p><pre><code class="language-py">class bookRudView(generics.RetrieveUpdateDestroyAPIView):
resource_name = 'books'
lookup_field  = 'id'
serializer_class    = bookSerializer
def get_queryset(self):
return Book.objects.all()</code></pre><p>This view uses the <code>id</code> <code>lookup_field</code> to retrieve an individual book record. The <a href="http://www.django-rest-framework.org/api-guide/generic-views/#retrieveupdatedestroyapiview" rel="noopener">RetrieveUpdateDestroyAPIView </a>provides basic <code>GET</code>, <code>PUT</code>, <code>PATCH</code> and <code>DELETE</code> method handlers. As you might imagine these let us create, update, and delete individual book data.</p><h4 id="5-2-2-update-the-book-api-urls">5.2.2 Update the book API URLs</h4><p>We’ll need to create a new URL pattern that delivers data through the <code>bookRudView</code>.</p><pre><code class="language-py">from .views import bookAPIView, bookRudView
from django.conf.urls import url
urlpatterns = [
url(r'^$', bookAPIView.as_view(), name='book-create'),
url(r'^(?P&lt;id&gt;\d+)', bookRudView.as_view(), name='book-rud')
]</code></pre><p>Import <code>bookRudView</code>, match it to the pattern <code>r'^(?P&lt;id&gt;</code>;\d+)', and give it the name <code>book-rud</code>.</p><h4 id="5-2-3-update-the-server-urls">5.2.3 Update the server URLs</h4><p>Finally, update the <code>books</code> API URL pattern in <code>server/server/urls.py</code>. We want to match to patterns which begin after <code>books/</code>:</p><pre><code>...
urlpatterns = [
...
url(r'^api/books/?', include('books.api.urls', namespace='api-books')),
Router.map(function() {
this.route('books');
this.route('book', { path: 'books/:book_id' });
});
...</code></pre><p>Next update the <code>book</code> route <code>client/app/routes/book.js</code> to retrieve a single book record from the database:</p><pre><code>import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
export default Route.extend({
store: service(),
model(book) {
return this.get('store').peekRecord('book', book.book_id);
}
});</code></pre><p>As outlined in <code>router.js</code> the <code>book</code> route takes in the <code>book_id</code> parameter. The parameter goes into the route’s <code>model</code> hook and we use it to retrieve the book with the Ember Data <code>store</code>.</p><h4 id="5-3-2-update-the-book-template">5.3.2 Update the <code>book</code> template</h4><p>Our <code>client/app/templates/book.hbs</code> template should display the book data we get back from the <code>store</code>. Get rid of <code>{{outlet}}</code> and update it:</p><pre><code class="language-html">&lt;div class="book book--detail"&gt;
&lt;div class="book-title"&gt;
{{model.title}}
&lt;/div&gt;
&lt;div class="book-author"&gt;
{{model.author}}
&lt;/div&gt;
&lt;div class="book-description"&gt;
{{model.description}}
&lt;/div&gt;
&lt;/div&gt;</code></pre><p>Like in the <code>books</code> template we access the <code>model</code> attributes using <a href="https://codeburst.io/javascript-quickie-dot-notation-vs-bracket-notation-333641c0f781" rel="noopener">dot notation</a>.</p><h4 id="5-3-3-update-the-books-template">5.3.3 Update the <code>books</code> template</h4><p>Finally, let’s update the <code>books</code> template. We want to link to each individual book page as displayed in the <code>book</code> route we created:</p><pre><code class="language-html">&lt;div class="book-list"&gt;
{{#each model as |book|}}
{{#link-to 'book' book.id class="book"}}
{{book.title}}
{{/link-to}}
{{/each}}
import { computed } from '@ember/object';
export default Controller.extend({
form: computed(function() {
return {
title: '',
author: '',
description: ''
}
})
});</code></pre><h4 id="6-1-3-setup-the-create-book-route">6.1.3 Setup the <code>create-book</code> route</h4><p>In <code>client/app/routes/create-book.js</code> we do the following:</p><ul><li>create actions to confirm creation of a new book</li><li>cancel the creation process</li><li>use a route hook to clear the form data upon entering the route:</li></ul><pre><code class="language-js">import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
export default Route.extend({
store: service(),
setupController(controller, model) {
this._super(controller, model);
this.controller.set('form.title', '');
this.controller.set('form.author', '');
this.controller.set('form.description', '');
},
actions: {
create() {
const form = this.controller.get('form');
const store = this.get('store');
const newBook = store.createRecord('book', {
title: form.title,
author: form.author,
description: form.description
});
newBook.save()
.then(() =&gt; {
this.transitionTo('books');
});
},
cancel() {
this.transitionTo('books');
}
}
});</code></pre><p>The <code>setupController</code> hook allows us to reset the form’s values. This is so that they don’t persist when we go back and forth through pages. We don’t want to click away to another page without having completed the create book process. If we do, we’ll come back to see the unused data still sitting in our form.</p><p>The <code>create()</code> action will take the form data and create a new record with the Ember Data <code>store</code>. It then persists it to the Django back end. Once complete it will transition the user back to the <code>books</code> route.</p><p>The <code>cancel</code> button transitions the user back to the <code>books</code> route.</p><h4 id="6-1-4-setup-the-create-book-template">6.1.4 Setup the <code>create-book</code> template</h4><p>Next, in <code>client/app/template/create-book.hbs</code> we build the form:</p><pre><code class="language-html">&lt;form class="form"&gt;
&lt;div class="header"&gt;
Add a new book
&lt;/div&gt;
{{input
value=form.title
name="title"
placeholder="Title"
autocomplete='off'
}}
{{input
value=form.author
name="author"
placeholder="Author"
autocomplete='off'
}}
{{textarea
value=form.description
name="description"
placeholder="Description"
rows=10
}}
&lt;/form&gt;
&lt;div class="actions"&gt;
&lt;div&gt;
&lt;button {{action 'create'}}&gt;
Create
&lt;/button&gt;
&lt;button {{action 'cancel'}}&gt;
Cancel
&lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;</code></pre><p>The <code>form</code> uses the built-in <code>{{input}}</code> helpers to:</p><ul><li>take in values</li><li>display placeholders</li><li>turn autocomplete off.</li></ul><p>The <code>{{text}}</code> area helper works in a similar way, with the addition of the number of rows.</p><p>The actions <code>div</code> contains the two buttons to create and cancel. Each button ties to its namesake action using the <code>{{action}}</code> helper.</p><h4 id="6-1-5-update-the-books-route-template">6.1.5 Update the <code>books</code> route template</h4><p>The final piece of the create book puzzle is to add a button in the <code>books</code> route. It will get us into the <code>create-book</code> route and begin creating a new book.</p><p>Add on to the bottom of <code>client/app/templates/books.hbs</code>:</p><pre><code>...
{{#link-to 'create-book' class='btn btn-addBook'}}
Add Book
&lt;div class="actions {{if confirmingDelete
'u-justify-space-between'}}"&gt;
{{#if confirmingDelete}}
&lt;div class="u-text-danger"&gt;
Are you sure you want to delete this book?
&lt;/div&gt;
&lt;div&gt;
&lt;button {{action 'delete' model}}&gt;Delete&lt;/button&gt;
&lt;button {{action (mut confirmingDelete)false}}&gt;
Cancel
&lt;/button&gt;
&lt;/div&gt;
{{else}}
&lt;div&gt;
&lt;button {{action (mut confirmingDelete) true}}&gt;Delete&lt;/button&gt;
&lt;/div&gt;
{{/if}}
&lt;/div&gt;</code></pre><p>The <code>actions</code> <code>div</code> contains the buttons and text for the book deletion process.</p><p>We have a <code>bool</code> called <code>confirmingDelete</code> which will be set on the route’s <code>controller</code>. <code>confirmingDelete</code> adds the <code>.u-justify-space-between</code> utility class on <code>actions</code> when it’s <code>true</code>.</p><p>When it’s true, it also displays a prompt with the utility class <code>.u-text-danger</code>. This prompts the user to confirm deletion of the book. Two buttons show up. One to run <code>delete</code> action in our route. The other uses the <code>mut</code> helper to flip <code>confirmingDelete</code> to <code>false</code>.</p><p>When <code>confirmingDelete</code> is <code>false</code> (the default state) a single <code>delete</code> button display. Clicking it flips <code>confirmingDelete</code> to <code>true</code>. This then displays the prompt and the other two buttons.</p><h4 id="6-2-2-update-the-book-route">6.2.2 Update the <code>book</code> route</h4><p>Next update the <code>book</code> route. Under the <code>model</code> hook add:</p><pre><code>setupController(controller, model) {
this._super(controller, model);
this.controller.set('confirmingDelete', false);
},</code></pre><p>In <code>setupController</code> we call <code>this._super()</code>. This is so the controller goes through its usual motions before we do our business. Then we set <code>confirmingDelete</code> to <code>false</code>.</p><p>Why do we do this? Let’s say we start to delete a book, but leave the page without either cancelling the action or deleting the book. When we go to any book page <code>confirmingDelete</code> would be set to <code>true</code> as a leftover.</p><p>Next let’s create an <code>actions</code> object that will hold our route actions:</p><pre><code>actions: {
delete(book) {
book.deleteRecord();
book.save().then(() =&gt; {
this.transitionTo('books');
});
}
&lt;form class="form"&gt;
&lt;div class="header"&gt;Edit&lt;/div&gt;
{{input
value=form.title
placeholder="Title"
autocomplete='off'
}}
{{input
value=form.author
placeholder="Author"
autocomplete='off'
}}
{{textarea
value=form.description
placeholder="Description"
rows=10
}}
&lt;/form&gt;
&lt;div class="actions"&gt;
&lt;div&gt;
&lt;button {{action 'update' model}}&gt;Update&lt;/button&gt;
&lt;button {{action (mut isEditing) false}}&gt;Cancel&lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;
{{else}}
...
&lt;div&gt;
&lt;button {{action (mut isEditing) true}}&gt;Edit&lt;/button&gt;
&lt;button {{action (mut confirmingDelete) true}}&gt;Delete&lt;/button&gt;
&lt;/div&gt;
...
{{/if}}</code></pre><p>First let’s wrap the entire template in an <code>if</code> statement. This corresponds to the <code>isEditing</code> property which by default will be <code>false</code>.</p><p>Notice that the form is very almost identical to our create book form. The only real difference is that the actions <code>update</code> runs the <code>update</code> action in the <code>book</code> route. The <code>cancel</code> button also flips the <code>isEditing</code> property to <code>false</code>.</p><p>Everything we had before gets nested inside the <code>else</code>. We add the <code>Edit</code> button to flip <code>isEditing</code> to true and display the form.</p><h4 id="6-3-2-create-a-book-controller-to-handle-form-values">6.3.2 Create a <code>book</code> controller to handle form values</h4><p>Remember the <code>create-book</code> controller? We used it to hold the values that’s later sent to the server to create a new book record.</p><p>We’ll use a similar method to get and display the book data in our <code>isEditing</code> form. It will pre-populate the form with the current book’s data.</p><p>Generate a book controller:</p><pre><code>ember g controller book</code></pre><p>Open <code>client/app/controllers/book.js</code> and create a <code>form</code> computed property like before. Unlike before we’ll use the <code>model</code> to pre-populate our form with the current <code>book</code> data:</p><pre><code class="language-js">import Controller from '@ember/controller';
import { computed } from '@ember/object';
export default Controller.extend({
form: computed(function() {
const model = this.get('model');
return {
title: model.get('title'),
author: model.get('author'),
description: model.get('description')
}
})
});</code></pre><h4 id="6-3-3-update-the-book-route">6.3.3 Update the <code>book</code> route</h4><p>We’ll have to update our route again:</p><pre><code class="language-js">setupController(controller, model) {
...
this.controller.set('isEditing', false);
this.controller.set('form.title', model.get('title'));
this.controller.set('form.author', model.get('author'));
this.controller.set('form.description', model.get('description'));
},</code></pre><p>Let’s add on to the <code>setupController</code> hook. Set <code>isEditing</code> to <code>false</code> and reset all the form values to their defaults.</p><p>Next let’s create the <code>update</code> action:</p><pre><code class="language-js">actions: {
...
update(book) {
const form = this.controller.get('form');
book.set('title', form.title);
book.set('author', form.author);
book.set('description', form.description);
book.save().then(() =&gt; {
this.controller.set('isEditing', false);
});
}
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
