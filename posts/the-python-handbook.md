---
card: "/images/default.jpg"
tags: [Python]
description: "The Python Handbook follows the 80/20 rule: learn 80% of the "
author: "Milad E. Fahmy"
title: "The Python Handbook"
created: "2021-08-16T15:34:40+02:00"
modified: "2021-08-16T15:34:40+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-python tag-python-developer tag-learn-to-code tag-beginner ">
<header class="post-full-header">
<h1 class="post-full-title">The Python Handbook</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="/news/content/images/size/w300/2021/03/book.png 300w,
/news/content/images/size/w600/2021/03/book.png 600w,
/news/content/images/size/w1000/2021/03/book.png 1000w,
/news/content/images/size/w2000/2021/03/book.png 2000w">
<img onerror="this.style.display='none'" src="/news/content/images/size/w2000/2021/03/book.png" alt="The Python Handbook">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>I find this approach gives a well-rounded overview.</p>
<p>This book does not try to cover everything under the sun related to Python. It focuses on the core of the language, trying to simplify the more complex topics.</p>
<p>I hope the contents of this book will help you achieve what you want: <strong>learn the basics of Python</strong>.</p>
<blockquote>
<p>Note: You can <a href="https://flaviocopes.com/page/python-handbook/">get a PDF, ePub and Mobi version of this Python Handbook</a></p>
</blockquote>
<p>Enjoy!</p>
<ul>
<li><a href="#introductiontopython">Introduction to Python</a></li>
<li><a href="#howtoinstallpython">How to Install Python</a></li>
<li><a href="#howtorunpythonprograms">How to Run Python Programs</a></li>
<li><a href="#python2vspython3">Python 2 vs Python 3</a></li>
<li><a href="#pythonbasics">Python Basics</a></li>
<li><a href="#datatypesinpython">Data Types in Python</a></li>
<li><a href="#operators">Operators in Python</a></li>
<li><a href="#theternaryoperatorinpython">The Ternary Operator in Python</a></li>
<li><a href="#stringsinpython">Strings in Python</a></li>
<li><a href="#booleansinpython">Booleans in Python</a></li>
<li><a href="#numbersinpython">Numbers in Python</a></li>
<li><a href="#constantsinpython">Constants in Python</a></li>
<li><a href="#enumsinpython">Enums in Python</a></li>
<li><a href="#userinputinpython">User Input in Python</a></li>
<li><a href="#controlstatementsinpython">Control Statements in Python</a></li>
<li><a href="#listsinpython">Lists in Python</a></li>
<li><a href="#tuplesinpython">Tuples in Python</a></li>
<li><a href="#dictionariesinpython">Dictionaries in Python</a></li>
<li><a href="#setsinpython">Sets in Python</a></li>
<li><a href="#functionsinpython">Functions in Python</a></li>
<li><a href="#objectsinpython">Objects in Python</a></li>
<li><a href="#loopsinpython">Loops in Python</a></li>
<li><a href="#classesinpython">Classes in Python</a></li>
<li><a href="#modulesinpython">Modules in Python</a></li>
<li><a href="#thepythonstandardlibrary">The Python Standard Library</a></li>
<li><a href="#thepep8pythonstyleguide">The PEP8 Python Style Guide</a></li>
<li><a href="#debugginginpython">Debugging in Python</a></li>
<li><a href="#variablescopeinpython">Variable Scope in Python</a></li>
<li><a href="#howtoacceptargumentsfromthecommandlineinpython">How to Accept Arguments from the Command Line in Python</a></li>
<li><a href="#lambdafunctionsinpython">Lambda Functions in Python</a></li>
<li><a href="#recursioninpython">Recursion in Python</a></li>
<li><a href="#nestedfunctionsinpython">Nested Functions in Python</a></li>
<li><a href="#closuresinpython">Closures in Python</a></li>
<li><a href="#decoratorsinpython">Decorators in Python</a></li>
<li><a href="#docstringsinpython">Docstrings in Python</a></li>
<li><a href="#introspectioninpython">Introspection in Python</a></li>
<li><a href="#annotationsinpython">Annotations in Python</a></li>
<li><a href="#exceptionsinpython">Exceptions in Python</a></li>
<li><a href="#thewithstatementinpython">The with Statement in Python</a></li>
<li><a href="#howtoinstall3rdpartypackagesinpythonusingpip">How to Install 3rd Party Packages in Python Using pip</a></li>
<li><a href="#listcomprehensionsinpython">List Comprehensions in Python</a></li>
<li><a href="#polymorphisminpython">Polymorphism in Python</a></li>
<li><a href="#operatoroverloadinginpython">Operator Overloading in Python</a></li>
<li><a href="#virtualenvironmentsinpython">Virtual Environments in Python</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p>Python is literally eating the programming world. It is growing in popularity and usage in ways that are pretty much unprecedented in the history of computers.</p>
<p>Python excels in a wide variety of scenarios – <strong>Shell scripting</strong>, <strong>task automation</strong>, and <strong>Web development</strong> are just some basic examples.</p>
<p>Python is the language of choice for <strong>data analysis</strong> and <strong>machine learning</strong>, but it can also adapt to create games and work with embedded devices.</p>
<p>Most importantly, it's the language of choice for introductory <strong>computer science courses</strong> in universities all around the world.</p>
<p>Many students learn Python as their first programming language. Many are learning it right now, and many more will learn it in the future. And for many of them, Python will be the only programming language they need.</p>
<p>Thanks to this unique position, Python is likely going to grow even more in the future.</p>
<p>The language is simple, expressive, and it's quite straightforward.</p>
<p>The ecosystem is huge. There seems to be a library for everything you can imagine.</p>
<p>Python is a high-level programming language suitable for beginners thanks to its intuitive syntax, its huge community, and its vibrant ecosystem.</p>
<p>It is also appreciated by professionals across many different fields.</p>
<p>Technically speaking Python is an interpreted language that does not have an intermediate compilation phase like a compiled language, for example C or Java.</p>
<p>And like many interpreted languages, it is dynamically typed. This means that you do not have to indicate the types of the variables you use, and variables are not tied to a specific type.</p>
<p>This has pros and cons. In particular, you write programs faster, but on the other hand you have less help from the tools to prevent possible bugs. This means that you will find out about certain issues only by executing the program at runtime.</p>
<p>Python supports a wide variety of different programming paradigms, including procedural programming, object oriented programming, and functional programming. It's flexible enough to adapt to a lot of different needs.</p>
<p>Created in 1991 by Guido van Rossum, it's been rising in popularity - especially in the past 5 years, as this Google Trends infographic shows:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-09-at-19.22.38.png" alt="Screen-Shot-2020-11-09-at-19.22.38"></p>
<p>Starting with Python is very easy. All you need is to install the official package from python.org, for Windows, macOS or Linux, and you're ready to go.</p>
<p>If you are new to programming, in the following posts I will guide you to go from zero to becoming a Python programmer.</p>
<p>And even if you are currently a programmer who specializes in another language, Python is a language worth knowing because I think it's only going to keep growing from here.</p>
<p>Lower level languages like C++ and Rust might be great for expert programmers, but they're daunting to begin with, and they take a long time to master.</p>
<p>Python, on the other hand, is a programming language for everyone – students, people doing their day jobs with Excel, scientists, and more.</p>
<p><strong>It's the language everyone interested in coding should learn first</strong>.</p>
<p>Go to <a href="https://www.python.org">https://www.python.org</a>, choose the Downloads menu, choose your operating system, and a panel with a link to download the official package will appear:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-09-at-13.57.36-1.png" alt="Screen-Shot-2020-11-09-at-13.57.36-1"></p>
<p>Make sure you follow the specific instructions for your operating system. On macOS you can find a detailed guide on <a href="https://flaviocopes.com/python-installation-macos/">https://flaviocopes.com/python-installation-macos/</a>.</p>
<p>There are a few different ways to run Python programs.</p>
<p>In particular, there's a distinction between using interactive prompts, where you type Python code and it's immediately executed, and saving a Python program into a file and executing that.</p>
<p>Let's start with interactive prompts.</p>
<p>If you open your terminal and type <code>python</code>, you will see a screen like this:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-13.44.07.png" alt="Screen-Shot-2020-11-10-at-13.44.07"></p>
<p>This is the Python REPL (Read-Evaluate-Print-Loop).</p>
<p>Notice the <code>&gt;&gt;&gt;</code> symbol, and the cursor after that. You can type any Python code here, and press the <code>enter</code> key to run it.</p>
<p>For example try defining a new variable using</p>
<pre><code class="language-python">name = "Flavio"
</code></pre>
<p>and then print its value, using <code>print()</code>:</p>
<pre><code class="language-python">print(name)
</code></pre>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.11.57.png" alt="Screen-Shot-2020-11-10-at-14.11.57"></p>
<blockquote>
<p>Note: in the REPL, you can also just type <code>name</code>, press the <code>enter</code> key and you'll get the value back. But in a program, you are not going to see any output if you do so - you need to use <code>print()</code> instead.</p>
</blockquote>
<p>Any line of Python you write here is going to be executed immediately.</p>
<p>Type <code>quit()</code> to exit this Python REPL.</p>
<p>You can access the same interactive prompt using the IDLE application that's installed by Python automatically:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.13.25.png" alt="Screen-Shot-2020-11-10-at-14.13.25"></p>
<p>This might be more convenient for you because with the mouse you can move around and copy/paste more easily than with the terminal.</p>
<p>Those are the basics that come with Python by default. However I recommend that you install <a href="https://ipython.org/">IPython</a>, probably the best command line REPL application you can find.</p>
<p>Install it with</p>
<pre><code class="language-sh">pip install ipython
</code></pre>
<p>Make sure the pip binaries are in your path, then run <code>ipython</code>:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-11-at-09.36.29.png" alt="Screen-Shot-2020-11-11-at-09.36.29"></p>
<p><code>ipython</code> is another interface that lets you work with a Python REPL, and provides some nice features like syntax highlighting, code completion, and much more.</p>
<p>The second way to run a Python program is to write your Python program code into a file, for example <code>program.py</code>:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.01.24.png" alt="Screen-Shot-2020-11-10-at-14.01.24"></p>
<p>and then run it with <code>python program.py</code>:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.01.32.png" alt="Screen-Shot-2020-11-10-at-14.01.32"></p>
<blockquote>
<p>Note that we save Python programs with the <code>.py</code> extension - that's a convention.</p>
</blockquote>
<p>In this case the program is executed as a whole, not one line at a time. And that's typically how we run programs.</p>
<p>We use the REPL for quick prototyping and for learning.</p>
<p>On Linux and macOS, a Python program can also be transformed into a shell script, by prepending all its content with a special line that indicates which executable to use to run it.</p>
<p>On my system the Python executable is located in <code>/usr/bin/python3</code>, so I type <code>#!/usr/bin/python3</code> in the first line:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.17.26.png" alt="Screen-Shot-2020-11-10-at-14.17.26"></p>
<p>Then I can set execution permission on the file:</p>
<pre><code class="language-sh">chmod u+x program.py
</code></pre>
<p>and I can run the program with</p>
<pre><code class="language-sh">./program.py
</code></pre>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.18.42.png" alt="Screen-Shot-2020-11-10-at-14.18.42"></p>
<p>This is especially useful when you write scripts that interact with the terminal.</p>
<p>We have many other ways to run Python programs.</p>
<p>One of them is using VS Code, and in particular the official Python extension from Microsoft:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.23.32.png" alt="Screen-Shot-2020-11-10-at-14.23.32"></p>
<p>After installing this extension you will have Python code autocompletion and error checking, automatic formatting and code linting with <code>pylint</code>, and some special commands, including:</p>
<p><strong>Python: Start REPL</strong> to run the REPL in the integrated terminal:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.31.36.png" alt="Screen-Shot-2020-11-10-at-14.31.36"></p>
<p><strong>Python: Run Python File in Terminal</strong> to run the current file in the terminal:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.31.06.png" alt="Screen-Shot-2020-11-10-at-14.31.06"></p>
<p><strong>Python: Run Current File in Python Interactive Window</strong>:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.30.02-1.png" alt="Screen-Shot-2020-11-10-at-14.30.02-1"></p>
<p>and many more. Just open the command palette (View -&gt; Command Palette, or Cmd-Shift-P) and type <code>python</code> to see all the Python-related commands:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.30.02.png" alt="Screen-Shot-2020-11-10-at-14.30.02"></p>
<p>Another way to easily run Python code is to use repl.it, a very nice website that provides a coding environment you can create and run your apps on, in any language, Python included:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.33.58.png" alt="Screen-Shot-2020-11-10-at-14.33.58"></p>
<p>Signup (it's free), then under "create a repl" click Python:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.46.34.png" alt="Screen-Shot-2020-11-10-at-14.46.34"></p>
<p>and you will be immediately shown an editor with a <code>main.py</code> file, ready to be filled with a lot of Python code:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.47.15.png" alt="Screen-Shot-2020-11-10-at-14.47.15"></p>
<p>Once you have some code, click "Run" to run it on the right side of the window:</p>
<p><img src="https://www.freecodecamp.org/news/content/images/2021/03/Screen-Shot-2020-11-10-at-14.48.09.png" alt="Screen-Shot-2020-11-10-at-14.48.09"></p>
<p>I think repl.it is handy because:</p>
<ul>
<li>you can easily share code just by sharing the link</li>
<li>multiple people can work on the same code</li>
<li>it can host long-running programs</li>
<li>you can install packages</li>
<li>it provides you a key-value database for more complex applications</li>
</ul>
<p>One key topic we should address, right from the start, is the Python 2 vs Python 3 discussion.</p>
<p>Python 3 was introduced in 2008, and it's been in development as the main Python version, while Python 2 continued being maintained with bug fixes and security patches until early 2020.</p>
<p>On that date, Python 2 support was discontinued.</p>
<p>Many programs are still written using Python 2, and organizations still actively work on those, because the migration to Python 3 is not trivial and it would require a lot of work to upgrade those programs. And large and important migrations always introduce new bugs.</p>
<p>But new code, unless you have to adhere to rules set by your organization that forces Python 2, should always be written in Python 3.</p>
<blockquote>
<p>This book focuses on Python 3.</p>
</blockquote>
<h3 id="variablesinpython">Variables in Python</h3>
<p>We can create a new Python variable by assigning a value to a label, using the <code>=</code> assignment operator.</p>
<p>In this example we assign a string with the value "Roger" to the <code>name</code> label:</p>
<pre><code class="language-python">name = "Roger"
</code></pre>
<p>Here's an example with a number:</p>
<pre><code class="language-python">age = 8
</code></pre>
<p>A variable name can be composed of characters, numbers, and the <code>_</code> underscore character. It can't start with a number. These are all <strong>valid</strong> variable names:</p>
<pre><code class="language-python">name1
AGE
aGE
a11111
my_name
_name
</code></pre>
<p>These are <strong>invalid</strong> variable names:</p>
<pre><code class="language-python">123
test!
name%
</code></pre>
<p>Other than that, anything is valid unless it's a Python <strong>keyword</strong>. There are some keywords like <code>for</code>, <code>if</code>, <code>while</code>, <code>import</code> and more.</p>
<p>There's no need to memorize them, as Python will alert you if you use one of those as a variable, and you will gradually recognize them as part of the Python programming language syntax.</p>
<h3 id="expressionsandstatementsinpython">Expressions and statements in Python</h3>
<p>We can <em>expression</em> any sort of code that returns a value. For example</p>
<pre><code class="language-python">1 + 1
"Roger"
</code></pre>
<p>A statement, on the other hand, is an operation on a value. For example these are 2 statements:</p>
<pre><code class="language-python">name = "Roger"
print(name)
</code></pre>
<p>A program is formed by a series of statements. Each statement is put on its own line, but you can use a semicolon to have more than one statement on a single line:</p>
<pre><code class="language-python">name = "Roger"; print(name)
</code></pre>
<h3 id="comments">Comments</h3>
<p>In a Python program, everything after a hash mark is ignored, and considered a comment:</p>
<pre><code class="language-python">#this is a commented line
name = "Roger" # this is an inline comment
</code></pre>
<h3 id="indentationinpython">Indentation in Python</h3>
<p>Indentation in Python is meaningful.</p>
<p>You cannot indent randomly like this:</p>
<pre><code class="language-python">name = "Flavio"
print(name)
</code></pre>
<p>Some other languages do not have meaningful whitespace, but in Python, indentation matters.</p>
<p>In this case, if you try to run this program you would get a <code>IndentationError: unexpected indent</code> error, because indenting has a special meaning.</p>
<p>Everything indented belongs to a block, like a control statement or conditional block, or a function or class body. We'll see more about those later on.</p>
<p>Python has several built-in types.</p>
<p>If you create the <code>name</code> variable assigning it the value "Roger", automatically this variable now represents a <strong>String</strong> data type.</p>
<pre><code class="language-python">name = "Roger"
</code></pre>
<p>You can check the type of a variable by using the <code>type()</code> function, passing the variable as an argument, and then comparing the result to <code>str</code>:</p>
<pre><code class="language-python">name = "Roger"
type(name) == str #True
</code></pre>
<p>Or using <code>isinstance()</code>:</p>
<pre><code class="language-python">name = "Roger"
isinstance(name, str) #True
</code></pre>
<blockquote>
<p>Notice that to see the <code>True</code> value in Python, outside of a REPL, you need to wrap this code inside <code>print()</code>, but for clarity I avoid using it.</p>
</blockquote>
<p>We used the <code>str</code> class here, but the same works for other data types.</p>
<p>First, we have numbers. Integer numbers are represented using the <code>int</code> class. Floating point numbers (fractions) are of type <code>float</code>:</p>
<pre><code class="language-python">age = 1
type(age) == int #True
</code></pre>
<pre><code class="language-python">fraction = 0.1
type(fraction) == float #True
</code></pre>
<p>You saw how to create a type from a value literal, like this:</p>
<pre><code class="language-python">name = "Flavio"
age = 20
</code></pre>
<p>Python automatically detects the type from the value type.</p>
<p>You can also create a variable of a specific type by using the class constructor, passing a value literal or a variable name:</p>
<pre><code class="language-python">name = str("Flavio")
anotherName = str(name)
</code></pre>
<p>You can also convert from one type to another by using the class constructor. Python will try to determine the correct value, for example extracting a number from a string:</p>
<pre><code class="language-python">age = int("20")
print(age) #20
fraction = 0.1
intFraction = int(fraction)
print(intFraction) #0
</code></pre>
<p>This is called <strong>casting</strong>. Of course this conversion might not always work depending on the value passed. If you write <code>test</code> instead of <code>20</code> in the above string, you'll get a <code>ValueError: invalid literal for int() with base 10: 'test'</code> error.</p>
<p>Those are just the basics of types. We have a lot more types in Python:</p>
<ul>
<li><code>complex</code> for complex numbers</li>
<li><code>bool</code> for booleans</li>
<li><code>list</code> for lists</li>
<li><code>tuple</code> for tuples</li>
<li><code>range</code> for ranges</li>
<li><code>dict</code> for dictionaries</li>
<li><code>set</code> for sets</li>
</ul>
<p>and more!</p>
<p>We'll explore them all soon.</p>
<p>Python operators are symbols that we use to run operations upon values and variables.</p>
<p>We can divide operators based on the kind of operation they perform:</p>
<ul>
<li>assignment operator</li>
<li>arithmetic operators</li>
<li>comparison operators</li>
<li>logical operators</li>
<li>bitwise operators</li>
</ul>
<p>plus some interesting ones like <code>is</code> and <code>in</code>.</p>
<h3 id="assignmentoperatorinpython">Assignment operator in Python</h3>
<p>The assignment operator is used to assign a value to a variable:</p>
<pre><code class="language-python">age = 8
</code></pre>
<p>Or to assign a variable value to another variable:</p>
<pre><code class="language-python">age = 8
anotherVariable = age
</code></pre>
<p>Since Python 3.8, the <code>:=</code> <em>walrus operator</em> is used to assign a value to a variable as part of another operation. For example inside an <code>if</code> or in the conditional part of a loop. More on that later.</p>
<h3 id="arithmeticoperatorsinpython">Arithmetic operators in Python</h3>
<p>Python has a number of arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (division), <code>%</code> (remainder), <code>**</code> (exponentiation) and <code>//</code> (floor division):</p>
<pre><code class="language-python">1 + 1 #2
2 - 1 #1
2 * 2 #4
4 / 2 #2
4 % 3 #1
4 ** 2 #16
4 // 2 #2
</code></pre>
<blockquote>
<p>Note that you don't need a space between the operands, but it's good for readability.</p>
</blockquote>
<p><code>-</code> also works as a unary minus operator:</p>
<pre><code class="language-python">print(-4) #-4
</code></pre>
<p><code>+</code> is also used to concatenate String values:</p>
<pre><code class="language-python">"Roger" + " is a good dog"
#Roger is a good dog
</code></pre>
<p>We can combine the assignment operator with arithmetic operators:</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
<li>..and so on</li>
</ul>
<p>Example:</p>
<pre><code class="language-python">age = 8
age += 1
# age is now 9
</code></pre>
<h3 id="comparisonoperatorsinpython">Comparison operators in Python</h3>
<p>Python defines a few comparison operators:</p>
<ul>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;=</code></li>
</ul>
<p>You can use those operators to get a boolean value (<code>True</code> or <code>False</code>) depending on the result:</p>
<pre><code class="language-python">a = 1
b = 2
a == b #False
a != b #True
a &gt; b #False
a &lt;= b #True
</code></pre>
<h3 id="booleanoperatorsinpython">Boolean operators in Python</h3>
<p>Python gives us the following boolean operators:</p>
<ul>
<li><code>not</code></li>
<li><code>and</code></li>
<li><code>or</code></li>
</ul>
<p>When working with <code>True</code> or <code>False</code> attributes, those work like logical AND, OR and NOT, and are often used in the <code>if</code> conditional expression evaluation:</p>
<pre><code class="language-python">condition1 = True
condition2 = False
not condition1 #False
condition1 and condition2 #False
condition1 or condition2 #True
</code></pre>
<p>Otherwise, pay attention to a possible source of confusion:</p>
<p><code>or</code> used in an expression returns the value of the first operand that is not a falsy value (<code>False</code>, <code>0</code>, <code>''</code>, <code>[]</code>..). Otherwise it returns the last operand.</p>
<pre><code class="language-python">print(0 or 1) ## 1
print(False or 'hey') ## 'hey'
print('hi' or 'hey') ## 'hi'
print([] or False) ## 'False'
print(False or []) ## '[]'
</code></pre>
<p>The Python docs describe it as <code>if x is false, then y, else x</code>.</p>
<p><code>and</code> only evaluates the second argument if the first one is true. So if the first argument is falsy (<code>False</code>, <code>0</code>, <code>''</code>, <code>[]</code>..), it returns that argument. Otherwise it evaluates the second argument:</p>
<pre><code class="language-python">print(0 and 1) ## 0
print(1 and 0) ## 0
print(False and 'hey') ## False
print('hi' and 'hey') ## 'hey'
print([] and False ) ## []
print(False and [] ) ## False
</code></pre>
<p>The Python docs describe it as <code>if x is false, then x, else y</code>.</p>
<h3 id="bitwiseoperatorsinpython">Bitwise operators in Python</h3>
<p>Some operators are used to work on bits and binary numbers:</p>
<ul>
<li><code>&amp;</code> performs binary AND</li>
<li><code>|</code> performs binary OR</li>
<li><code>^</code> performs a binary XOR operation</li>
<li><code>~</code> performs a binary NOT operation</li>
<li><code>&lt;&lt;</code> shift left operation</li>
<li><code>&gt;&gt;</code> shift right operation</li>
</ul>
<p>Bitwise operators are rarely used, only in very specific situations, but they are worth mentioning.</p>
<h3 id="isandininpython"><code>is</code> and <code>in</code> in Python</h3>
<p><code>is</code> is called the <strong>identity operator</strong>. It is used to compare two objects and returns true if both are the same object. More on objects later.</p>
<p><code>in</code> is called the <strong>membership operator</strong>. Is used to tell if a value is contained in a list, or another sequence. More on lists and other sequences later.</p>
<p>The ternary operator in Python allows you to quickly define a conditional.</p>
<p>Let's say you have a function that compares an <code>age</code> variable to the <code>18</code> value, and returns True or False depending on the result.</p>
<p>Instead of writing:</p>
<pre><code class="language-python">def is_adult(age):
if age &gt; 18:
return True
else:
return False
</code></pre>
<p>You can implement it with the ternary operator in this way:</p>
<pre><code class="language-python">def is_adult(age):
return True if age &gt; 18 else False
</code></pre>
<p>First you define the result if the condition is True, then you evaluate the condition, then you define the result if the condition is false:</p>
<pre><code class="language-python">&lt;result_if_true&gt; if &lt;condition&gt; else &lt;result_if_false&gt;
</code></pre>
<p>A string in Python is a series of characters enclosed in quotes or double quotes:</p>
<pre><code class="language-python">"Roger"
'Roger'
</code></pre>
<p>You can assign a string value to a variable:</p>
<pre><code class="language-python">name = "Roger"
</code></pre>
<p>You can concatenate two strings using the <code>+</code> operator:</p>
<pre><code class="language-python">phrase = "Roger" + " is a good dog"
</code></pre>
<p>You can append to a string using <code>+=</code>:</p>
<pre><code class="language-python">name = "Roger"
name += " is a good dog"
print(name) #Roger is a good dog
</code></pre>
<p>You can convert a number to a string using the <code>str</code> class constructor:</p>
<pre><code class="language-python">str(8) #"8"
</code></pre>
<p>This is essential to concatenate a number to a string:</p>
<pre><code class="language-python">print("Roger is " + str(8) + " years old") #Roger is 8 years old
</code></pre>
<p>A string can be multi-line when defined with a special syntax, enclosing the string in a set of 3 quotes:</p>
<pre><code class="language-python">print("""Roger is
8
years old
""")
#double quotes, or single quotes
print('''
Roger is
8
years old
''')
</code></pre>
<p>A string has a set of built-in methods, like:</p>
<ul>
<li><code>isalpha()</code> to check if a string contains only characters and is not empty</li>
<li><code>isalnum()</code> to check if a string contains characters or digits and is not empty</li>
<li><code>isdecimal()</code> to check if a string contains digits and is not empty</li>
<li><code>lower()</code> to get a lowercase version of a string</li>
<li><code>islower()</code> to check if a string is lowercase</li>
<li><code>upper()</code> to get an uppercase version of a string</li>
<li><code>isupper()</code> to check if a string is uppercase</li>
<li><code>title()</code> to get a capitalized version of a string</li>
<li><code>startsswith()</code> to check if the string starts with a specific substring</li>
<li><code>endswith()</code> to check if the string ends with a specific substring</li>
<li><code>replace()</code> to replace a part of a string</li>
<li><code>split()</code> to split a string on a specific character separator</li>
<li><code>strip()</code> to trim the whitespace from a string</li>
<li><code>join()</code> to append new letters to a string</li>
<li><code>find()</code> to find the position of a substring</li>
</ul>
<p>and many more.</p>
<p>None of those methods alter the original string. They return a new, modified string instead. For example:</p>
<pre><code class="language-python">name = "Roger"
print(name.lower()) #"roger"
print(name) #"Roger"
</code></pre>
<p>You can use some global functions to work with strings, too.</p>
<p>In particular I think of <code>len()</code>, which gives you the length of a string:</p>
<pre><code class="language-python">name = "Roger"
print(len(name)) #5
</code></pre>
<p>The <code>in</code> operator lets you check if a string contains a substring:</p>
<pre><code class="language-python">name = "Roger"
print("ger" in name) #True
</code></pre>
<p>Escaping is a way to add special characters into a string.</p>
<p>For example, how do you add a double quote into a string that's wrapped into double quotes?</p>
<pre><code class="language-python">name = "Roger"
</code></pre>
<p><code>"Ro"Ger"</code> will not work, as Python will think the string ends at <code>"Ro"</code>.</p>
<p>The way to go is to escape the double quote inside the string, with the <code>\</code> backslash character:</p>
<pre><code class="language-python">name = "Ro\"ger"
</code></pre>
<p>This applies to single quotes too <code>\'</code>, and for special formatting characters like <code>\t</code> for tab, <code>\n</code> for new line and <code>\\</code> for the backslash.</p>
<p>Given a string, you can get its characters using square brackets to get a specific item, given its index, starting from 0:</p>
<pre><code class="language-python">name = "Roger"
name[0] #'R'
name[1] #'o'
name[2] #'g'
</code></pre>
<p>Using a negative number will start counting from the end:</p>
<pre><code class="language-python">name = "Roger"
name[-1] #"r"
</code></pre>
<p>You can also use a range, using what we call <strong>slicing</strong>:</p>
<pre><code class="language-python">name = "Roger"
name[0:2] #"Ro"
name[:2] #"Ro"
name[2:] #"ger"
</code></pre>
<p>Python provides the <code>bool</code> type, which can have two values: <code>True</code> and <code>False</code> (capitalized).</p>
<pre><code class="language-python">done = False
done = True
</code></pre>
<p>Booleans are especially useful with conditional control structures like <code>if</code> statements:</p>
<pre><code class="language-python">done = True
if done:
# run some code here
else:
# run some other code
</code></pre>
<p>When evaluating a value for <code>True</code> or <code>False</code>, if the value is not a <code>bool</code> we have some rules depending on the type we're checking:</p>
<ul>
<li>numbers are always <code>True</code> except for the number <code>0</code></li>
<li>strings are <code>False</code> only when empty</li>
<li>lists, tuples, sets, and dictionaries are <code>False</code> only when empty</li>
</ul>
<p>You can check if a value is a boolean in this way:</p>
<pre><code class="language-python">done = True
type(done) == bool #True
</code></pre>
<p>Or using <code>isinstance()</code>, passing 2 arguments: the variable, and the <code>bool</code> class:</p>
<pre><code class="language-python">done = True
isinstance(done, bool) #True
</code></pre>
<p>The global <code>any()</code> function is also very useful when working with booleans, as it returns <code>True</code> if any of the values of the iterable (list, for example) passed as argument are <code>True</code>:</p>
<pre><code class="language-python">book_1_read = True
book_2_read = False
read_any_book = any([book_1_read, book_2_read])
</code></pre>
<p>The global <code>all()</code> function is same, but returns <code>True</code> if all of the values passed to it are <code>True</code>:</p>
<pre><code class="language-python">ingredients_purchased = True
meal_cooked = False
ready_to_serve = all([ingredients_purchased, meal_cooked])
</code></pre>
<p>Numbers in Python can be of 3 types: <code>int</code>, <code>float</code> and <code>complex</code>.</p>
<h3 id="integernumbersinpython">Integer numbers in Python</h3>
<p>Integer numbers are represented using the <code>int</code> class. You can define an integer using a value literal:</p>
<pre><code class="language-python">age = 8
</code></pre>
<p>You can also define an integer number using the <code>int()</code> constructor:</p>
<pre><code class="language-python">age = int(8)
</code></pre>
<p>To check if a variable is of type <code>int</code>, you can use the <code>type()</code> global function:</p>
<pre><code class="language-python">type(age) == int #True
</code></pre>
<h3 id="floatingpointnumbersinpython">Floating point numbers in Python</h3>
<p>Floating point numbers (fractions) are of type <code>float</code>. You can define an integer using a value literal:</p>
<pre><code class="language-python">fraction = 0.1
</code></pre>
<p>Or using the <code>float()</code> constructor:</p>
<pre><code class="language-python">fraction = float(0.1)
</code></pre>
<p>To check if a variable is of type <code>float</code>, you can use the <code>type()</code> global function:</p>
<pre><code class="language-python">type(fraction) == float #True
</code></pre>
<h3 id="complexnumbersinpython">Complex numbers in Python</h3>
<p>Complex numbers are of type <code>complex</code>.</p>
<p>You can define them using a value literal:</p>
<pre><code class="language-python">complexNumber = 2+3j
</code></pre>
<p>or using the <code>complex()</code> constructor:</p>
<pre><code class="language-python">complexNumber = complex(2, 3)
</code></pre>
<p>Once you have a complex number, you can get its real and imaginary part:</p>
<pre><code class="language-python">complexNumber.real #2.0
complexNumber.imag #3.0
</code></pre>
<p>Again, to check if a variable is of type <code>complex</code>, you can use the <code>type()</code> global function:</p>
<pre><code class="language-python">type(complexNumber) == complex #True
</code></pre>
<h3 id="arithmeticoperationsonnumbersinpython">Arithmetic operations on numbers in Python</h3>
<p>You can perform arithmetic operations on numbers, using the arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> (division), <code>%</code> (remainder), <code>**</code> (exponentiation) and <code>//</code> (floor division):</p>
<pre><code class="language-python">1 + 1 #2
2 - 1 #1
2 * 2 #4
4 / 2 #2
4 % 3 #1
4 ** 2 #16
4 // 2 #2
</code></pre>
<p>and you can use the compound assignment operators</p>
<ul>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
<li>..and so on</li>
</ul>
<p>to quickly perform operations on variables, too:</p>
<pre><code class="language-python">age = 8
age += 1
</code></pre>
<h3 id="builtinfunctionsinpython">Built-in Functions in Python</h3>
<p>There are 2 built-in functions that help with numbers:</p>
<p><code>abs()</code> returns the absolute value of a number.</p>
<p><code>round()</code> given a number, returns its value rounded to the nearest integer:</p>
<pre><code class="language-python">round(0.12) #0
</code></pre>
<p>You can specify a second parameter to set the decimal point's precision:</p>
<pre><code class="language-python">round(0.12, 1) #0.1
</code></pre>
<p>Several other math utility functions and constants are provided by the Python standard library:</p>
<ul>
<li>the <code>math</code> package provides general math functions and constants</li>
<li>the <code>cmath</code> package provides utilities to work with complex numbers.</li>
<li>the <code>decimal</code> package provides utilities to work with decimals and floating point numbers.</li>
<li>the <code>fractions</code> package provides utilities to work with rational numbers.</li>
</ul>
<p>We'll explore some of those separately later on.</p>
<p>Python has no way to enforce that a variable should be a constant.</p>
<p>The nearest you can get is to use an enum:</p>
<pre><code class="language-Python">class Constants(Enum):
WIDTH = 1024
HEIGHT = 256
</code></pre>
<p>And get to each value using, for example, <code>Constants.WIDTH.value</code>.</p>
<p>No one can reassign that value.</p>
<p>Otherwise if you want to rely on naming conventions, you can adhere to this one: declare variables that should never change uppercase:</p>
<pre><code class="language-python">WIDTH = 1024
</code></pre>
<p>No one will prevent you from overwriting this value, and Python will not stop it.</p>
<p>That's what most Python code does that you will see.</p>
<p>Enums are readable names that are bound to a constant value.</p>
<p>To use enums, import <code>Enum</code> from the <code>enum</code> standard library module:</p>
<pre><code class="language-python">from enum import Enum
</code></pre>
<p>Then you can initialize a new enum in this way:</p>
<pre><code class="language-python">class State(Enum):
INACTIVE = 0
ACTIVE = 1
</code></pre>
<p>Once you do so, you can reference <code>State.INACTIVE</code> and <code>State.ACTIVE</code>, and they serve as constants.</p>
<p>Now if you try to print <code>State.ACTIVE</code> for example:</p>
<pre><code class="language-python">print(State.ACTIVE)
</code></pre>
<p>it will not return <code>1</code>, but <code>State.ACTIVE</code>.</p>
<p>The same value can be reached by the number assigned in the enum: <code>print(State(1))</code> will return <code>State.ACTIVE</code>. Same for using the square brackets notation <code>State['ACTIVE']</code>.</p>
<p>You can, however, get the value using <code>State.ACTIVE.value</code>.</p>
<p>You can list all the possible values of an enum:</p>
<pre><code class="language-python">list(State) # [&lt;State.INACTIVE: 0&gt;, &lt;State.ACTIVE: 1&gt;]
</code></pre>
<p>You can count them:</p>
<pre><code class="language-python">len(State) # 2
</code></pre>
<p>In a Python command line application you can display information to the user using the <code>print()</code> function:</p>
<pre><code class="language-python">name = "Roger"
print(name)
</code></pre>
<p>We can also accept input from the user, using <code>input()</code>:</p>
<pre><code class="language-python">print('What is your age?')
age = input()
print('Your age is ' + age)
</code></pre>
<p>This approach gets input at runtime, meaning the program will stop execution and will wait until the user types something and presses the <code>enter</code> key.</p>
<p>You can also do more complex input processing and accept input at program invocation time, and we'll see how to do that later on.</p>
<p>This works for command line applications. Other kinds of applications will need a different way of accepting input.</p>
<p>When you're dealing with booleans, and expressions that return a boolean in particular, we can make decisions and take different roads depending on their <code>True</code> or <code>False</code> values.</p>
<p>In Python we do so using the <code>if</code> statement:</p>
<pre><code class="language-python">condition = True
if condition == True:
# do something
</code></pre>
<p>When the condition test resolves to <code>True</code>, like in the above case, its block gets executed.</p>
<p>What is a block? A block is that part that is indented one level (4 spaces usually) on the right:</p>
<pre><code class="language-python">condition = True
if condition == True:
print("The condition")
print("was true")
</code></pre>
<p>The block can be formed by a single line, or multiple lines as well, and it ends when you move back to the previous indentation level:</p>
<pre><code class="language-python">condition = True
if condition == True:
print("The condition")
print("was true")
print("Outside of the if")
</code></pre>
<p>In combination with <code>if</code> you can have an <code>else</code> block that's executed if the condition test of <code>if</code> results to <code>False</code>:</p>
<pre><code class="language-python">condition = True
if condition == True:
print("The condition")
print("was True")
else:
print("The condition")
print("was False")
</code></pre>
<p>And you can have different linked <code>if</code> checks with <code>elif</code> that's executed if the previous check was <code>False</code>:</p>
<pre><code class="language-python">condition = True
name = "Roger"
if condition == True:
print("The condition")
print("was True")
elif name == "Roger":
print("Hello Roger")
else:
print("The condition")
print("was False")
</code></pre>
<p>The second block in this case is executed if <code>condition</code> is <code>False</code>, and the <code>name</code> variable value is "Roger".</p>
<p>In a <code>if</code> statement you can have just one <code>if</code> and <code>else</code> check, but multiple series of <code>elif</code> checks:</p>
<pre><code class="language-python">condition = True
name = "Roger"
if condition == True:
print("The condition")
print("was True")
elif name == "Roger":
print("Hello Roger")
elif name == "Syd":
print("Hello Syd")
elif name == "Flavio":
print("Hello Flavio")
else:
print("The condition")
print("was False")
</code></pre>
<p><code>if</code> and <code>else</code> can also be used in an inline format, which lets us return one value or another based on a condition.</p>
<p>Example:</p>
<pre><code class="language-python">a = 2
result = 2 if a == 0 else 3
print(result) # 3
</code></pre>
<p>Lists are an essential Python data structure.</p>
<p>The allow you to group together multiple values and reference them all with a common name.</p>
<p>For example:</p>
<pre><code class="language-python">dogs = ["Roger", "Syd"]
</code></pre>
<p>A list can hold values of different types:</p>
<pre><code class="language-python">items = ["Roger", 1, "Syd", True]
</code></pre>
<p>You can check if an item is contained in a list with the <code>in</code> operator:</p>
<pre><code class="language-python">print("Roger" in items) # True
</code></pre>
<p>A list can also be defined as empty:</p>
<pre><code class="language-python">items = []
</code></pre>
<p>You can reference the items in a list by their index, starting from zero:</p>
<pre><code class="language-python">items[0] # "Roger"
items[1] # 1
items[3] # True
</code></pre>
<p>Using the same notation you can change the value stored at a specific index:</p>
<pre><code class="language-python">items[0] = "Roger"
</code></pre>
<p>You can also use the <code>index()</code> method:</p>
<pre><code class="language-python">items.index(0) # "Roger"
items.index(1) # 1
</code></pre>
<p>As with strings, using a negative index will start searching from the end:</p>
<pre><code class="language-python">items[-1] # True
</code></pre>
<p>You can also extract a part of a list, using slices:</p>
<pre><code class="language-python">items[0:2] # ["Roger", 1]
items[2:] # ["Syd", True]
</code></pre>
<p>Get the number of items contained in a list using the <code>len()</code> global function, the same we used to get the length of a string:</p>
<pre><code class="language-python">len(items) #4
</code></pre>
<p>You can add items to the list by using a list <code>append()</code> method:</p>
<pre><code class="language-python">items.append("Test")
</code></pre>
<p>or the extend() method:</p>
<pre><code class="language-python">items.extend(["Test"])
</code></pre>
<p>You can also use the <code>+=</code> operator:</p>
<pre><code class="language-python">items += ["Test"]
# items is ['Roger', 1, 'Syd', True, 'Test']
</code></pre>
<blockquote>
<p>Tip: with <code>extend()</code> or <code>+=</code> don't forget the square brackets. Don't do <code>items += "Test"</code> or <code>items.extend("Test")</code> or Python will add 4 individual characters to the list, resulting in <code>['Roger', 1, 'Syd', True, 'T', 'e', 's', 't']</code></p>
</blockquote>
<p>Remove an item using the <code>remove()</code> method:</p>
<pre><code class="language-python">items.remove("Test")
</code></pre>
<p>You can add multiple elements using</p>
<pre><code class="language-python">items += ["Test1", "Test2"]
#or
items.extend(["Test1", "Test2"])
</code></pre>
<p>These append the item to the end of the list.</p>
<p>To add an item in the middle of a list, at a specific index, use the <code>insert()</code> method:</p>
<pre><code class="language-python">items.insert("Test", 1) # add "Test" at index 1
</code></pre>
<p>To add multiple items at a specific index, you need to use slices:</p>
<pre><code class="language-python">items[1:1] = ["Test1", "Test2"]
</code></pre>
<p>Sort a list using the <code>sort()</code> method:</p>
<pre><code class="language-python">items.sort()
</code></pre>
<blockquote>
<p>Tip: sort() will only work if the list holds values that can be compared. Strings and integers for example can't be compared, and you'll get an error like <code>TypeError: '&lt;' not supported between instances of 'int' and 'str'</code> if you try.</p>
</blockquote>
<p>The <code>sort()</code> methods orders uppercase letters first, then lowercase letters. To fix this, use:</p>
<pre><code class="language-python">items.sort(key=str.lower)
</code></pre>
<p>instead.</p>
<p>Sorting modifies the original list content. To avoid that, you can copy the list content using</p>
<pre><code class="language-python">itemscopy = items[:]
</code></pre>
<p>or use the <code>sorted()</code> global function:</p>
<pre><code class="language-python">print(sorted(items, key=str.lower))
</code></pre>
<p>that will return a new list, sorted, instead of modifying the original list.</p>
<p>Tuples are another fundamental Python data structure.</p>
<p>They allow you to create immutable groups of objects. This means that once a tuple is created, it can't be modified. You can't add or remove items.</p>
<p>They are created in a way similar to lists, but using parentheses instead of square brackets:</p>
<pre><code class="language-python">names = ("Roger", "Syd")
</code></pre>
<p>A tuple is ordered, like a list, so you can get its values by referencing an index value:</p>
<pre><code class="language-python">names[0] # "Roger"
names[1] # "Syd"
</code></pre>
<p>You can also use the <code>index()</code> method:</p>
<pre><code class="language-python">names.index('Roger') # 0
names.index('Syd')   # 1
</code></pre>
<p>As with strings and lists, using a negative index will start searching from the end:</p>
<pre><code class="language-python">names[-1] # True
</code></pre>
<p>You can count the items in a tuple with the <code>len()</code> function:</p>
<pre><code class="language-python">len(names) # 2
</code></pre>
<p>You can check if an item is contained in a tuple with the <code>in</code> operator:</p>
<pre><code class="language-python">print("Roger" in names) # True
</code></pre>
<p>You can also extract a part of a tuple, using slices:</p>
<pre><code class="language-python">names[0:2] # ('Roger', 'Syd')
names[1:] # ('Syd',)
</code></pre>
<p>Get the number of items in a tuple using the <code>len()</code> global function, the same we used to get the length of a string:</p>
<pre><code class="language-python">len(names) #2
</code></pre>
<p>You can create a sorted version of a tuple using the <code>sorted()</code> global function:</p>
<pre><code class="language-python">sorted(names)
</code></pre>
<p>You can create a new tuple from existing tuples using the <code>+</code> operator:</p>
<pre><code class="language-python">newTuple = names + ("Vanille", "Tina")
</code></pre>
<p>Dictionaries are a very important Python data structure.</p>
<p>While lists allow you to create collections of values, dictionaries allow you to create collections of <strong>key / value pairs</strong>.</p>
<p>Here is a dictionary example with one key/value pair:</p>
<pre><code class="language-python">dog = { 'name': 'Roger' }
</code></pre>
<p>The key can be any immutable value like a string, a number or a tuple. The value can be anything you want.</p>
<p>A dictionary can contain multiple key/value pairs:</p>
<pre><code class="language-python">dog = { 'name': 'Roger', 'age': 8 }
</code></pre>
<p>You can access individual key values using this notation:</p>
<pre><code class="language-python">dog['name'] # 'Roger'
dog['age']  # 8
</code></pre>
<p>Using the same notation you can change the value stored at a specific index:</p>
<pre><code class="language-python">dog['name'] = 'Syd'
</code></pre>
<p>And another way is using the <code>get()</code> method, which has an option to add a default value:</p>
<pre><code class="language-python">dog.get('name') # 'Roger'
dog.get('test', 'default') # 'default'
</code></pre>
<p>The <code>pop()</code> method retrieves the value of a key, and subsequently deletes the item from the dictionary:</p>
<pre><code class="language-python">dog.pop('name') # 'Roger'
</code></pre>
<p>The <code>popitem()</code> method retrieves and removes the last key/value pair inserted into the dictionary:</p>
<pre><code class="language-python">dog.popitem()
</code></pre>
<p>You can check if a key is contained into a dictionary with the <code>in</code> operator:</p>
<pre><code class="language-python">'name' in dog # True
</code></pre>
<p>Get a list with the keys in a dictionary using the <code>keys()</code> method, passing its result to the <code>list()</code> constructor:</p>
<pre><code class="language-python">list(dog.keys()) # ['name', 'age']
</code></pre>
<p>Get the values using the <code>values()</code> method, and the key/value pairs tuples using the <code>items()</code> method:</p>
<pre><code class="language-python">print(list(dog.values()))
# ['Roger', 8]
print(list(dog.items()))
# [('name', 'Roger'), ('age', 8)]
</code></pre>
<p>Get a dictionary length using the <code>len()</code> global function, the same we used to get the length of a string or the items in a list:</p>
<pre><code class="language-python">len(dog) #2
</code></pre>
<p>You can add a new key/value pair to the dictionary in this way:</p>
<pre><code class="language-python">dog['favorite food'] = 'Meat'
</code></pre>
<p>You can remove a key/value pair from a dictionary using the <code>del</code> statement:</p>
<pre><code class="language-python">del dog['favorite food']
</code></pre>
<p>To copy a dictionary, use the copy() method:</p>
<pre><code class="language-python">dogCopy = dog.copy()
</code></pre>
<p>Sets are another important Python data structure.</p>
<p>We can say they work like tuples, but they are not ordered, and they are <strong>mutable</strong>.</p>
<p>Or we can say they work like dictionaries, but they don't have keys.</p>
<p>They also have an immutable version, called <code>frozenset</code>.</p>
<p>You can create a set using this syntax:</p>
<pre><code class="language-python">names = {"Roger", "Syd"}
</code></pre>
<p>Sets work well when you think about them as mathematical sets.</p>
<p>You can intersect two sets:</p>
<pre><code class="language-python">set1 = {"Roger", "Syd"}
set2 = {"Roger"}
intersect = set1 &amp; set2 #{'Roger'}
</code></pre>
<p>You can create a union of two sets:</p>
<pre><code class="language-python">set1 = {"Roger", "Syd"}
set2 = {"Luna"}
union = set1 | set2
#{'Syd', 'Luna', 'Roger'}
</code></pre>
<p>You can get the difference between two sets:</p>
<pre><code class="language-python">set1 = {"Roger", "Syd"}
set2 = {"Roger"}
difference = set1 - set2 #{'Syd'}
</code></pre>
<p>You can check if a set is a superset of another (and of course if a set is a subset of another):</p>
<pre><code class="language-python">set1 = {"Roger", "Syd"}
set2 = {"Roger"}
isSuperset = set1 &gt; set2 # True
</code></pre>
<p>You can count the items in a set with the <code>len()</code> global function:</p>
<pre><code class="language-python">names = {"Roger", "Syd"}
len(names) # 2
</code></pre>
<p>You can get a list from the items in a set by passing the set to the <code>list()</code> constructor:</p>
<pre><code class="language-python">names = {"Roger", "Syd"}
list(names) #['Syd', 'Roger']
</code></pre>
<p>You can check if an item is contained in a set with the <code>in</code> operator:</p>
<pre><code class="language-python">print("Roger" in names) # True
</code></pre>
<p>A function lets us create a set of instructions that we can run when needed.</p>
<p>Functions are essential in Python and in many other programming languages. They help us create meaningful programs, because they allow us to decompose a program into manageable parts, and they promote readability and code reuse.</p>
<p>Here is an example function called <code>hello</code> that prints "Hello!":</p>
<pre><code class="language-python">def hello():
print('Hello!')
</code></pre>
<p>This is the function <strong>definition</strong>. Thereis a name (<code>hello</code>) and a body, the set of instructions, which is the part that follows the colon. It's indented one level on the right.</p>
<p>To run this function, we must call it. This is the syntax to call the function:</p>
<pre><code class="language-python">hello()
</code></pre>
<p>We can execute this function once, or multiple times.</p>
<p>The name of the function, <code>hello</code>, is very important. It should be descriptive, so anyone calling it can imagine what the function does.</p>
<p>A function can accept one or more parameters:</p>
<pre><code class="language-python">def hello(name):
print('Hello ' + name + '!')
</code></pre>
<p>In this case we call the function by passing the argument</p>
<pre><code class="language-python">hello('Roger')
</code></pre>
<blockquote>
<p>We call <em>parameters</em> the values accepted by the function inside the function definition, and <em>arguments</em> the values we pass to the function when we call it. It's common to get confused about this distinction.</p>
</blockquote>
<p>An argument can have a default value that's applied if the argument is not specified:</p>
<pre><code class="language-python">def hello(name='my friend'):
print('Hello ' + name + '!')
hello()
#Hello my friend!
</code></pre>
<p>Here's how we can accept multiple parameters:</p>
<pre><code class="language-python">def hello(name, age):
print('Hello ' + name + ', you are ' + str(age) + ' years old!')
</code></pre>
<p>In this case we call the function passing a set of arguments:</p>
<pre><code class="language-python">hello('Roger', 8)
</code></pre>
<p>Parameters are passed by reference. All types in Python are objects, but some of them are immutable, including integers, booleans, floats, strings, and tuples. This means that if you pass them as parameters and you modify their value inside the function, the new value is not reflected outside of the function:</p>
<pre><code class="language-python">def change(value):
value = 2
val = 1
change(val)
print(val) #1
</code></pre>
<p>If you pass an object that's not immutable, and you change one of its properties, the change will be reflected outside.</p>
<p>A function can return a value, using the <code>return</code> statement. For example in this case we return the <code>name</code> parameter name:</p>
<pre><code class="language-python">def hello(name):
print('Hello ' + name + '!')
return name
</code></pre>
<p>When the function meets the <code>return</code> statement, the function ends.</p>
<p>We can omit the value:</p>
<pre><code class="language-python">def hello(name):
print('Hello ' + name + '!')
return
</code></pre>
<p>We can have the return statement inside a conditional, which is a common way to end a function if a starting condition is not met:</p>
<pre><code class="language-python">def hello(name):
if not name:
return
print('Hello ' + name + '!')
</code></pre>
<p>If we call the function passing a value that evaluates to <code>False</code>, like an empty string, the function is terminated before reaching the <code>print()</code> statement.</p>
<p>You can return multiple values by using comma separated values:</p>
<pre><code class="language-python">def hello(name):
print('Hello ' + name + '!')
return name, 'Roger', 8
</code></pre>
<p>In this case calling <code>hello('Syd')</code> the return value is a tuple containing those 3 values: <code>('Syd', 'Roger', 8)</code>.</p>
<p>Everything in Python is an object.</p>
<p>Even values of basic primitive types (integer, string, float..) are objects. Lists are objects, as are tuples, dictionaries, everything.</p>
<p>Objects have <strong>attributes</strong> and <strong>methods</strong> that can be accessed using the dot syntax.</p>
<p>For example, try defining a new variable of type <code>int</code>:</p>
<pre><code class="language-python">age = 8
</code></pre>
<p><code>age</code> now has access to the properties and methods defined for all <code>int</code> objects.</p>
<p>This includes, for example, access to the real and imaginary part of that number:</p>
<pre><code class="language-python">print(age.real) # 8
print(age.imag) # 0
print(age.bit_length()) #4
# the bit_length() method returns the number of bits necessary to represent this number in binary notation
</code></pre>
<p>A variable holding a list value has access to a different set of methods:</p>
<pre><code class="language-python">items = [1, 2]
items.append(3)
items.pop()
</code></pre>
<p>The methods depend on the type of value.</p>
<p>The <code>id()</code> global function provided by Python lets you inspect the location in memory for a particular object.</p>
<pre><code class="language-python">id(age) # 140170065725376
</code></pre>
<blockquote>
<p>Your memory value will change - I am only showing it as an example.</p>
</blockquote>
<p>If you assign a different value to the variable, its address will change, because the content of the variable has been replaced with another value stored in another location in memory:</p>
<pre><code class="language-python">age = 8
print(id(age)) # 140535918671808
age = 9
print(id(age)) # 140535918671840
</code></pre>
<p>But if you modify the object using its methods, the address stays the same:</p>
<pre><code class="language-python">items = [1, 2]
print(id(items)) # 140093713593920
items.append(3)
print(items) # [1, 2, 3]
print(id(items)) # 140093713593920
</code></pre>
<p>The address only changes if you reassign a variable to another value.</p>
<p>Some objects are <em>mutable</em>, while others are <em>immutable</em>. This depends on the object itself.</p>
<p>If the object provides methods to change its content, then it's mutable. Otherwise it's immutable.</p>
<p>Most types defined by Python are immutable. For example an <code>int</code> is immutable. There are no methods to change its value. If you increment the value using</p>
<pre><code class="language-python">age = 8
age = age + 1
#or
age += 1
</code></pre>
<p>and you check with <code>id(age)</code>, you will find that <code>age</code> points to a different memory location. The original value has not mutated, we just switched to another value.</p>
<p>Loops are one essential part of programming.</p>
<p>In Python we have 2 kinds of loops: <strong>while loops</strong> and <strong>for loops</strong>.</p>
<h3 id="whileloopsinpython"><code>while</code> loops in Python</h3>
<p><code>while</code> loops are defined using the <code>while</code> keyword, and they repeat their block until the condition is evaluated as <code>False</code>:</p>
<pre><code class="language-python">condition = True
while condition == True:
print("The condition is True")
</code></pre>
<p>This is an <strong>infinite loop</strong>. It never ends.</p>
<p>Let's halt the loop right after the first iteration:</p>
<pre><code class="language-python">condition = True
while condition == True:
print("The condition is True")
condition = False
print("After the loop")
</code></pre>
<p>In this case, the first iteration is run, as the condition test is evaluated to <code>True</code>. At the second iteration, the condition test evaluates to <code>False</code>, so the control goes to the next instruction after the loop.</p>
<p>It's common to have a counter to stop the iteration after some number of cycles:</p>
<pre><code class="language-python">count = 0
while count &lt; 10:
print("The condition is True")
count = count + 1
print("After the loop")
</code></pre>
<h3 id="forloopsinpython"><code>for</code> loops in Python</h3>
<p>Using <code>for</code> loops we can tell Python to execute a block for a pre-determined amount of times, up front, and without the need of a separate variable and conditional to check its value.</p>
<p>For example we can iterate the items in a list:</p>
<pre><code class="language-python">items = [1, 2, 3, 4]
for item in items:
print(item)
</code></pre>
<p>Or, you can iterate a specific amount of times using the <code>range()</code> function:</p>
<pre><code class="language-python">for item in range(04):
print(item)
</code></pre>
<p><code>range(4)</code> creates a sequence that starts from 0 and contains 4 items: <code>[0, 1, 2, 3]</code>.</p>
<p>To get the index, you should wrap the sequence into the <code>enumerate()</code> function:</p>
<pre><code class="language-python">items = [1, 2, 3, 4]
for index, item in enumerate(items):
print(index, item)
</code></pre>
<h3 id="breakandcontinueinpython">Break and continue in Python</h3>
<p>Both <code>while</code> and <code>for</code> loops can be interrupted inside the block, using two special keywords: <code>break</code> and <code>continue</code>.</p>
<p><code>continue</code> stops the current iteration and tells Python to execute the next one.</p>
<p><code>break</code> stops the loop altogether, and goes on with the next instruction after the loop ends.</p>
<p>The first example here prints <code>1, 3, 4</code>. The second example prints <code>1</code>:</p>
<pre><code class="language-python">items = [1, 2, 3, 4]
for item in items:
if item == 2:
continue
print(item)
</code></pre>
<pre><code class="language-python">items = [1, 2, 3, 4]
for item in items:
if item == 2:
break
print(item)
</code></pre>
<p>In addition to using the Python-provided types, we can declare our own classes, and from classes we can instantiate objects.</p>
<p>An object is an instance of a class. A class is the type of an object.</p>
<p>We can define a class in this way:</p>
<pre><code class="language-python">class &lt;class_name&gt;:
# my class
</code></pre>
<p>For example let's define a Dog class</p>
<pre><code class="language-python">class Dog:
# the Dog class
</code></pre>
<p>A class can define methods:</p>
<pre><code class="language-python">class Dog:
# the Dog class
def bark(self):
print('WOF!')
</code></pre>
<blockquote>
<p><code>self</code> as the argument of the method points to the current object instance, and must be specified when defining a method.</p>
</blockquote>
<p>We create an instance of a class, an <strong>object</strong>, using this syntax:</p>
<pre><code class="language-python">roger = Dog()
</code></pre>
<p>Now <code>roger</code> is a new object of type Dog.</p>
<p>If you run</p>
<pre><code class="language-python">print(type(roger))
</code></pre>
<p>You will get <code>&lt;class '__main__.Dog'&gt;</code></p>
<p>A special type of method, <code>__init__()</code> is called constructor, and we can use it to initialize one or more properties when we create a new object from that class:</p>
<pre><code class="language-python">class Dog:
# the Dog class
def __init__(self, name, age):
self.name = name
self.age = age
def bark(self):
print('WOF!')
</code></pre>
<p>We use it in this way:</p>
<pre><code class="language-python">roger = Dog('Roger', 8)
print(roger.name) # 'Roger'
print(roger.age)  # 8
roger.bark() # 'WOF!'
</code></pre>
<p>One important feature of classes is inheritance.</p>
<p>We can create an Animal class with a method <code>walk()</code>:</p>
<pre><code class="language-python">class Animal:
def walk(self):
print('Walking..')
</code></pre>
<p>and the Dog class can inherit from Animal:</p>
<pre><code class="language-python">class Dog(Animal):
def bark(self):
print('WOF!')
</code></pre>
<p>Now creating a new object of class <code>Dog</code> will have the <code>walk()</code> method as that's inherited from <code>Animal</code>:</p>
<pre><code class="language-python">roger = Dog()
roger.walk() # 'Walking..'
roger.bark() # 'WOF!'
</code></pre>
<p>Every Python file is a module.</p>
<p>You can import a module from other files, and that's the base of any program of moderate complexity, as it promotes a sensible organization and code reuse.</p>
<p>In the typical Python program, one file acts as the entry point. The other files are modules and expose functions that we can call from other files.</p>
<p>The file <code>dog.py</code> contains this code:</p>
<pre><code class="language-python">def bark():
print('WOF!')
</code></pre>
<p>We can import this function from another file using <code>import</code>. And once we do, we can reference the function using the dot notation, <code>dog.bark()</code>:</p>
<pre><code class="language-python">import dog
dog.bark()
</code></pre>
<p>Or, we can use the <code>from .. import</code> syntax and call the function directly:</p>
<pre><code class="language-python">from dog import bark
bark()
</code></pre>
<p>The first strategy allows us to load everything defined in a file.</p>
<p>The second strategy lets us pick the things we need.</p>
<p>Those modules are specific to your program, and importing depends on the location of the file in the filesystem.</p>
<p>Suppose you put <code>dog.py</code> in a <code>lib</code> subfolder.</p>
<p>In that folder, you need to create an empty file named <code>__init__.py</code>. This tells Python the folder contains modules.</p>
<p>Now you can choose - you can import <code>dog</code> from <code>lib</code>:</p>
<pre><code class="language-py">from lib import dog
dog.bark()
</code></pre>
<p>or you can reference the <code>dog</code> module specific function importing from <code>lib.dog</code>:</p>
<pre><code class="language-py">from lib.dog import bark
bark()
</code></pre>
<p>Python exposes a lot of built-in functionality through its <strong>standard library</strong>.</p>
<p>The standard library is a huge collection of all sort of utilities, ranging from math utilities to debugging to creating graphical user interfaces.</p>
<p>You can find the full list of standard library modules here: <a href="https://docs.python.org/3/library/index.html">https://docs.python.org/3/library/index.html</a></p>
<p>Some of the important modules are:</p>
<ul>
<li><code>math</code> for math utilities</li>
<li><code>re</code> for regular expressions</li>
<li><code>json</code> to work with JSON</li>
<li><code>datetime</code> to work with dates</li>
<li><code>sqlite3</code> to use SQLite</li>
<li><code>os</code> for Operating System utilities</li>
<li><code>random</code> for random number generation</li>
<li><code>statistics</code> for statistics utilities</li>
<li><code>requests</code> to perform HTTP network requests</li>
<li><code>http</code> to create HTTP servers</li>
<li><code>urllib</code> to manage URLs</li>
</ul>
<p>Let's introduce how to <em>use</em> a module of the standard library. You already know how to use modules you create, importing from other files in the program folder.</p>
<p>Well that's the same with modules provided by the standard library:</p>
<pre><code class="language-python">import math
math.sqrt(4) # 2.0
</code></pre>
<p>or</p>
<pre><code class="language-python">from math import sqrt
sqrt(4) # 2.0
</code></pre>
<p>We'll soon explore the most important modules individually to understand what we can do with them.</p>
<p>When you write code, you should adhere to the conventions of the programming language you use.</p>
<p>If you learn the right naming and formatting conventions right from the start, it will be easier to read code written by other people, and people will find your code easier to read.</p>
<p>Python defines its conventions in the PEP8 style guide. PEP stands for <em>Python Enhancement Proposals</em> and it's the place where all Python language enhancements and discussions happen.</p>
<p>There are a lot of PEP proposals, all available at <a href="https://www.python.org/dev/peps/">https://www.python.org/dev/peps/</a>.</p>
<p>PEP8 is one of the first ones, and one of the most important, too. It defines the formatting and also some rules on how to write Python in a "pythonic" way.</p>
<p>You can read its full content here: <a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a> but here's a quick summary of the important points you can start with:</p>
<ul>
<li>Indent using spaces, not tabs</li>
<li>Indent using 4 spaces.</li>
<li>Python files are encoded in UTF-8</li>
<li>Use maximum 80 columns for your code</li>
<li>Write each statement on its own line</li>
<li>Functions, variable names and file names are lowercase, with underscores between words (snake_case)</li>
<li>Class names are capitalized, separate words are written with the capital letter too, (CamelCase)</li>
<li>Package names are lowercase and do not have underscores between words</li>
<li>Variables that should not change (constants) are written in uppercase</li>
<li>Variable names should be meaningful</li>
<li>Add useful comments, but avoid obvious comments</li>
<li>Add spaces around operators</li>
<li>Do not use unnecessary whitespace</li>
<li>Add a blank line before a function</li>
<li>Add a blank line between methods in a class</li>
<li>Inside functions/methods, blank lines can be used to separate related blocks of code to help readability</li>
</ul>
<p>Debugging is one of the best skills you can learn, as it will help you in many difficult situations.</p>
<p>Every language has its debugger. Python has <code>pdb</code>, available through the standard library.</p>
<p>You debug by adding one breakpoint into your code:</p>
<pre><code class="language-python">breakpoint()
</code></pre>
<blockquote>
<p>You can add more breakpoints if needed.</p>
</blockquote>
<p>When the Python interpreter hits a breakpoint in your code, it will stop, and it will tell you what is the next instruction it will run.</p>
<p>Then and you can do a few things.</p>
<p>You can type the name of any variable to inspect its value.</p>
<p>You can press <code>n</code> to step to the next line in the current function. If the code calls functions, the debugger does not get into them, and considers them "black boxes".</p>
<p>You can press <code>s</code> to step to the next line in the current function. If the next line is a function, the debugger goes into that, and you can then run one instruction of that function at a time.</p>
<p>You can press <code>c</code> to continue the execution of the program normally, without the need to do it step-by-step.</p>
<p>You can press <code>q</code> to stop the execution of the program.</p>
<p>Debugging is useful to evaluate the result of an instruction, and it's especially good to know how to use it when you have complex iterations or algorithms that you want to fix.</p>
<p>When you declare a variable, that variable is visible in parts of your program, depending on where you declare it.</p>
<p>If you declare it outside of any function, the variable is visible to any code running after the declaration, including functions:</p>
<pre><code class="language-python">age = 8
def test():
print(age)
print(age) # 8
test() # 8
</code></pre>
<p>We call it a <strong>global variable</strong>.</p>
<p>If you define a variable inside a function, that variable is a <strong>local variable</strong>, and it is only visible inside that function. Outside the function, it is not reachable:</p>
<pre><code class="language-python">def test():
age = 8
print(age)
test() # 8
print(age)
# NameError: name 'age' is not defined
</code></pre>
<p>Python offers several ways to handle arguments passed when we invoke the program from the command line.</p>
<p>So far you've run programs either from a REPL, or using</p>
<pre><code class="language-sh">python &lt;filename&gt;.py
</code></pre>
<p>You can pass additional arguments and options when you do so, like this:</p>
<pre><code class="language-sh">python &lt;filename&gt;.py &lt;argument1&gt;
python &lt;filename&gt;.py &lt;argument1&gt; &lt;argument2&gt;
</code></pre>
<p>A basic way to handle those arguments is to use the <code>sys</code> module from the standard library.</p>
<p>You can get the arguments passed in the <code>sys.argv</code> list:</p>
<pre><code class="language-python">import sys
print(len(sys.argv))
print(sys.argv)
</code></pre>
<p>The <code>sys.argv</code> list contains as the first item the name of the file that was run, for example <code>['main.py']</code>.</p>
<p>This is a simple way, but you have to do a lot of work. You need to validate arguments, make sure their type is correct, and you need to print feedback to the user if they are not using the program correctly.</p>
<p>Python provides another package in the standard library to help you: <code>argparse</code>.</p>
<p>First you import <code>argparse</code> and you call <code>argparse.ArgumentParser()</code>, passing the description of your program:</p>
<pre><code class="language-python">import argparse
parser = argparse.ArgumentParser(
description='This program prints the name of my dogs'
)
</code></pre>
<p>Then you proceed to add arguments you want to accept.<br>
For example in this program we accept a <code>-c</code> option to pass a color, like this: <code>python program.py -c red</code></p>
<pre><code class="language-python">import argparse
parser = argparse.ArgumentParser(
description='This program prints a color HEX value'
)
parser.add_argument('-c', '--color', metavar='color', required=True, help='the color to search for')
args = parser.parse_args()
print(args.color) # 'red'
</code></pre>
<p>If the argument is not specified, the program raises an error:</p>
<pre><code>➜  python python program.py
usage: program.py [-h] -c color
program.py: error: the following arguments are required: -c
</code></pre>
<p>You can set an option to have a specific set of values, using <code>choices</code>:</p>
<pre><code class="language-python">parser.add_argument('-c', '--color', metavar='color', required=True, choices={'red','yellow'}, help='the color to search for')
</code></pre>
<pre><code>➜  python python program.py -c blue
usage: program.py [-h] -c color
program.py: error: argument -c/--color: invalid choice: 'blue' (choose from 'yellow', 'red')
</code></pre>
<p>There are more options, but those are the basics.</p>
<p>And there are community packages that provide this functionality, too, like <a href="https://click.palletsprojects.com/en/7.x/">Click</a> and <a href="https://python-prompt-toolkit.readthedocs.io/en/master/index.html">Python Prompt Toolkit</a>.</p>
<p>Lambda functions (also called anonymous functions) are tiny functions that have no name and only have one expression as their body.</p>
<p>In Python they are defined using the <code>lambda</code> keyword:</p>
<pre><code class="language-python">lambda &lt;arguments&gt; : &lt;expression&gt;
</code></pre>
<p>The body must be a single expression - an expression, not a statement.</p>
<blockquote>
<p>This difference is important. An expression returns a value, a statement does not.</p>
</blockquote>
<p>The simplest example of a lambda function is a function that doubles the value of a number:</p>
<pre><code class="language-python">lambda num : num * 2
</code></pre>
<p>Lambda functions can accept more arguments:</p>
<pre><code class="language-python">lambda a, b : a * b
</code></pre>
<p>Lambda functions cannot be invoked directly, but you can assign them to variables:</p>
<pre><code class="language-python">multiply = lambda a, b : a * b
print(multiply(2, 2)) # 4
</code></pre>
<p>The utility of lambda functions comes when combined with other Python functionality, for example in combination with <code>map()</code>, <code>filter()</code> and <code>reduce()</code>.</p>
<p>A function in Python can call itself. That's what recursion is. And it can be pretty useful in many scenarios.</p>
<p>The common way to explain recursion is by using the factorial calculation.</p>
<p>The factorial of a number is the number <code>n</code> mutiplied by <code>n-1</code>, multiplied by <code>n-2</code>... and so on, until reaching the number <code>1</code>:</p>
<pre><code>3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
</code></pre>
<p>Using recursion we can write a function that calculates the factorial of any number:</p>
<pre><code class="language-python">def factorial(n):
if n == 1: return 1
return n * factorial(n-1)
print(factorial(3)) #   6
print(factorial(4)) #  24
print(factorial(5)) # 120
</code></pre>
<p>If inside the <code>factorial()</code> function you call <code>factorial(n)</code> instead of <code>factorial(n-1)</code>, you are going to cause an infinite recursion. Python by default will halt recursions at 1000 calls, and when this limit is reached, you will get a <code>RecursionError</code> error.</p>
<p>Recursion is helpful in many places, and it helps us simplify our code when there's no other optimal way to do it, so it's good to know this technique.</p>
<p>Functions in Python can be nested inside other functions.</p>
<p>A function defined inside a function is visible only inside that function.</p>
<p>This is useful to create utilities that are useful to a function, but not useful outside of it.</p>
<p>You might ask: why should I be "hiding" this function, if it does no harm?</p>
<p>One, because it's always best to hide functionality that's local to a function, and is not useful elsewhere.</p>
<p>Also, because we can make use of closures (more on this later).</p>
<p>Here is an example:</p>
<pre><code class="language-python">def talk(phrase):
def say(word):
print(word)
words = phrase.split(' ')
for word in words:
say(word)
talk('I am going to buy the milk')
</code></pre>
<p>If you want to access a variable defined in the outer function from the inner function, you first need to declare it as <code>nonlocal</code>:</p>
<pre><code class="language-python">def count():
count = 0
def increment():
nonlocal count
count = count + 1
print(count)
increment()
count()
</code></pre>
<p>This is useful especially with closures, as we'll see next.</p>
<p>If you return a nested function from a function, that nested function has access to the variables defined in that function, even if that function is not active any more.</p>
<p>Here is a simple counter example.</p>
<pre><code class="language-python">def counter():
count = 0
def increment():
nonlocal count
count = count + 1
return count
return increment
increment = counter()
print(increment()) # 1
print(increment()) # 2
print(increment()) # 3
</code></pre>
<p>We return the <code>increment()</code> inner function, and that still has access to the state of the <code>count</code> variable even though the <code>counter()</code> function has ended.</p>
<p>Decorators are a way to change, enhance, or alter in any way how a function works.</p>
<p>Decorators are defined with the <code>@</code> symbol followed by the decorator name, just before the function definition.</p>
<p>Example:</p>
<pre><code class="language-python">@logtime
def hello():
print('hello!')
</code></pre>
<p>This <code>hello</code> function has the <code>logtime</code> decorator assigned.</p>
<p>Whenever we call <code>hello()</code>, the decorator is going to be called.</p>
<p>A decorator is a function that takes a function as a parameter, wraps the function in an inner function that performs the job it has to do, and returns that inner function. In other words:</p>
<pre><code class="language-python">def logtime(func):
def wrapper():
# do something before
val = func()
# do something after
return val
return wrapper
</code></pre>
<p>Documentation is hugely important, not just to communicate to other people what the goal of a function/class/method/module is, but it also communicates it to yourself.</p>
<p>When you come back to your code 6 or 12 months from now, you might not remember all the knowledge you are holding in your head. At that point, reading your code and understanding what it is supposed to do will be much more difficult.</p>
<p>Comments are one way to help yourself (and others) out:</p>
<pre><code class="language-python"># this is a comment
num = 1 #this is another comment
</code></pre>
<p>Another way is to use <strong>docstrings</strong>.</p>
<p>The utility of docstrings is that they follow conventions. As such they can be processed automatically.</p>
<p>This is how you define a docstring for a function:</p>
<pre><code class="language-python">def increment(n):
"""Increment a number"""
return n + 1
</code></pre>
<p>This is how you define a docstring for a class and a method:</p>
<pre><code class="language-python">class Dog:
"""A class representing a dog"""
def __init__(self, name, age):
"""Initialize a new dog"""
self.name = name
self.age = age
def bark(self):
"""Let the dog bark"""
print('WOF!')
</code></pre>
<p>Document a module by placing a docstring at the top of the file, for example supposing this is <code>dog.py</code>:</p>
<pre><code class="language-python">"""Dog module
This module does ... bla bla bla and provides the following classes:
- Dog
...
"""
class Dog:
"""A class representing a dog"""
def __init__(self, name, age):
"""Initialize a new dog"""
self.name = name
self.age = age
def bark(self):
"""Let the dog bark"""
print('WOF!')
</code></pre>
<p>Docstrings can span multiple lines:</p>
<pre><code class="language-python">def increment(n):
"""Increment
a number
"""
return n + 1
</code></pre>
<p>Python will process those and you can use the <code>help()</code> global function to get the documentation for a class/method/function/module.</p>
<p>For example calling <code>help(increment)</code> will give you this:</p>
<pre><code>Help on function increment in module
__main__:
increment(n)
Increment
a number
</code></pre>
<p>There are many different standards to format docstrings, and you can choose to adhere to your favorite one.</p>
<p>I like Google's standard: <a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings">https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings</a></p>
<p>Standards allow to have tools to extract docstrings and automatically generate documentation for your code.</p>
<p>Functions, variables, and objects can be analyzed using <strong>introspection</strong>.</p>
<p>First, using the <code>help()</code> global function we can get the documentation if provided in form of docstrings.</p>
<p>Then, you can use print() to get information about a function:</p>
<pre><code class="language-python">def increment(n):
return n + 1
print(increment)
# &lt;function increment at 0x7f420e2973a0&gt;
</code></pre>
<p>or an object:</p>
<pre><code class="language-python">class Dog():
def bark(self):
print('WOF!')
roger = Dog()
print(roger)
# &lt;__main__.Dog object at 0x7f42099d3340&gt;
</code></pre>
<p>The <code>type()</code> function gives us the type of an object:</p>
<pre><code class="language-python">print(type(increment))
# &lt;class 'function'&gt;
print(type(roger))
# &lt;class '__main__.Dog'&gt;
print(type(1))
# &lt;class 'int'&gt;
print(type('test'))
# &lt;class 'str'&gt;
</code></pre>
<p>The <code>dir()</code> global function lets us find out all the methods and attributes of an object:</p>
<pre><code class="language-python">print(dir(roger))
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'bark']
</code></pre>
<p>The <code>id()</code> global function shows us the location in memory of any object:</p>
<pre><code class="language-python">print(id(roger)) # 140227518093024
print(id(1))     # 140227521172384
</code></pre>
<p>It can be useful to check if two variables point to the same object.</p>
<p>The <code>inspect</code> standard library module gives us more tools to get information about objects, and you can check it out here: <a href="https://docs.python.org/3/library/inspect.html">https://docs.python.org/3/library/inspect.html</a></p>
<p>Python is dynamically typed. We do not have to specify the type of a variable or function parameter, or a function return value.</p>
<p>Annotations allow us to (optionally) do that.</p>
<p>This is a function without annotations:</p>
<pre><code class="language-python">def increment(n):
return n + 1
</code></pre>
<p>This is the same function with annotations:</p>
<pre><code class="language-python">def increment(n: int) -&gt; int:
return n + 1
</code></pre>
<p>You can also annotate variables:</p>
<pre><code class="language-python">count: int = 0
</code></pre>
<p>Python will ignore those annotations. A separate tool called <a href="http://mypy-lang.org/"><code>mypy</code></a> can be run standalone, or integrated by IDE like VS Code or PyCharm to automatically check for type errors statically, while you are coding. It will also help you catch type mismatch bugs before even running the code.</p>
<p>A great help especially when your software becomes large and you need to refactor your code.</p>
<p>It's important to have a way to handle errors, and Python gives us exception handling to do so.</p>
<p>If you wrap lines of code into a <code>try:</code> block:</p>
<pre><code class="language-python">try:
# some lines of code
</code></pre>
<p>If an error occurs, Python will alert you and you can determine which kind of error occurred using a <code>except</code> blocks:</p>
<pre><code class="language-python">try:
# some lines of code
except &lt;ERROR1&gt;:
# handler &lt;ERROR1&gt;
except &lt;ERROR2&gt;:
# handler &lt;ERROR2&gt;
</code></pre>
<p>To catch all exceptions you can use <code>except</code> without any error type:</p>
<pre><code class="language-python">try:
# some lines of code
except &lt;ERROR1&gt;:
# handler &lt;ERROR1&gt;
except:
# catch all other exceptions
</code></pre>
<p>The <code>else</code> block is run if no exceptions were found:</p>
<pre><code class="language-python">try:
# some lines of code
except &lt;ERROR1&gt;:
# handler &lt;ERROR1&gt;
except &lt;ERROR2&gt;:
# handler &lt;ERROR2&gt;
else:
# no exceptions were raised, the code ran successfully
</code></pre>
<p>A <code>finally</code> block lets you perform some operation in any case, regardless of whether an error occurred or not:</p>
<pre><code class="language-python">try:
# some lines of code
except &lt;ERROR1&gt;:
# handler &lt;ERROR1&gt;
except &lt;ERROR2&gt;:
# handler &lt;ERROR2&gt;
else:
# no exceptions were raised, the code ran successfully
finally:
# do something in any case
</code></pre>
<p>The specific error that's going to occur depends on the operation you're performing.</p>
<p>For example if you are reading a file, you might get an <code>EOFError</code>. If you divide a number by zero you will get a <code>ZeroDivisionError</code>. If you have a type conversion issue you might get a <code>TypeError</code>.</p>
<p>Try this code:</p>
<pre><code class="language-python">result = 2 / 0
print(result)
</code></pre>
<p>The program will terminate with an error:</p>
<pre><code>Traceback (most recent call last):
File "main.py", line 1, in &lt;module&gt;
result = 2 / 0
ZeroDivisionError: division by zero
</code></pre>
<p>and the lines of code after the error will not be executed.</p>
<p>Adding that operation in a <code>try:</code> block lets us recover gracefully and move on with the program:</p>
<pre><code class="language-python">try:
result = 2 / 0
except ZeroDivisionError:
print('Cannot divide by zero!')
finally:
result = 1
print(result) # 1
</code></pre>
<p>You can raise exceptions in your own code, too, using the <code>raise</code> statement:</p>
<pre><code class="language-python">raise Exception('An error occurred!')
</code></pre>
<p>This raises a general exception, and you can intercept it using:</p>
<pre><code class="language-python">try:
raise Exception('An error occurred!')
except Exception as error:
print(error)
</code></pre>
<p>You can also define your own exception class, extending from Exception:</p>
<pre><code class="language-python">class DogNotFoundException(Exception):
pass
</code></pre>
<blockquote>
<p><code>pass</code> here means "nothing" and we must use it when we define a class without methods, or a function without code, too.</p>
</blockquote>
<pre><code class="language-python">try:
raise DogNotFoundException()
except DogNotFoundException:
print('Dog not found!')
</code></pre>
<p>The <code>with</code> statement is very helpful to simplify working with exception handling.</p>
<p>For example when working with files, each time we open a file, we must remember to close it.</p>
<p><code>with</code> makes this process transparent.</p>
<p>Instead of writing:</p>
<pre><code class="language-python">filename = '/Users/flavio/test.txt'
try:
file = open(filename, 'r')
content = file.read()
print(content)
finally:
file.close()
</code></pre>
<p>You can write:</p>
<pre><code class="language-python">filename = '/Users/flavio/test.txt'
with open(filename, 'r') as file:
content = file.read()
print(content)
</code></pre>
<p>In other words we have built-in implicit exception handling, as <code>close()</code> will be called automatically for us.</p>
<p><code>with</code> is not just helpful to work with files. The above example is just meant to introduce its capabilities.</p>
<p>The Python standard library contains a huge number of utilities that simplify our Python development needs, but nothing can satisfy <em>everything</em>.</p>
<p>That's why individuals and companies create packages, and make them available as open source software for the entire community.</p>
<p>Those modules are all collected in a single place, the <strong>Python Package Index</strong> available at <a href="https://pypi.org">https://pypi.org</a>, and they can be installed on your system using <code>pip</code>.</p>
<p>There are more than 270,000 packages freely available at the time of writing.</p>
<blockquote>
<p>You should have <code>pip</code> already installed if you followed the Python installation instructions.</p>
</blockquote>
<p>Install any package using the command <code>pip install</code>:</p>
<pre><code>pip install &lt;package&gt;
</code></pre>
<p>or, if you do have troubles, you can also run it through <code>python -m</code>:</p>
<pre><code>python -m pip install &lt;package&gt;
</code></pre>
<p>For example you can install the <a href="https://pypi.org/project/requests/"><code>requests</code></a> package, a popular HTTP library:</p>
<pre><code>pip install requests
</code></pre>
<p>and once you do, it will be available for all your Python scripts, because packages are installed globally.</p>
<p>The exact location depends on your operating system.</p>
<p>On macOS, running Python 3.9, the location is <code>/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages</code>.</p>
<p>Upgrade a package to its latest version using:</p>
<pre><code>pip install –U &lt;package&gt;
</code></pre>
<p>Install a specific version of a package using:</p>
<pre><code>pip install &lt;package&gt;==&lt;version&gt;
</code></pre>
<p>Uninstall a package using:</p>
<pre><code>pip uninstall &lt;package&gt;
</code></pre>
<p>Show an installed package details, including version, documentation website and author information using:</p>
<pre><code>pip show &lt;package&gt;
</code></pre>
<p>List comprehensions are a way to create lists in a very concise way.</p>
<p>Suppose you have a list:</p>
<pre><code class="language-python">numbers = [1, 2, 3, 4, 5]
</code></pre>
<p>You can create a new list using a list comprehension, composed by the <code>numbers</code> list elements, power 2:</p>
<pre><code class="language-python">numbers_power_2 = [n**2 for n in numbers]
# [1, 4, 9, 16, 25]
</code></pre>
<p>List comprehensions are a syntax that's sometimes preferred over loops, as it's more readable when the operation can be written on a single line:</p>
<pre><code class="language-python">numbers_power_2 = []
for n in numbers:
numbers_power_2.append(n**2)
</code></pre>
<p>and over <code>map()</code>:</p>
<pre><code class="language-python">numbers_power_2 = list(map(lambda n : n**2, numbers))
</code></pre>
<p>Polymorphism generalizes a functionality so it can work on different types. It's an important concept in object-oriented programming.</p>
<p>We can define the same method on different classes:</p>
<pre><code class="language-python">class Dog:
def eat():
print('Eating dog food')
class Cat:
def eat():
print('Eating cat food')
</code></pre>
<p>Then we can generate objects and we can call the <code>eat()</code> method regardless of the class the object belongs to, and we'll get different results:</p>
<pre><code class="language-python">animal1 = Dog()
animal2 = Cat()
animal1.eat()
animal2.eat()
</code></pre>
<p>We built a generalized interface and we now do not need to know that an animal is a Cat or a Dog.</p>
<p>Operator overloading is an advanced technique we can use to make classes comparable and to make them work with Python operators.</p>
<p>Let's take a class Dog:</p>
<pre><code class="language-python">class Dog:
# the Dog class
def __init__(self, name, age):
self.name = name
self.age = age
</code></pre>
<p>Let's create 2 Dog objects:</p>
<pre><code class="language-python">roger = Dog('Roger', 8)
syd = Dog('Syd', 7)
</code></pre>
<p>We can use operator overloading to add a way to compare those 2 objects, based on the <code>age</code> property:</p>
<pre><code class="language-python">class Dog:
# the Dog class
def __init__(self, name, age):
self.name = name
self.age = age
def __gt__(self, other):
return True if self.age &gt; other.age else False
</code></pre>
<p>Now if you try running <code>print(roger &gt; syd)</code> you will get the result <code>True</code>.</p>
<p>In the same way we defined <code>__gt__()</code> (which means greater than), we can define the following methods:</p>
<ul>
<li><code>__eq__()</code> to check for equality</li>
<li><code>__lt__()</code> to check if an object should be considered lower than another with the <code>&lt;</code> operator</li>
<li><code>__le__()</code> for lower or equal (<code>&lt;=</code>)</li>
<li><code>__ge__()</code> for greater or equal (<code>&gt;=</code>)</li>
<li><code>__ne__()</code> for not equal (<code>!=</code>)</li>
</ul>
<p>Then you have methods to interoperate with arithmetic operations:</p>
<ul>
<li><code>__add__()</code> respond to the <code>+</code> operator</li>
<li><code>__sub__()</code> respond to the <code>–</code> operator</li>
<li><code>__mul__()</code> respond to the <code>*</code> operator</li>
<li><code>__truediv__()</code> respond to the <code>/</code> operator</li>
<li><code>__floordiv__()</code> respond to the <code>//</code> operator</li>
<li><code>__mod__()</code> respond to the <code>%</code> operator</li>
<li><code>__pow__()</code> respond to the <code>**</code> operator</li>
<li><code>__rshift__()</code> respond to the <code>&gt;&gt;</code> operator</li>
<li><code>__lshift__()</code> respond to the <code>&lt;&lt;</code> operator</li>
<li><code>__and__()</code> respond to the <code>&amp;</code> operator</li>
<li><code>__or__()</code> respond to the <code>|</code> operator</li>
<li><code>__xor__()</code> respond to the <code>^</code> operator</li>
</ul>
<p>There are a few more methods to work with other operators, but you get the idea.</p>
<p>It's common to have multiple Python applications running on your system.</p>
<p>When applications require the same module, at some point you will reach a tricky situation where an app needs a version of a module, and another app a different version of that same module.</p>
<p>To solve this, you use <strong>virtual environments</strong>.</p>
<p>We'll use <code>venv</code>. Other tools work similarly, like <code>pipenv</code>.</p>
<p>Create a virtual environment using</p>
<pre><code class="language-sh">python -m venv .venv
</code></pre>
<p>in the folder where you want to start the project, or where you already have an existing project.</p>
<p>Then run</p>
<pre><code class="language-sh">source .venv/bin/activate
</code></pre>
<blockquote>
<p>Use <code>source .venv/bin/activate.fish</code> on the Fish shell</p>
</blockquote>
<p>Executing the program will activate the Python virtual environment. Depending on your configuration you might also see your terminal prompt change.</p>
<p>Mine changed from</p>
<p><code>➜ folder </code></p>
<p>to</p>
<p><code>(.venv) ➜ folder </code></p>
<p>Now running <code>pip</code> will use this virtual environment instead of the global environment.</p>
<p>Thanks a lot for reading this book.</p>
<p>I hope it will inspire you to learn more about Python.</p>
<p>For more on Python and programming tutorials in general, check out my blog <a href="https://flaviocopes.com">flaviocopes.com</a>.</p>
<p>Send any feedback, errata, or opinions at <a href="mailto:flavio@flaviocopes.com">mailto:flavio@flaviocopes.com</a>, and you can reach me on Twitter <a href="https://twitter.com/flaviocopes">@flaviocopes</a>.</p>
<blockquote>
<p>Note: You can <a href="https://flaviocopes.com/page/python-handbook/">get a PDF, ePub and Mobi version of this Python Handbook</a></p>
</blockquote>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
