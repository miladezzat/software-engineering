---
card: "https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png"
tags: [JavaScript]
description: by Peter Mbanugo
author: "Milad E. Fahmy"
title: "Going serverless with React and AWS Amplify Part 2: Creating And Using Serverless Services"
created: "2021-08-15T19:37:27+02:00"
modified: "2021-08-15T19:37:27+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-javascript tag-aws tag-react tag-serverless tag-tech ">
<header class="post-full-header">
<h1 class="post-full-title">Going serverless with React and AWS Amplify Part 2: Creating And Using Serverless Services</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*0iJpmj6zVTc8EHFGW5VTnA.png" alt="Going serverless with React and AWS Amplify Part 2: Creating And Using Serverless Services">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content medium-migrated-article">
<p>by Peter Mbanugo</p>
<h1 id="going-serverless-with-react-and-aws-amplify-part-2-creating-and-using-serverless-services">Going serverless with React and AWS Amplify Part 2: Creating And Using Serverless Services</h1>
<p>Serverless is a cloud-computing execution model in which the cloud provider is responsible for executing a piece of code by dynamically allocating resources to run the code when needed. In a previous <a href="https://medium.freecodecamp.org/going-serverless-with-react-and-aws-amplify-development-environment-set-up-9b15c3363bd" rel="noopener">post</a>, we looked at what serverless is, and we set up our computer to be able to build serverless applications using AWS Amplify. We bootstrapped a React project and added the Amplify library to it. In this post, we will use the Amplify CLI to provision a secured backend API and a NoSQL database. Then we will consume this API from the React project.</p>
<h3 id="creating-the-serverless-backend-services">Creating The Serverless Backend Services</h3>
<p>The application we’re going to build will allow users to perform basic CRUD operations. We will use a REST API with a NoSQL database. Follow the instruction below to create the serverless backend.</p>
<ol>
<li>Open the command line and go to the root directory of your project.</li>
<li>Run the command <code>amplify add api</code>.</li>
<li>You get a prompt to select a service type. Choose <code>REST</code> and press Enter.</li>
<li>It prompts you to enter a name for the current category (the API category). Enter <code>todosApi</code> and press Enter.</li>
<li>You’re asked for a path. Accept the default <code>items</code> path by pressing Enter.</li>
<li>The next prompt asks for the Lambda source. The serverless REST API works by creating a path on API Gateway and mapping that path to a lambda function. The lambda function contains code to execute when a request is made to the path it’s mapped to. We will create a new lambda. Select the option <code>Create a new Lambda function</code> and press Enter.</li>
<li>Enter <code>todosLambda</code> as the name of the resource for the category (function category), and press Enter.</li>
<li>You will be asked for the name of the lambda function. Enter <code>todos</code> and press Enter.</li>
<li>You will be asked to choose a template for generating code for this function. Choose the option <code>CRUD function for Amazon DynamoDB table (Integration with Amazon API Gateway and Amazon DynamoDB)</code> and press Enter. This creates an architecture using API Gateway with Express running in an AWS Lambda function that reads and writes to Amazon DynamoDB.</li>
<li>The next prompt asks you to choose a DynanoDB data source. We do not have an existing DynamoDB table so we will choose the <code>Create a new DynamoDB table</code> option. Press Enter to continue. Now you should see DynamoDB database wizard. It'll ask a series of questions to determine how to create the database.</li>
<li>You will be asked to enter the name for this resource. Enter <code>todosTable</code> and press Enter.</li>
<li>The next prompt is for the table name. Enter <code>todos</code> and press Enter.</li>
<li>You will be asked to add columns to the DynamoDB table. Follow the prompt to create column <code>id</code> with <code>String</code> as its type.</li>
<li>Select <code>id</code> column when asked for the partition key (primary key) for the table.</li>
<li>You will be asked if you want to add a sort key to the table. Choose false.</li>
<li>The next prompt asks if you want to add global secondary indexes to your table. Enter <code>n</code> and press Enter. You should see the message <code>Successfully added DynamoDb table locally</code></li>
<li>The next prompt asks <strong>Do you want to edit the local lambda function now?</strong>. Enter <code>n</code> and press Enter. You should see the message <code>Successfully added the Lambda function locally</code>.</li>
<li>You get asked if you want to restrict access to the API. Enter <code>y</code> and press Enter.</li>
<li>For the next prompt, choose <code>Authenticated and Guest users</code> and press Enter. This option gives both authorized and guest users access to the REST API.</li>
<li>Next, you get asked <code>What kind of access do you want for Authenticated users</code>. Choose <code>read/write</code> and press Enter.</li>
<li>Now we get a prompt to choose the kind of access for unauthenticated users (i.e gues users). Choose <code>read</code> and press Enter. You should get the message <code>Successfully added auth resource locally</code>. This is because we have chosen to restrict access to the API, and the CLI added the Auth category to the project since we don't have any for the project. At this point, we've added resources that are needed to create our API (API Gateway, DynamoDB, Lambda function, and Cognito for authentication).</li>
<li>We get asked if we want to add another path to the API. Enter <code>n</code> and press Enter. This completes the process and we get the message <code>Successfully added resource todosApi locally</code>.</li>
</ol>
<p>The <code>amplify add api</code> command took us through the process of creating a REST API. This API will be created based on the options we chose. To create this API requires 4 AWS services. They're:</p>
<ol>
<li>Amazon DynamoDB. This will serve as our NoSQL database. We created a DynomoDB table named <code>todos</code> when we added the <code>todosTable</code> resource. We gave it 3 columns with <code>id</code> as the primary key.</li>
<li>AWS Lambda functions. This lets us run code without provisioning or managing servers. This is where our code to perform CRUD operations on the DynamoDB table will be.</li>
<li>Amazon Cognito. This is responsible for authentication and user management. This lets us add user sign-up, sign-in, and access control to our app. We chose the option to restrict access to our API, and this service will help us authenticate users.</li>
<li>Amazon API Gateway. This is what allows us to create REST API endpoint. We added a resource for this named <code>todosApi</code>, with a path <code>items</code>. We also selected the option to restrict access to the API.</li>
</ol>
<p>However, the service specifications for these services are not yet in the cloud. We need to update the project in the cloud with information to provide the needed services. Run the command <code>amplify status</code>, and we should get a table with information about the amplify project.</p>
<p>Open the file <strong>backend/function/todosLambda/src/app.js</strong>. You will notice that this file contains code generated during the resource set up process. It uses <a href="https://expressjs.com/" rel="noopener">Express.js</a> to set up routes, and <a href="https://github.com/awslabs/aws-serverless-express" rel="noopener">aws-serverless-express</a> package to easily build RESTful APIs using the Express.js framework on top of AWS Lambda and Amazon API Gateway.</p>
<p>When we push the project configuration to the cloud, it’ll configure a simple proxy API using Amazon API Gateway and integrate it with this Lambda function. The package includes middleware to easily get the event object Lambda receives from API Gateway. It was applied on line 32 <code>app.use(awsServerlessExpressMiddleware.eventContext());</code> and used across the routes with codes that looks like <code>req.apiGateway.event.*</code>. The pre-defined routes allow us to perform CRUD operation on the DynamoDB table.</p>
<p>We will make a couple of changes to this file. The first will be to change the value for <code>tableName</code> variable from <code>todosTable</code> to <code>todos</code>. When creating the DynamoDB resource, we specified <code>todosTable</code> as the resource name and <code>todos</code> as the table name, so it wrongly used the resource name as the table name when the file was created. This would likely be fixed in a future version of the CLI, so if you don't find it wrongly used, you can skip this step. We will also need to update the definitions.</p>
<p>Change the first route definition to use the code below.</p><pre><code>app.get(path, function(req, res) {  const queryParams = {    TableName: tableName,    ProjectionExpression: "id, title"  };</code></pre><pre><code>  dynamodb.scan(queryParams, (err, data) =&gt; {    if (err) {      res.json({ error: "Could not load items: " + err });    } else {      res.json(data.Items);    }  });});</code></pre>
<p>This defines a route to respond to the <strong>/items</strong> path with code to return all data in the DynamoDB table. The <code>ProjectionExpression</code> values are used to specify that it should get only the columns <code>id</code> and <code>title</code>.</p>
<p>Change the route definition on line 77 to read as <code>app.get(path + hashKeyPath + sortKeyPath, function(req, res) {</code>. This allows us to retrieve an item by its <code>id</code> following the path <strong>/items/:id</strong>. Also, change line 173 to be <code>app.delete(path + hashKeyPath + sortKeyPath, function(req, res) {</code>. This responds to HTTP DELETE method to delete an item following the path <strong>/items/:id</strong>.</p>
<p>The AWS resources have been added and updated locally, and we need to provision them in the cloud. Open the command line and run <code>amplify push</code>. You'll get a prompt if you want to continue executing the command. Enter <code>y</code> and press Enter. What this does is that it'll upload the latest versions of the resources nested stack templates to an S3 deployment bucket, and then call the AWS CloudFormation API to create / update resources in the cloud.</p>
<h3 id="building-the-frontend">Building The Frontend</h3>
<p>When the <code>amplify push</code> command completes, you'll see a file <strong>aws-exports.js</strong> in the <strong>src</strong> folder. This file contains information to the resources that were created in the cloud. Each time a resource is created or updated by running the <code>push</code> command, this file will be updated. It's created for JavaScript projects and will be used in Amplify JavaScript library. We will be using this in our React project. We will also use Bootstrap to style the page. Open <strong>public/index.html</strong> and add the following in the head:</p><pre><code>&lt;link  rel="stylesheet"  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"  integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"  crossorigin="anonymous"/&gt;&lt;script  src="https://code.jquery.com/jquery-3.3.1.slim.min.js"  integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"  crossorigin="anonymous"&gt;&lt;/script&gt;&lt;script  src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"  integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"  crossorigin="anonymous"&gt;&lt;/script&gt;&lt;script  src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"  integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"  crossorigin="anonymous"&gt;&lt;/script&gt;</code></pre>
<p>This component will display the details of an item with buttons to delete that item or go back to the list view. Open <strong>src/App.js</strong> and update it with this code:</p><pre><code>import React, { Component } from "react";import List from "./List";import Details from "./Details";</code></pre><pre><code>import Amplify, { API } from "aws-amplify";import aws_exports from "./aws-exports";import { withAuthenticator } from "aws-amplify-react";Amplify.configure(aws_exports);</code></pre><pre><code>class App extends Component {  constructor(props) {    super(props);    this.state = {      content: "",      title: "",      list: [],      item: {},      showDetails: false    };  }</code></pre><pre><code>  async componentDidMount() {    await this.fetchList();  }  handleChange = event =&gt; {    const id = event.target.id;    this.setState({ [id]: event.target.value });  };</code></pre><pre><code>  handleSubmit = async event =&gt; {    event.preventDefault();    await API.post("todosApi", "/items", {      body: {        id: Date.now().toString(),        title: this.state.title,        content: this.state.content      }    });</code></pre><pre><code>    this.setState({ content: "", title: "" });    this.fetchList();  };  async fetchList() {    const response = await API.get("todosApi", "/items");    this.setState({ list: [...response] });  }</code></pre><pre><code>  loadDetailsPage = async id =&gt; {    const response = await API.get("todosApi", "/items/" + id);    this.setState({ item: { ...response }, showDetails: true });  };</code></pre><pre><code>  loadListPage = () =&gt; {    this.setState({ showDetails: false });  };</code></pre><pre><code>  delete = async id =&gt; {    //TODO: Implement functionality  };</code></pre><pre><code>  render() {    return (      &lt;div className="container"&gt;        &lt;form onSubmit={this.handleSubmit}&gt;          &lt;legend&gt;Add&lt;/legend&gt;          &lt;div className="form-group"&gt;            &lt;label htmlFor="title"&gt;Title&lt;/label&gt;            &lt;input              type="text"              className="form-control"              id="title"              placeholder="Title"              value={this.state.title}              onChange={this.handleChange}            /&gt;          &lt;/div&gt;          &lt;div className="form-group"&gt;            &lt;label htmlFor="content"&gt;Content&lt;/label&gt;            &lt;textarea              className="form-control"              id="content"              placeholder="Content"              value={this.state.content}              onChange={this.handleChange}            /&gt;          &lt;/div&gt;          &lt;button type="submit" className="btn btn-primary"&gt;            Submit          &lt;/button&gt;        &lt;/form&gt;        &lt;hr /&gt;        {this.state.showDetails ? (          &lt;Details            item={this.state.item}            loadListPage={this.loadListPage}            delete={this.delete}          /&gt;        ) : (          &lt;List list={this.state.list} loadDetailsPage={this.loadDetailsPage} /&gt;        )}      &lt;/div&gt;    );  }}</code></pre><pre><code>export default withAuthenticator(App, true);</code></pre>
<p>We imported the Amplify library and initialized it by calling <code>Amplify.configure(aws_exports);</code>. When the component is mounted, we call <code>fetchList()</code> to retrieve items from the API.</p>
<p>This function uses the API client from the Amplify library to call the REST API. Under the hood, it utilizes <a href="https://github.com/axios/axios" rel="noopener">Axios</a> to execute the HTTP requests. It'll add necessary headers to the request so you can successfully call the REST API. You can add headers if you defined custom headers for your API.</p>
<p>For our project, we only specify the apiName and path when invoking the functions from the API client. The <code>loadDetailsPage()</code> function fetches a particular item from the database through the API. Then sets <code>item</code> state with the response and <code>showDetails</code> to true. This <code>showDetails</code> is used in the render function to toggle between showing a list of items or the details page of a selected item. The function <code>handleSubmit()</code> is called when the form is submitted. It sends the form data to the API to create a document in the database, with columns <code>id</code>, <code>title</code> and <code>content</code>, then calls <code>fetchList()</code> to update the list. I left the <code>delete()</code> function empty so you can implement it yourself. What better way to learn than to try it yourself ?.</p>
<p>This function will be called from the delete button in the <code>Details</code> component. The code you have in it should call the API to delete an item by <code>id</code> and display the list component with correct items.</p>
<p>We wrapped the App component with the <code>withAuthenticator</code> higher order component from the Amplify React library. This provides the app with complete flows for user registration, sign-in, signup, and sign out. Only signed in users can access the app since we're using this higher order component. The <code>withAuthenticator</code> component automatically detects the authentication state and updates the UI. If the user is signed in, the underlying <strong>App</strong> component is displayed, otherwise, sign-in/signup controls are displayed.</p>
<p>The second argument which was set to <code>true</code> tells it to display a sign-out button at the top of the page. Using the <code>withAuthenticator</code> component is the simplest way to add authentication flows into your app. You can also have a custom UI and use set of APIs from the Amplify library to implement sign-in and sign up flows. See the <a href="https://aws-amplify.github.io/docs/js/authentication#working-with-the-api" rel="noopener">docs</a> for more details.</p>
<p>We have all the code necessary to use the application. Open the terminal and run <code>npm start</code> to start the application. You'll need to signup and sign in to use the application.</p>
<figcaption>completed application</figcaption>
</figure>
<h3 id="wrapping-up">Wrapping Up</h3>
<p>We went through creating our backend services using the Amplify CLI. The command <code>amplify add api</code> took us through adding resources for DynamoDB, Lambda, API Gateway, and Cognito for authentication. We updated the code in <strong>backend/function/todosLambda/src/app.js</strong> to match our API requirement. We added UI components to perform CRUD operations on the app and used a higher order component from the Amplify React library to allow only authenticated users access to the application.</p>
<p>You should notice we only used a few lines of code to add authentication flows and call the API. Also creating the serverless backend services and connecting them all together was done with a command and responding to the prompts that followed. Thus showing how AWS Amplify makes development easier.</p>
<blockquote><em>Originally posted on my <a href="https://www.pmbanugo.me/blog/2019-01-14-going-serverless-with-react-and-aws-amplify-part-2-creating-and-using-serverless-services/" rel="noopener">blog</a>.</em></blockquote>
</div>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
