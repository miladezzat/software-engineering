---
card: "https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png"
tags: [Python]
description: "Addition January 2019: If you are coming back to this blog af"
author: "Milad E. Fahmy"
title: "How to manage multiple Python versions and virtual environments"
created: "2021-08-16T15:40:29+02:00"
modified: "2021-08-16T15:40:29+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-python tag-technology tag-software-development tag-programming tag-productivity ">
<header class="post-full-header">
<h1 class="post-full-title">How to manage multiple Python versions and virtual environments</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*X7729FJyghz1ADa5OGhrqg.png" alt="How to manage multiple Python versions and virtual environments">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p><em>Addition January 2019: If you are coming back to this blog after upgrading to macOS Mojave please see <a href="https://github.com/pyenv/pyenv/issues/1219#issue-363576794" rel="noopener">this github issue</a> for a solution to the common pyenv ‘zlib not available’ problem.</em></p><p>Before we start, let’s briefly go over the terms used in the title:</p><ul><li><strong>Multiple Python versions</strong>: Different installations of Python on the same machine, 2.7 and 3.4 for example.</li><li><a href="https://packaging.python.org/tutorials/installing-packages/#creating-virtual-environments" rel="noopener"><strong>Virtual environments</strong></a>: isolated independent environments that can have both a specific version of Python and of any project-specific packages installed within them, without affecting any other projects.</li></ul><p>Here we’ll look at three different tools for working with these, and when you might need each one. Let’s explore the use cases for:</p><ul><li><code>venv</code> / <code>pyvenv</code></li><li><code>pyenv</code></li><li><code>pyenv-virtualenv</code></li></ul><p>If you are using a <strong>single version</strong> of Python say version <strong>3.3+</strong>, and want to manage <strong>different virtual environments, </strong>then <code>venv</code> is all you need.</p><p>If you want to use <strong>multiple versions</strong> of Python at <strong>3.3+</strong>, <strong>with or without virtual environments</strong>, then continue to read about <code>pyenv</code>.</p><p>If you also want to work with <strong>Python 2</strong>, then <code>pyenv-virtualenv</code> is a tool to consider.</p><h3 id="venv">venv</h3><p>From Python 3.3+ the <code>venv</code> package is included. It is ideal for creating lightweight virtual environments.</p><p>Up until Python 3.6 a script called <code>pyvenv</code> was also included as a wrapper around <code>venv</code>, but this has been <a href="https://docs.python.org/3/library/venv.html" rel="noopener">deprecated</a>. It will be completely removed in Python 3.8. The exact same functionality is available when using <code>venv</code>, and any existing documentation should be updated. For anyone interested you can read <a href="https://bugs.python.org/issue25154" rel="noopener">the reasons behind depreciating <code>pyvenv</code></a>.</p><p><code>venv</code> is used to create a new environment via the terminal command:</p><pre><code class="language-bash">$ python3 -m venv directory-name-to-create</code></pre><p>activated with:</p><pre><code class="language-bash">$ source name-given/bin/activate</code></pre><p>and deactivated with simply:</p><pre><code class="language-bash">$ deactivate</code></pre><p>If you need to remove the environment completely after deactivating it, you can run:</p><pre><code class="language-bash">$ rm -r name-given</code></pre><p>By default, the environment it creates will be the current version of Python you are using. If you are writing documentation, and want the additional safety that the correct version of Python is being used by your reader you can specify the major and minor version number in the command, like so:</p><pre><code class="language-bash">$ python3.6 -m venv example-three-six</code></pre><p>If the reader is using a version other than 3.6 then the command will not be successful and will indicate in its error message. However, any patch version (for example 3.6.4) will work.</p><p>When the environment is active, any packages can be installed to it via <code><a href="https://pip.pypa.io/en/stable/installing/#installation" rel="noopener">pip</a></code> as normal. By default, the newly created environment will <strong>not</strong> include any packages already installed on the machine. As <code>pip</code> itself will not necessarily be installed on the machine. It is recommended to first upgrade <code>pip</code> to the latest version, using <code>pip install --upgrade pip</code>.</p><p>Projects will commonly have a <code>requirements.txt</code> file specifying its dependencies. This allows the shortcut command <code>pip install -r requirements.txt</code> command to quickly install all packages to the newly created virtual environment. They will only exist in the virtual environment. It will not be available when it is deactivated but will persist when it is reactivated.</p><p>If you do not need to use additional versions of Python itself, then this is all you need to create isolated, project specific, virtual environments.</p><h3 id="pyenv"><a href="https://github.com/pyenv/pyenv" rel="noopener">pyenv</a></h3><p>If you wish to use multiple versions of Python on a single machine, then <code>pyenv</code> is a commonly used tool to install and switch between versions. This is not to be confused with the previously mentioned depreciated <code>pyvenv</code> script. It does not come bundled with Python and must be installed separately.</p><p>The <code><a href="https://github.com/pyenv/pyenv" rel="noopener">pyenv</a></code><a href="https://github.com/pyenv/pyenv" rel="noopener"> documentation</a> includes a great description of <a href="https://github.com/pyenv/pyenv#how-it-works" rel="noopener">how it works</a>, so here we will look simply at how to use it.</p><p>Firstly we will need to install it. If using Mac OS X, we can do this using Homebrew, else consider <a href="https://github.com/pyenv/pyenv#installation" rel="noopener">other installation options</a>.</p><pre><code class="language-bash">$ brew update
$ brew install pyenv</code></pre><p>Next, add the following towards the bottom of your shell scripts to allow <code>pyenv</code> to automatically change versions for you:</p><pre><code class="language-bash">eval "$(pyenv init -)"</code></pre><p>To do, open your <a href="https://askubuntu.com/questions/590899/how-to-check-which-shell-am-i-using" rel="noopener">in use shell</a> script, via <code>$ ~/.zshrc</code>, <code>$ ~/.bashrc</code> or <code>$ ~/.bash_profile</code> and copy and paste the above line in.</p><p>Running <code>pyenv versions</code> will show which Python versions are currently installed, with a <code>*</code> next to the one currently in use. <code>pyenv version</code> shows this directly, and <code>python --version</code> can be used to verify this.</p><p>To install an additional version, say <code>3.4.0</code>, simply use <code>pyenv install 3.4.0</code>.</p><p><code>pyenv</code> looks in four places to decide which version of Python to use, in priority order:</p><ol><li>The <code>PYENV_VERSION</code> environment variable (if specified). You can use the <code><a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-shell" rel="noopener">pyenv shell</a></code> command to set this environment variable in your current shell session.</li><li>The application-specific <code>.python-version</code> file in the current directory (if present). You can modify the current directory's <code>.python-version</code> file with the <code><a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-local" rel="noopener">pyenv local</a></code> command.</li><li>The first <code>.python-version</code> file found (if any) by searching each parent directory, until reaching the root of your filesystem.</li><li>The global version file. You can modify this file using the <code><a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md#pyenv-global" rel="noopener">pyenv global</a></code> command. If the global version file is not present, pyenv assumes you want to use the "system" Python. (In other words, whatever version would run if pyenv weren't in your <code>PATH</code>.)</li></ol><p>When setting up a new project that is to use Python 3.6.4 then <code>pyenv local 3.6.4</code> would be ran in its root directory. This would both set the version, and create a <code>.python-version</code> file, so that other contributors’ machines would pick it up.</p><p>The <a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" rel="noopener">full description of <code>pyenv</code> commands</a> is one to bookmark.</p><h4 id="pyenv-and-venv">pyenv and venv</h4><p>When working with Python 3.3+ we now know both how to install and switch between different versions of Python, and how to create new virtual environments.</p><p>As an example, let’s say we were setting up a project that was to use Python 3.4.</p><p>First we could set our local version using <code>pyenv local 3.4.0</code>.</p><p>If we then ran <code>python3 -m venv example-project</code> a new virtual environment would be set up under <code>example-project</code>, using our locally enabled Python 3.4.0.</p><p>We activate using <code>source example-project/bin/activate</code> and can start working.</p><p>Next we could <em>optionally</em> document that a collaborator should use <code>python3.4 -m venv &lt;name&gt;</code>. This means even if a collaborator was not using pyenv the <code>python3.4</code> command would error if their Python version was not the same major and minor version (3 and 4), as we intended.</p><p>Alternatively, we could choose to simply specify that 3.4.0 was to be used, and instruct <code>python3 -m venv &lt;name&gt;</code>. If we believe that any ve<em>rsion g</em>reater than 3.4 is acceptable, then we also may choose to use <code>python3</code> over <code>python3.4</code>, as if the collaborator was using 3.6 then they would otherwise also receive an error. This is a project specific decision.</p><h3 id="pyenv-virtualenv">pyenv-virtualenv</h3><p><code>pyenv</code> can be used to install both Python 2 and 3 versions. However, as we have seen, <code>venv</code> is limited to versions of Python greater than 3.3.</p><p><code>pyenv-virtualenv</code> is a tool to create virtual environments integrated with <code>pyenv</code>, and works for all versions of Python. It is still recommended to use the official Python <code>venv</code> where possible. But if, for example, you’re creating a virtual environment based on <code>2.7.13</code>, then this compliments <code>pyenv</code>.</p><p>It also works well with <a href="https://conda.io/docs/glossary.html#anaconda-glossary" rel="noopener">Anaconda and Miniconda</a> <code>conda</code> environments if you are already using those. A tool called <code>virtualenv</code> also exists. It’s not covered here, but it’s linked at the end.</p><p>After installing <code>pyenv</code> it can next be installed using Homebrew (<a href="https://github.com/pyenv/pyenv-virtualenv" rel="noopener">or alternatives</a>) as so:</p><pre><code class="language-bash">$ brew install pyenv-virtualenv</code></pre><p>Next in your <code>.zshrc</code>, <code>.bashrc</code>, or <code>.bash_profile</code> (depending on which shell you use) add the following towards the bottom:</p><pre><code class="language-bash">eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"</code></pre><p>This allows <code>pyenv</code> to activate and deactivate environments automatically when moving directories.</p><p>To create a new virtual environment, use:</p><pre><code class="language-bash">$ pyenv virtualenv &lt;version&gt; &lt;name-to-give-it&gt;
// for example
$ pyenv virtualenv 2.7.10 my-virtual-env-2.7.10</code></pre><p>Existing environments can be listed with:</p><pre><code class="language-bash">$ pyenv virtualenvs</code></pre><p>Activated/ deactivated with:</p><pre><code class="language-bash">$ pyenv activate &lt;name&gt;
$ pyenv deactivate</code></pre><p>At the time of writing, when using <code>activate</code> the warning <code>prompt changing will be removed from future release</code> will be displayed. This is <a href="https://github.com/pyenv/pyenv-virtualenv/issues/135#issuecomment-386154344" rel="noopener">expected</a> and refers only to the <code>(env-name)</code> being displayed in your shell, not the use of the <code>activate</code> command itself.</p><p>Installing requirements works as described in <code>venv</code>. Unlike in <code>venv</code> a <code>rm -r</code> command is not needed to remove an environment, an <code><a href="https://github.com/pyenv/pyenv-virtualenv#delete-existing-virtualenv" rel="noopener">uninstall</a></code><a href="https://github.com/pyenv/pyenv-virtualenv#delete-existing-virtualenv" rel="noopener"> command </a>exists.</p><h3 id="final-thoughts">Final thoughts</h3><p>Between these three tools, we have the ability to collaborate on any project, no matter the version of Python or of the dependencies required. We also know how to document set up instructions for others to use for any project we work on.</p><p>We can also see the reasoning behind which set to use, as not all developers will require all three.</p><p>Hopefully this was helpful, and is a useful reference in combination with the documentation linked below.</p><p>Thanks for reading! ?</p><h3 id="other-things-i-ve-explored-">Other things I’ve explored:</h3><ul><li><a href="https://medium.com/codeclan/mocking-es-and-commonjs-modules-with-jest-mock-37bbb552da43" rel="noopener">Mocking ES and CommonJS modules with jest.mock()</a></li><li><a href="/news/amazon-ecs-terms-and-architecture-807d8c4960fd/">A beginner’s guide to Amazon’s Elastic Container Service</a></li></ul><h3 id="resources">Resources</h3><ul><li><a href="https://realpython.com/python-virtual-environments-a-primer/" rel="noopener">Python Virtual Environments: A Primer</a></li><li><a href="https://bugs.python.org/issue25154" rel="noopener">Depreciating <code>pyvenv</code></a></li><li><a href="https://docs.python.org/3/library/venv.html" rel="noopener">Python <code>venv</code> documentation</a></li><li><code><a href="https://www.reddit.com/r/learnpython/comments/4hsudz/pyvenv_vs_virtualenv/" rel="noopener">venv</a></code><a href="https://www.reddit.com/r/learnpython/comments/4hsudz/pyvenv_vs_virtualenv/" rel="noopener"> vs <code>virtualenv</code></a></li><li><a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe" rel="noopener">What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?</a></li><li><a href="https://pip.pypa.io/en/stable/installing/#installation" rel="noopener">Do I need to install <code>pip</code>?</a></li></ul>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
