---
card: "/images/default.jpg"
tags: [Typescript]
description: Since I'm trying to build a writing habit, well, I'm writing
author: "Milad E. Fahmy"
title: "How to Automate Your Blog Post Publishing Process with Typescript"
created: "2021-08-15T19:29:54+02:00"
modified: "2021-08-15T19:29:54+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-typescript tag-javascript tag-node tag-developer-tools tag-software-development tag-software-engineering ">
<header class="post-full-header">
<h1 class="post-full-title">How to Automate Your Blog Post Publishing Process with Typescript</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="/news/content/images/size/w300/2020/05/cover.jpg 300w,
/news/content/images/size/w600/2020/05/cover.jpg 600w,
/news/content/images/size/w1000/2020/05/cover.jpg 1000w,
/news/content/images/size/w2000/2020/05/cover.jpg 2000w">
<img onerror="this.style.display='none'" src="/news/content/images/size/w2000/2020/05/cover.jpg" alt="How to Automate Your Blog Post Publishing Process with Typescript">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>Since I'm trying to build a writing habit, well, I'm writing more and more. Even though I use publishing blogs like <a href="https://medium.com/@leandrotk_">Medium</a>, <a href="https://dev.to/teekay">dev.to</a>, and <a href="https://hashnode.com/@teekay">Hashnode</a>, I like to post my content on <a href="http://leandrotk.github.io/tk">my own blog</a> as well.</p>
<p>As I wanted to build a simple website, this blog is basically HTML and CSS with very little JavaScript. But the thing is, I needed to improve the publishing process.</p>
<p>So how does it work now?</p>
<p>I manage the blog roadmap on Notion. It looks like this:</p>
<p>It's a simple kanban type of board. I like this board because I can get all my ideas into a physical (or digital?) representation. I also use it to build a draft, polish that draft and make it better and better, and then publish it to the blog.</p>
<p>So I write my blog post using Notion. After I finish it, I copy the Notion writing and paste it into an online tool to transform markdown into HTML. And then I can use this HTML to create the actual post.</p>
<p>But this is just the body, the content for the page. I always need to create the whole HTML with the head content, body, and footer.</p>
<p>This process is tedious and boring. But good news, it can be automated. And this post is all about this automation. I want to show you the behind the scenes of this new tool I created and what I learned through this process.</p>
<h2 id="features">Features</h2>
<p>My main idea was to have a whole HTML article ready to publish. As I mentioned before, the <code>&lt;head&gt;</code> and <code>&lt;footer&gt;</code> sections don't change much. So I could use those as a "template".</p>
<p>With this template, I have the data that can change for each article I write and publish. This data is a variable in the template with this representation <code>{{ variableName }}</code>. An example:</p><pre><code class="language-html">&lt;h1&gt;{{ title }}&lt;/h1&gt;
</code></pre>
<p>Now I can use the template and replace the variables with real data â€“ specific info for each article.</p>
<p>The second part is the body, the real post. In the template, it is represented by <code>{{ article }}</code>. This variable will be replaced by the HTML generated by Notion markdown.</p>
<p>When we copy and paste notes from Notion, we get kind of a Markdown style. This project will transform this markdown into an HTML and use it as the <code>article</code> variable in the template.</p>
<p>To create the ideal template, I took a look of all variables I needed to create:</p>
<ul>
<li><code>title</code></li>
<li><code>description</code></li>
<li><code>date</code></li>
<li><code>tags</code></li>
<li><code>imageAlt</code></li>
<li><code>imageCover</code></li>
<li><code>photographerUrl</code></li>
<li><code>photographerName</code></li>
<li><code>article</code></li>
<li><code>keywords</code></li>
</ul>
<p>With these variables, I created the <a href="https://github.com/leandrotk/publisher/blob/master/examples/template.html">template</a>.</p>
<p>To pass some of this information to build the HTML, I created a <code>json</code> file as the article config: <code>article.config.json</code>. There I have something like this:</p><pre><code class="language-json">{
"title": "React Hooks, Context API, and Pokemons",
"description": "Understanding how hooks and the context api work",
"date": "2020-04-21",
"tags": [
"javascript",
"react"
],
"imageAlt": "The Ash from Pokemon",
"photographerUrl": "&lt;https://www.instagram.com/kazuh.illust&gt;",
"photographerName": "kazuh.yasiro",
"articleFile": "article.md",
"keywords": "javascript,react"
}
</code></pre>
<p>The first step was that the project should know how to open and read the template and the article config. I use this data to populate the template.</p>
<p>Template first:</p><pre><code class="language-typescript">const templateContent: string = await getTemplateContent();
</code></pre>
<p>So we basically need to implement the <code>getTemplateContent</code> function.</p><pre><code class="language-typescript">import fs, { promises } from 'fs';
import { resolve } from 'path';
const { readFile } = promises;
const getTemplateContent = async (): Promise&lt;string&gt; =&gt; {
const contentTemplatePath = resolve(__dirname, '../examples/template.html');
return await readFile(contentTemplatePath, 'utf8');
};
</code></pre>
<p>The <code>resolve</code> with <code>__dirname</code> will get the absolute path to the directory from the source file that is running. And then go to the <code>examples/template.html</code> file. The <code>readFile</code> will asynchronously read and return the content from the template path.</p>
<p>Now we have the template content. And we need to do the same thing for the article config.</p><pre><code class="language-typescript">const getArticleConfig = async (): Promise&lt;ArticleConfig&gt; =&gt; {
const articleConfigPath = resolve(__dirname, '../examples/article.config.json');
const articleConfigContent = await readFile(articleConfigPath, 'utf8');
return JSON.parse(articleConfigContent);
};
</code></pre>
<p>Two different things happen here:</p>
<ul>
<li>As the <code>article.config.json</code> has a json format, we need to transform this json string into a JavaScript object after reading the file</li>
<li>The return of the article config content will be an <code>ArticleConfig</code> as I defined in the function return type. Let's build it.</li>
</ul><pre><code class="language-typescript">type ArticleConfig = {
title: string;
description: string;
date: string;
tags: string[];
imageCover: string;
imageAlt: string;
photographerUrl: string;
photographerName: string;
articleFile: string;
keywords: string;
};
</code></pre>
<p>When we get this content, we also use this new type.</p><pre><code class="language-typescript">const articleConfig: ArticleConfig = await getArticleConfig();
</code></pre>
<p>Now we can use the <code>replace</code> method to fill the config data in the template content. Just to illustrate the idea, it would look like this:</p><pre><code class="language-typescript">templateContent.replace('title', articleConfig.title)
</code></pre>
<p>But some variables appear more than one time in the template. Regex to the rescue. With this:</p><pre><code class="language-typescript">new RegExp('\\{\\{(?:\\\\s+)?(title)(?:\\\\s+)?\\}\\}', 'g');
</code></pre>
<p>... I get all the strings that match <code>{{ title }}</code>. So I can build a function that receives a parameter to be found and use it in the title place.</p><pre><code class="language-typescript">const getPattern = (find: string): RegExp =&gt;
new RegExp('\\{\\{(?:\\\\s+)?(' + find + ')(?:\\\\s+)?\\}\\}', 'g');
</code></pre>
<p>Now we can replace all matches. An example for the title variable:</p><pre><code class="language-typescript">templateContent.replace(getPattern('title'), articleConfig.title)
</code></pre>
<p>But we don't want to replace only the title variable, but all variables from the article config. Replace all!</p><pre><code class="language-typescript">const buildArticle = (templateContent: string) =&gt; ({
with: (articleConfig: ArticleAttributes) =&gt;
templateContent
.replace(getPattern('title'), articleConfig.title)
.replace(getPattern('description'), articleConfig.description)
.replace(getPattern('date'), articleConfig.date)
.replace(getPattern('tags'), articleConfig.articleTags)
.replace(getPattern('imageCover'), articleConfig.imageCover)
.replace(getPattern('imageAlt'), articleConfig.imageAlt)
.replace(getPattern('photographerUrl'), articleConfig.photographerUrl)
.replace(getPattern('photographerName'), articleConfig.photographerName)
.replace(getPattern('article'), articleConfig.articleBody)
.replace(getPattern('keywords'), articleConfig.keywords)
});
</code></pre>
<p>Now I replace all! We use it like this:</p><pre><code class="language-typescript">const article: string = buildArticle(templateContent).with(articleConfig);
</code></pre>
<p>But we are missing two parts here:</p>
<ul>
<li><code>tags</code></li>
<li><code>article</code></li>
</ul>
<p>In the config json file, the <code>tags</code> is a list. So, for the list:</p><pre><code class="language-json">['javascript', 'react'];
</code></pre>
<p>The final HTML would be:</p><pre><code class="language-html">&lt;a class="tag-link" href="../../../tags/javascript.html"&gt;javascript&lt;/a&gt;
&lt;a class="tag-link" href="../../../tags/react.html"&gt;react&lt;/a&gt;
</code></pre>
<p>So I created another template: <code>tag_template.html</code> with the <code>{{ tag }}</code> variable. We just need to map the <code>tags</code> list and create each HTML tag template.</p><pre><code class="language-typescript">const getArticleTags = async ({ tags }: { tags: string[] }): Promise&lt;string&gt; =&gt; {
const tagTemplatePath = resolve(__dirname, '../examples/tag_template.html');
const tagContent = await readFile(tagTemplatePath, 'utf8');
return tags.map(buildTag(tagContent)).join('');
};
</code></pre>
<p>Here we:</p>
<ul>
<li>get the tag template path</li>
<li>get the tag template content</li>
<li>map through the <code>tags</code> and build the final tag HTML based on the tag template</li>
</ul>
<p>The <code>buildTag</code> is a function that returns another function.</p><pre><code class="language-typescript">const buildTag = (tagContent: string) =&gt; (tag: string): string =&gt;
tagContent.replace(getPattern('tag'), tag);
</code></pre>
<p>It receives the <code>tagContent</code> - it is the tag template content - and returns a function that receives a tag and builds the final tag HTML. And now we call it to get the article tags.</p><pre><code class="language-typescript">const articleTags: string = await getArticleTags(articleConfig);
</code></pre>
<p>About the article now. It looks like this:</p><pre><code class="language-typescript">const getArticleBody = async ({ articleFile }: { articleFile: string }): Promise&lt;string&gt; =&gt; {
const articleMarkdownPath = resolve(__dirname, `../examples/${articleFile}`);
const articleMarkdown = await readFile(articleMarkdownPath, 'utf8');
return fromMarkdownToHTML(articleMarkdown);
};
</code></pre>
<p>It receives the <code>articleFile</code>, we try to get the path, read the file, and get the markdown content. Then pass this content to <code>fromMarkdownToHTML</code> function to transform the markdown into HTML.</p>
<p>For this part I'm using an external library called <code>showdown</code>. It handles every little corner case to transform markdown into HTML.</p><pre><code class="language-typescript">import showdown from 'showdown';
const fromMarkdownToHTML = (articleMarkdown: string): string =&gt; {
const converter = new showdown.Converter()
return converter.makeHtml(articleMarkdown);
};
</code></pre>
<p>And now I have the tags and the article HTML:</p><pre><code class="language-typescript">const templateContent: string = await getTemplateContent();
const articleConfig: ArticleConfig = await getArticleConfig();
const articleTags: string = await getArticleTags(articleConfig);
const articleBody: string = await getArticleBody(articleConfig);
const article: string = buildArticle(templateContent).with({
...articleConfig,
articleTags,
articleBody
});
</code></pre>
<p>I missed one more thing! Before, I expected that I always needed to add the image cover path into the article config file. Something like this:</p><pre><code class="language-typescript">{
"imageCover": "an-image.png",
}
</code></pre>
<p>But we could assume that the image name will be <code>cover</code>. The challenge was the extension. It can be <code>.png</code>, <code>.jpg</code>, <code>.jpeg</code>, or <code>.gif</code>.</p>
<p>So I built a function to get the right image extension. The idea is to search for the image in the folder. If it exists in the folder, return the extension.</p>
<p>I started with the "existing" part.</p><pre><code class="language-typescript">fs.existsSync(`${folder}/${fileName}.${extension}`);
</code></pre>
<p>Here I'm using the <code>existsSync</code> function to find the file. If it exists in the folder, it returns true. Otherwise, false.</p>
<p>I added this code into a function:</p><pre><code class="language-typescript">const existsFile = (folder: string, fileName: string) =&gt; (extension: string): boolean =&gt;
fs.existsSync(`${folder}/${fileName}.${extension}`);
</code></pre>
<p>Why did I do it this way?</p>
<p>Using this function, I need to pass the <code>folder</code>, the <code>filename</code>, and the <code>extension</code>. The <code>folder</code> and the <code>filename</code> are always the same. The difference is the <code>extension</code>.</p>
<p>So I could build a function using curry. That way, I can build different functions for the same <code>folder</code> and <code>filename</code>. Like this:</p><pre><code class="language-typescript">const hasFileWithExtension = existsFile(examplesFolder, imageName);
hasFileWithExtension('jpeg'); // true or false
hasFileWithExtension('jpg'); // true or false
hasFileWithExtension('png'); // true or false
hasFileWithExtension('gif'); // true or false
</code></pre>
<p>The whole function would look like this:</p><pre><code class="language-typescript">const getImageExtension = (): string =&gt; {
const examplesFolder: string = resolve(__dirname, `../examples`);
const imageName: string = 'cover';
const hasFileWithExtension = existsFile(examplesFolder, imageName);
if (hasFileWithExtension('jpeg')) {
return 'jpeg';
}
if (hasFileWithExtension('jpg')) {
return 'jpg';
}
if (hasFileWithExtension('png')) {
return 'png';
}
return 'gif';
};
</code></pre>
<p>But I didn't like this hardcoded string to represent the image extension. <code>enum</code> is really cool!</p><pre><code class="language-typescript">enum ImageExtension {
JPEG = 'jpeg',
JPG = 'jpg',
PNG = 'png',
GIF = 'gif'
};
</code></pre>
<p>And the function now using our new enum <code>ImageExtension</code>:</p><pre><code class="language-typescript">const getImageExtension = (): string =&gt; {
const examplesFolder: string = resolve(__dirname, `../examples`);
const imageName: string = 'cover';
const hasFileWithExtension = existsFile(examplesFolder, imageName);
if (hasFileWithExtension(ImageExtension.JPEG)) {
return ImageExtension.JPEG;
}
if (hasFileWithExtension(ImageExtension.JPG)) {
return ImageExtension.JPG;
}
if (hasFileWithExtension(ImageExtension.PNG)) {
return ImageExtension.PNG;
}
return ImageExtension.GIF;
};
</code></pre>
<p>Now I have all the data to fill the template. Great!</p>
<p>As the HTML is done, I want to create the real HTML file with this data. I basically need to get the correct path, the HTML, and use the <code>writeFile</code> function to create this file.</p>
<p>To get the path, I needed to understand the pattern of my blog. It organizes the folder with the year, the month, the title, and the file is named <code>index.html</code>.</p>
<p>An example would be:</p><pre><code class="language-bash">2020/04/publisher-a-tooling-to-blog-post-publishing/index.html
</code></pre>
<p>At first, I thought about adding this data to the article config file. So every time I need to update this attribute from the article config to get the correct path.</p>
<p>But another interesting idea was to infer the path by some data we already have in the article config file. We have the <code>date</code> (e.g. <code>"2020-04-21"</code>) and the <code>title</code> (e.g. <code>"Publisher: tooling to automate blog post publishing"</code>).</p>
<p>From the date, I can get the year and the month. From the title, I can generate the article folder. The <code>index.html</code> file is always constant.</p>
<p>The string would look like this:</p><pre><code class="language-typescript">`${year}/${month}/${slugifiedTitle}`
</code></pre>
<p>For the date, it is really simple. I can split by <code>-</code> and destructure:</p><pre><code class="language-typescript">const [year, month]: string[] = date.split('-');
</code></pre>
<p>For the <code>slugifiedTitle</code>, I built a function:</p><pre><code class="language-typescript">const slugify = (title: string): string =&gt;
title
.trim()
.toLowerCase()
.replace(/[^\\w\\s]/gi, '')
.replace(/[\\s]/g, '-');
</code></pre>
<p>It removes the white spaces from the beginning and the end of the string. Then downcase the string. Then remove all special characters (keep only word and whitespace characters). And finally, replace all whitespaces with a <code>-</code>.</p>
<p>The whole function looks like this:</p><pre><code class="language-typescript">const buildNewArticleFolderPath = ({ title, date }: { title: string, date: string }): string =&gt; {
const [year, month]: string[] = date.split('-');
const slugifiedTitle: string = slugify(title);
return resolve(__dirname, `../../${year}/${month}/${slugifiedTitle}`);
};
</code></pre>
<p>This function tries to get the article folder. It doesn't generate the new file. This is why I didn't add the <code>/index.html</code> to the end of the final string.</p>
<p>Why did it do that? Because, before writing the new file, we always need to create the folder. I used <code>mkdir</code> with this folder path to create it.</p><pre><code class="language-typescript">const newArticleFolderPath: string = buildNewArticleFolderPath(articleConfig);
await mkdir(newArticleFolderPath, { recursive: true });
</code></pre>
<p>And now I could use the folder the create the new article file in it.</p><pre><code class="language-typescript">const newArticlePath: string = `${newArticleFolderPath}/index.html`;
await writeFile(newArticlePath, article);
</code></pre>
<p>One thing we are missing here: as I added the image cover in the article config folder, I needed to copy it and paste it into the right place.</p>
<p>For the <code>2020/04/publisher-a-tooling-to-blog-post-publishing/index.html</code> example, the image cover would be in the assets folder:</p><pre><code class="language-bash">2020/04/publisher-a-tooling-to-blog-post-publishing/assets/cover.png
</code></pre>
<p>To do this, I need two things:</p>
<ul>
<li>create a new <code>assets</code> folder with <code>mkdir</code></li>
<li>copy the image file and paste it into the new folder with <code>copyFile</code></li>
</ul>
<p>To create the new folder, I just need the folder path. To copy and paste the image file, I need the current image path and the article image path.</p>
<p>For the folder, as I have the <code>newArticleFolderPath</code>, I just need to concatenate this path to the assets folder.</p><pre><code class="language-typescript">const assetsFolder: string = `${newArticleFolderPath}/assets`;
</code></pre>
<p>For the current image path, I have the <code>imageCoverFileName</code> with the correct extension. I just need to get the image cover path:</p><pre><code class="language-typescript">const imageCoverExamplePath: string = resolve(__dirname, `../examples/${imageCoverFileName}`);
</code></pre>
<p>To get the future image path, I need to concatenate the image cover path and the image file name:</p><pre><code class="language-typescript">const imageCoverPath: string = `${assetsFolder}/${imageCoverFileName}`;
</code></pre>
<p>With all these data, I can create the new folder:</p><pre><code class="language-typescript">await mkdir(assetsFolder, { recursive: true });
</code></pre>
<p>And copy and paste the image cover file:</p><pre><code class="language-typescript">await copyFile(imageCoverExamplePath, imageCoverPath);
</code></pre>
<p>As I was implementing this <code>paths</code> part, I saw I could group them all into a function <code>buildPaths</code>.</p><pre><code class="language-typescript">const buildPaths = (newArticleFolderPath: string): ArticlePaths =&gt; {
const imageExtension: string = getImageExtension();
const imageCoverFileName: string = `cover.${imageExtension}`;
const newArticlePath: string = `${newArticleFolderPath}/index.html`;
const imageCoverExamplePath: string = resolve(__dirname, `../examples/${imageCoverFileName}`);
const assetsFolder: string = `${newArticleFolderPath}/assets`;
const imageCoverPath: string = `${assetsFolder}/${imageCoverFileName}`;
return {
newArticlePath,
imageCoverExamplePath,
imageCoverPath,
assetsFolder,
imageCoverFileName
};
};
</code></pre>
<p>I also created the <code>ArticlePaths</code> type:</p><pre><code class="language-typescript">type ArticlePaths = {
newArticlePath: string;
imageCoverExamplePath: string;
imageCoverPath: string;
assetsFolder: string;
imageCoverFileName: string;
};
</code></pre>
<p>And I could use the function to get all the path data I needed:</p><pre><code class="language-typescript">const {
newArticlePath,
imageCoverExamplePath,
imageCoverPath,
assetsFolder,
imageCoverFileName
}: ArticlePaths = buildPaths(newArticleFolderPath);
</code></pre>
<p>The last part of the algorithm now! I wanted to quickly validate the created post. So what if I could open the created post in a browser tab? That would be amazing!</p>
<p>So I did it:</p><pre><code class="language-typescript">await open(newArticlePath);
</code></pre>
<p>Here I'm using the <code>open</code> library to simulate the terminal open command.</p>
<p>And that was it!</p>
<h2 id="what-i-learned">What I learned</h2>
<p>This project was a lot of fun! I learned some cool things through this process. I want to list them here:</p>
<ul>
<li>As I'm <a href="https://leandrotk.github.io/tk/2020/04/typescript-learnings/index.html">learning Typescript</a>, I wanted to quickly validate the code I was writing. So I configured <code>nodemon</code> to compile and run the code on every file save. It is cool to make the development process so dynamic.</li>
<li>I tried to use the new node <code>fs</code>'s <code>promises</code>: <code>readFile</code>, <code>mkdir</code>, <code>writeFile</code>, and <code>copyFile</code>. It is on <code>Stability: 2</code>.</li>
<li>I did a lot of <a href="https://leandrotk.github.io/tk/2020/03/closure-currying-and-cool-abstractions/index.html">currying</a> for some functions to make them reusable.</li>
<li>Enums and <a href="https://leandrotk.github.io/tk/2020/04/typescript-learnings-002-type-system/index.html">Types</a> are good ways to make the state consistent in Typescript, but also make a good representation and documentation of all the project's data. <a href="https://leandrotk.github.io/tk/2020/04/thinking-in-data-contracts/index.html">Data contracts</a> are a really nice thing.</li>
<li>The tooling mindset. This is one of the things I really love about programming. Build toolings to automate repetitive tasks and make life easier.</li>
</ul>
<p>I hope it was good reading! Keep learning and coding!</p>
<p>This post was originally published <a href="https://leandrotk.github.io/tk/2020/04/publisher-a-tooling-to-automate-the-process-to-publish-my-blog-posts/index.html">on my blog</a>.</p>
<p>My <a href="https://twitter.com/leandrotk_">Twitter</a> and <a href="https://github.com/leandrotk/">Github</a>.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/leandrotk/publisher">Publisher Tooling: source code</a></li>
<li><a href="https://leandrotk.github.io/tk/2020/04/thinking-in-data-contracts/index.html">Thinking in data contracts</a></li>
<li><a href="https://leandrotk.github.io/tk/2020/04/typescript-learnings/index.html">Typescript Learnings</a></li>
<li><a href="https://leandrotk.github.io/tk/2020/03/closure-currying-and-cool-abstractions/index.html">Closures, Currying, and Cool Abstractions</a></li>
<li><a href="https://alterclass.io/?ref=5ec57f513c1321001703dcd2">Learn React by building an App</a></li>
</ul>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
