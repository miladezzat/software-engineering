---
card: "https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ"
tags: [JavaScript]
description: "by Changhui Xu"
author: "Milad E. Fahmy"
title: "How to Compose Canvas Animations in TypeScript"
created: "2021-08-16T11:39:51+02:00"
modified: "2021-08-16T11:39:51+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-javascript tag-typescript tag-animation tag-front-end-development tag-technology ">
<header class="post-full-header">
<h1 class="post-full-title">How to Compose Canvas Animations in TypeScript</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ 300w,
https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ 600w,
https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ 1000w,
https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/0*pJTkQHXgr6hKmpXZ" alt="How to Compose Canvas Animations in TypeScript">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content medium-migrated-article">
private readonly vertices: Point[];
private readonly controlPoints: Point[][];
constructor(
public readonly centerPoint: Point,
public readonly radius: number,
public readonly tipSkewRatio: number,
public readonly angleSpan: number,
public readonly color: string
) {
this.vertices = this.getVertices();
this.controlPoints = this.getControlPoints(this.vertices);
}
draw(context: CanvasRenderingContext2D) {
// draw curves using vertices and controlPoints
}
private getVertices() {
// compute vertices' coordinates
}
private getControlPoints(vertices: Point[]): Point[][] {
// compute control points' coordinates
}
}</code></pre><p>The auxiliary <code>Point</code> class in <code>Petal</code> is defined as follows. Coordinates are using integers (via <code>Math.floor()</code>) to save some computing power.</p><pre><code class="language-ts">export class Point {
constructor(public readonly x = 0, public readonly y = 0) {
this.x = Math.floor(this.x);
this.y = Math.floor(this.y);
}
}</code></pre><p>The representation of a <strong>Flower Center</strong> can be parameterized by its center point, circle radius, and color. Thus, the skeleton of the <code>FlowerCenter</code> class is as follows:</p><pre><code class="language-ts">export class FlowerCenter {
constructor(
private readonly centerPoint: Point,
private readonly centerRadius: number,
private readonly centerColor: string
) {}
draw(context: CanvasRenderingContext2D) {
// draw the circle
}
}</code></pre><p>Since we have a petal and a flower center, we are ready to move forward to draw a flower, which contains a center circle and several petals with the same shape.</p><p>From an Object Oriented perspective, <code>Flower</code> can be constructed as <code>new Flower(center: FlowerCenter, petals: Petal[])</code> or as <code>new Flower(center: FlowerCenter, numberOfPetals: number, petal: Petal)</code>. I use the second way, because no array is needed for this scenario.</p><p>In the constructor, you can add some validations to ensure data integrity. For example, throw an error if <code>center.centerPoint</code> doesnâ€™t match <code>petal.centerPoint</code>.</p><pre><code class="language-ts">export class Flower {
constructor(
private readonly flowerCenter: FlowerCenter,
private readonly numberOfPetals: number,
private petal: Petal
) {}
draw(context: CanvasRenderingContext2D) {
this.drawPetals(context);
this.flowerCenter.draw(context);
}
private drawPetals(context: CanvasRenderingContext2D) {
context.save();
const cx = this.petal.centerPoint.x;
const cy = this.petal.centerPoint.y;
const rotateAngle = (2 * Math.PI) / this.numberOfPetals;
for (let i = 0; i &lt; this.numberOfPetals; i++) {
context.translate(cx, cy);
context.rotate(rotateAngle);
context.translate(-cx, -cy);
this.petal.draw(context);
}
context.restore();
}
constructor(){}
getFlowerAt(point: Point): Flower {
... // randomization
}
...  // other helper methods
}</code></pre><p>Then we create a <code>BloomingFlowers</code> class to store an array of flowers generated by <code>FlowerRandomizationService</code>.</p><p>To make an animation, we define a method <code>increasePetalRadius()</code> in <code>Flower</code> class to update the flower objects. Then by calling <code>window.requestAnimationFrame(() =&gt; this.animateFlowers(</code>)); <code>in BloomingFlow</code>ers class, we schedule a redraw on canvas at each frame. And flowers are updated v<code>ia flower.increasePetalRadius</code>(); during each redraw. The code snippet below shows a bare minimum animation class.</p><pre><code class="language-ts">export class BloomingFlowers {
private readonly context: CanvasRenderingContext2D;
private readonly canvasW: number;
private readonly canvasH: number;
private readonly flowers: Flower[] = [];
constructor(
private readonly canvas: HTMLCanvasElement,
private readonly nFlowers: number = 30
) {
this.context = this.canvas.getContext('2d');
this.canvasWidth = this.canvas.width;
this.canvasHeight = this.canvas.height;
this.getFlowers();
}
bloom() {
window.requestAnimationFrame(() =&gt; this.animateFlowers());
}
private animateFlowers() {
this.context.clearRect(0, 0, this.canvasW, this.canvasH);
this.flowers.forEach(flower =&gt; {
flower.increasePetalRadius();
flower.draw(this.context);
});
window.requestAnimationFrame(() =&gt; this.animateFlowers());
}
private getFlowers() {
for (let i = 0; i &lt; this.nFlowers; i++) {
const flower = ... // get a randomized flower
this.flowers.push(flower);
}
}
private readonly context: CanvasRenderingContext2D;
private readonly canvasW: number;
private readonly canvasH: number;
private flowers: Flower[] = [];
private readonly randomizationService =
new FlowerRandomizationService();
private ctrlIsPressed = false;
private mousePosition = new Point(-100, -100);
constructor(private readonly canvas: HTMLCanvasElement) {
this.context = this.canvas.getContext('2d');
this.canvasW = this.canvas.width;
this.canvasH = this.canvas.height;
this.addInteractions();
}
clearCanvas() {
this.flowers = [];
this.context.clearRect(0, 0, this.canvasW, this.canvasH);
}
private animateFlowers() {
if (this.flowers.every(f =&gt; f.stopChanging)) {
return;
}
this.context.clearRect(0, 0, this.canvasW, this.canvasH);
this.flowers.forEach(flower =&gt; {
flower.increasePetalRadiusWithLimit();
flower.draw(this.context);
});
window.requestAnimationFrame(() =&gt; this.animateFlowers());
}
private addInteractions() {
this.canvas.addEventListener('click', e =&gt; {
if (this.ctrlIsPressed) {
this.clearCanvas();
return;
}
this.calculateMouseRelativePositionInCanvas(e);
const flower = this.randomizationService
.getFlowerAt(this.mousePosition);
this.flowers.push(flower);
this.animateFlowers();
});
window.addEventListener('keydown', (e: KeyboardEvent) =&gt; {
if (e.which === 17 || e.keyCode === 17) {
this.ctrlIsPressed = true;
}
});
window.addEventListener('keyup', () =&gt; {
this.ctrlIsPressed = false;
});
}
private calculateMouseRelativePositionInCanvas(e: MouseEvent) {
this.mousePosition = new Point(
e.clientX +
(document.documentElement.scrollLeft ||
document.body.scrollLeft) -
this.canvas.offsetLeft,
e.clientY +
(document.documentElement.scrollTop ||
document.body.scrollTop) -
this.canvas.offsetTop
);
}
</div>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
