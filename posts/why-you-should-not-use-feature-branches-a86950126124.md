---
card: "https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png"
tags: [Git]
description: "Isn’t the git history in the picture above nice to work with?"
author: "Milad E. Fahmy"
title: "Why you should not use (long-lived) feature branches"
created: "2021-08-16T10:07:08+02:00"
modified: "2021-08-16T10:07:08+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-git tag-web-development tag-continuous-integration tag-devops tag-software-development ">
<header class="post-full-header">
<h1 class="post-full-title">Why you should not use (long-lived) feature branches</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*iBt55gRsIwnNX3D_9uJVTA.png" alt="Why you should not use (long-lived) feature branches">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>Isn’t the git history in the picture above nice to work with? There are probably many problems in that repository, but one of them is most definitely the use of feature branches. Let’s see how such a bad thing became such a common practice.</p><p>When git came to replace SVN it brought a ridiculously easy way to create branches.</p><blockquote><em>The idea behind git is to ease your pain as a developer working on many features at a time. Not to push branches around and tie them to the whole development process of your team.</em></blockquote><p>When JIRA and others came along, companies like Atlassian started to promote the “git workflow” and feature branches heavily. The “Create branch” button appeared in your JIRA tasks and boom, feature branches were born! Atlassian tells you all about it in <a href="https://www.atlassian.com/agile/software-development/branching" rel="noopener">this interesting article</a>. I like Atlassian’s products very much. Keep in mind though that their core business is tasks management for development teams. The more tangled it gets with branches and code, the better.</p><p>Ten years later, feature branching is a standard in most teams, when in fact it doesn’t bring any benefits to your bottom line: release quality software to production. Not only do feature branches provide zero benefits, they actually slow you down!</p><p>For the sake of clarity: this article assumes a feature branch will carry the whole feature you are developing and is a so-called ‘long-lived’ feature branch that will last 1 week or more. It’s not a “no branches at all” mantra.</p><blockquote>“The feature is ready. I just need to merge it!”</blockquote><p>I’ve heard this way too many times. This falls in the same category as statements like “It compiles so it works”.</p><p>In practice, the merging leads to the “unpredictable release syndrome”. It can be quick or evince a major incompatibility, which needs fixing in a rush. You are either lucky or … your timeline shifts and code quality drops.</p><blockquote><em>The real problem with feature branches is the reason they are so popular: they pump a developer’s pride and make you feel good about your work.</em></blockquote><p>Your feature branch is your own perfect garden and you can keep it clean and shiny. But it is separated from the other gardens of your team. The more you work apart, the harder it is to reconcile.</p><p>I am a big fan of the management book “The goal”. It shows how over time people tend to use metrics that highlight local optimums of a process because it is more comfortable. They just lose focus on their global bottom line. The book is about a production plant, but the analogy stands. Your feature branch is a local optimum with high-quality code. It may also be so far off the main branch that it is of no use for the upcoming release.</p><h3 id="trunk-based-development-to-the-rescue">Trunk based development to the rescue</h3><p>As the name suggests, in trunk based development the whole team pushes continuously to the main branch or use very short-lived (1 or 2 days max) branches.</p><p>Here is a <a href="https://trunkbaseddevelopment.com/" rel="noopener">detailed description</a> of the idea. I have no affiliation with the linked website. It is just a great overview of the concept.</p><p>When you push your work to the main branch on every push, the amount of code to merge is way smaller and it becomes trivial. There is a far greater benefit though: you and your team can spot problems before they become painful. It might be that your refactoring clashes with another feature. Or you are drifting off from the project conventions or architecture patterns. This is the real value of the process. As I preach in any place I find myself in:</p><blockquote><em>It is teamwork that makes or breaks software projects.</em></blockquote><p>Working days on code that will never get to the release on time is the biggest failure there is for a team.</p><p>Another upside of pushing to the main branch is that your changes will run live in some environment. It is always good to deploy and battle test your code, even in progress, in some real deploy.</p><h4 id="objection-1-wip-in-the-main-branch-">Objection 1: “WIP” in the main branch!?!</h4><p>If you read so far you are probably thinking “This is crazy, how can I push my half done work to the main branch when it will probably get deployed to production very soon!?!”.</p><p>Here are the common objections one might have and a tentative solution.</p><h4 id="objection-2-i-can-t-expose-unfinished-work-">Objection 2: I can’t expose unfinished work!</h4><p>Use feature toggles. They can be environment variables or whatever suits you best to turn on and off your work in progress. Make it defensive of course so your half-finished code does not get active in production by mistake.</p><p>Your whole team will love this: you can activate the code on any environment at any time to see how it looks or performs. Testers can prepare to test early on. Product owners can comment on your work along the way. It is all live and easy to access for everyone! If your work is just started, this provides little value. But evil lies in the details. It usually takes half the time to get to 90% completion and another half to finish the remaining 10%. Sharing your work in this state of 90% completion is always a good idea ;)</p><p>Another thing that comes for free: you can turn the feature off in production if a problem arises after deployment. After a few days or weeks, once the feature runs smoothly, just remove the toggle from the code.</p><h4 id="objection-3-what-if-i-break-the-main-branch-for-everyone">Objection 3: What if I break the main branch for everyone?</h4><p>It is 2019. If you don’t have a continuous integration setup that builds and runs tests automatically … then set it up yesterday. If you break anything you’ll be notified before it becomes a problem for the whole team.</p><p>In pure Trunk Based Development the feedback will come after the merge and has to be fixed right away. If you are using short-lived branches the merge should be blocked by your CI tool. A short-lived branch is something that should last 1 or 2 days max and carry a consistent piece of code that contributes to the feature you are building.</p><h4 id="objection-4-there-must-be-a-code-review-before-we-merge-">Objection 4: There must be a code review before we merge!</h4><p>That’s a valid point. Code reviews do not need feature branches though. If the code review culture is strong in your team then it can very well be done on the commit to the main branch. The reviewer would stop by the author of the commit and discuss what needs to be fixed. The fix would come in another commit. Even better, have the code review together before pushing the commit in the first place.</p><p>If it is not acceptable to your team to have post-merge code reviews (because let’s face it it is less handy as tools do not really support that), use short-lived branches and apply your code review process there.</p><h4 id="objection-5-i-want-to-see-the-code-that-is-related-to-a-task">Objection 5: <strong>I want to see the code that is related to a task</strong></h4><p>If you have a given branch per feature then it is easy to track code back to your agile board. You can navigate from a task to the branch that implements it.</p><p>It sounds cool, while in reality, this is useless! How many people can you have on an agile team? Up to 5? Up to 10? How hard is it to ask the person running a task or story what commits you need to look at to deep dive into the implementation?</p><p>After some time, once tasks are completed for a long time, linking tasks to code does not make sense anymore. Developers rely on git blame to know the who, on code content to know the how, and hopefully on comments to know the why.</p><h3 id="the-cherry-on-the-cake-opt-in-on-new-features">The cherry on the cake: opt-in on new features</h3><p>It became common to see major UI features or updates released using an “opt-in” approach. Github, Bitbucket, Gmail, … to name a few.</p><p>The concept is that major changes are introduced using a banner “Hey we have this new feature / improved dashboard / whatever. Click here to try it out”. You can opt-in, and usually opt out as easily if you don’t like the change. This is a very good adoption testing strategy as it involves the end users in the decision process. If people opt-in and stay there it means you are improving the experience. If they opt in and out … you know you’ve changed things for the worse.</p><p>If you are using feature toggles from the start, exposing these on a per-user basis at run time becomes very easy.</p><h3 id="conclusion">Conclusion</h3><p>If you never thought of trunk based development as an alternative to the feature branch mantra, I hope this article gave you some perspective and that you will to try it out.</p><p>The best thing is that to get there you’ll need to setup or improve every other aspect of your process (CI, automated tests, code reviews). This is a good path to take. We obviously recommend Fire CI as a <a href="https://fire.ci/" rel="noopener">continuous integration tool</a>.</p><p>Remember that your bottom line is to put quality software in front of your users. The closer your code is from the production environment at all times, the better.</p><p>Now, although the article is very much “trunk based development” oriented, note that it might not be a valid approach for your team.</p><p>If your team is highly distributed, in different time zones, has a lot of junior developers who need to learn the project conventions and architecture, using longer-lived feature branches might work better.</p><p>The main idea in this article is:</p><p><strong>The faster you integrate the different pieces together and check that things are working, the safer you are to have a working product at the end.</strong></p><p>A good common ground is to use short-lived branches that last 1 or 2 days max and merge them to the main branch. This way you can humanly control what gets in and still integrate code fast.</p><p><strong>Thanks for reading! If you find the article useful please hit the clap button below. It would mean a lot to me and it helps other people see the story!</strong></p><p><em>Originally published at <a href="https://fire.ci/blog/why-you-should-not-use-feature-branches/" rel="noopener">fire.ci</a> on March 30, 2019.</em></p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
