---
card: "https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU"
tags: [Docker]
description: "Do you sometimes feel you’re a beautiful princess turned by a"
author: "Milad E. Fahmy"
title: "How to set up Docker and Windows Subsystem for Linux: A Love Story. ?"
created: "2021-08-16T14:38:24+02:00"
modified: "2021-08-16T14:38:24+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-docker tag-life-lessons tag-technology tag-productivity tag-programming ">
<header class="post-full-header">
<h1 class="post-full-title">How to set up Docker and Windows Subsystem for Linux: A Love Story. ?</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU 300w,
https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU 600w,
https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU 1000w,
https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/0*nKPs7NaTWQnJpNSU" alt="How to set up Docker and Windows Subsystem for Linux: A Love Story. ?">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>Do you sometimes feel you’re a beautiful princess turned by an evil wizard into a frog? Like you don’t belong? I do. I’m a UNIX guy scared to leave the cozy command line. My terminal is my castle. But there are times when I’m forced to use Microsoft Windows and I have learned a few tricks on how to cope with that.</p><p>For my daily terminal needs, I have installed Windows Subsystem for Linux along with the Ubuntu distribution. On top of that, I have a Linuxbrew installation which helps me manage any third-party apps I may need. This combination works surprisingly well! I have a nifty symbolic link to access all my “external” (that is Windows-hosted) data: <code>ln -s ~/external /mnt/c/Users/DoomHammer</code> and most of the needs are fulfilled this way. That is, unless I need to use Docker.</p><h3 id="what-s-so-special-about-docker">What’s so Special About Docker?</h3><p>Unlike most applications I typically use every day, Docker is a system application. This means its rooted deep into the system and requires an actual daemon to run on the host machine. And by the host machine, I mean native Microsoft Windows in that case.</p><p>Does it mean you can’t use Docker from inside WSL? Not necessarily. But you need to flex your muscles a bit more to get there. First of all, you need to install Docker for Windows. There’s Docker Enterprise Editions for Windows Server 2016 (and up) and there’s Community Edition for Windows 10 Professional or Enterprise. And I was stuck at Windows 10 Home Edition.</p><h3 id="getting-docker-on-windows-10-home">Getting Docker on Windows 10 Home</h3><p>It seems getting Docker to run on Windows 10 Home Edition is a bit more tricky. Docker Community Edition requires Hyper-V support which is unavailable on Home Edition. This means I needed to dig out <a href="https://docs.docker.com/toolbox/toolbox_install_windows/" rel="noopener">Docker Toolbox</a>, an older distribution which relied on Docker Machine and Virtualbox. But after installation, Virtualbox greeted me with a prompt saying it’s impossible to run virtualization.</p><p>As it turned out, I had the virtualization setting turned off in BIOS. Apparently for security reasons. I turned it on, opened Virtualbox again and… the same. This made me worried a bit. After a bit of Web crawling, I found the advice to check <code>systeminfo</code>. Well, it clearly showed *some* hypervisor is running. But not Virtualbox and most certainly not Hyper-V, right?</p><p>To my surprise, it was Hyper-V all along. It seems Home Edition lacks the userland tools to actually <strong>use</strong> Hyper-V but it doesn’t mean that the Hypervisor itself wasn’t running. Thankfully, turning it off was just a <code>bcdedit /set hypervisorlaunchtype off</code> away. After I rebooted the machine Virtualbox was eager to work. Cool, score for me!</p><h3 id="docker-and-wsl-best-friends-forever">Docker and WSL, Best Friends Forever?</h3><p>Having a working Virtualbox I opened Docker Quickstart Terminal. On the first run, it creates a Docker Machine (that’s why it needs Virtualbox) to act as a host for all the containers. I typed <code>docker run --rm hello-world</code> and watched the progress bar as Docker downloaded the appropriate image for me. Another score!</p><p>Now, instead of the <code>cmd.exe</code> I’d like to use Docker from the comfort of my WSL. How do I do that? Fortunately, WSL has access to native Windows binaries. This means I can run <code>docker-machine.exe ls</code> to see the machine created by Docker Toolbox. It should be right there named simply <code>default</code>. If the state is anything else than “Running” you can start it with <code>docker-machine.exe start</code>. Each time you want to run Docher Machine remember that unlike in <code>cmd.exe</code> the extension (<code>.exe</code>) is mandatory.</p><p>Normally we would call <code>docker-machine.exe env</code> to set the environment variables.</p><p>Unfortunately it outputs the variables in a format understood by <code>cmd.exe</code>, not by any Bourne-compatible shell like bash or zsh. But we can change this behavior with <code>docker-machine.exe env --shell sh</code>.</p><p>Hmm, almost there. But there’s one thing left hanging. The certificate path is written as a Windows path. How to translate into something WSL understands? <a href="https://github.com/MicrosoftDocs/WSL/releases/tag/17046" rel="noopener">For some time now</a>, WSL features a nice utility called <code>wslpath</code>. Thanks to this tool we can call <code>export DOCKER_CERT_PATH=$(wslpath $DOCKER_CERT_PATH)</code> and we're <strong>almost</strong> ready.</p><p>We still need the userland tools. So, using your favorite package manager install both the Docker Engine and Docker Compose. For me this means <code>brew install docker docker-compose</code>. After that a <code>docker run --rm hello-world</code> should yield exactly the same results as it did in a Docker Toolbox terminal. Congratulations!</p><h3 id="is-that-all">Is That All?</h3><p>No, of course not. You may quickly notice that bind-mount does not work correctly. That’s because the Docker daemon expects proper Windows paths, and WSL paths sadly cannot be translated automatically. But there are a few hacks we can use to improve the situation.</p><p>Now, which hack you need depends of the version you are running. Hitting Win+R and typing <code>winver</code> you should see a dialog that says something around the lines:</p><blockquote>Microsoft Windows<br>Version 18.03 (OS Build 17133.73)</blockquote><p>If it’s actually 18.03 or newer you can edit <code>/etc/wsl.conf</code> to look like this:</p><pre><code>[automount]
root = /
options = "metadata"</code></pre><p>It means WSL would mount the C: drive under <code>/c/</code> instead of the usual <code>/mnt/c</code>. Why is this important? Well, it’s important because that’s what Docker daemon expects of Windows paths. By the way: after you save the file, you need to re-login for the changes to take effect.</p><p><strong>Warning</strong>! If you happen to use <a href="https://github.com/goreliu/wsl-terminal" rel="noopener">wsl-terminal</a> this change will break it. Use the next method in such a case.</p><p>Another approach if you don’t want to re-login or if you’re stuck with an older version is to bind mount one mountpoint to the other like this:</p><pre><code>sudo mkdir /c
sudo mount --bind /mnt/c /c</code></pre><p>Quicker, but only available as long as you are logged in. You’ll have to repeat this the next time you reboot your machine or add it to your shell runtime configuration (like <code>~/.bashrc</code> or <code>~/.zshrc</code>). That’s because <code>/etc/fstab</code> does not work as expected on WSL.</p><p>As you may have noticed, this means you are now able to run Docker with mounts, but only if your volumes are within the Windows filesystem. Since command line <code>docker</code> expects absolute paths this should be no big deal, but with Docker Compose you have to be extra careful. It allows to use relative paths and this way everything that starts with <code>./</code> won’t work.</p><p>If you absolutely insist on mounting WSL’s filesystem with Docker you can try replacing all those <code>./</code> with <code>/c/Users/$USERNAME/AppData/Local/lxss</code> along with the project’s <code>$PWD</code>. In this case <code>$USERNAME</code> does not mean your WSL username, but you Windows one.</p><p>I thought it’d be clever to write a wrapper around Docker Compose to make it change the working directory into this <code>lxss</code> but unfortunately WSL has no rights to access it. And rightfully so, I think!</p><h3 id="one-last-wall">One Last Wall</h3><p>We can run Docker and we can bind data directories. What else can we want? Maybe working port-forwarding? Unlike with Native solutions, using Docker through Docker Machine requires to call every service on <code>$(docker-machine ip):$PORT</code> instead of the usual <code>localhost:$PORT</code>. There is a way around it, albeit not a very elegant one:</p><pre><code class="language-sh">#!/bin/sh
# This script uses Virtualbox Port Forwarding to make all Docker services
# available on Windows host under `localhost`
VBXMGMT=/c/Program\ Files/Oracle/VirtualBox/VBoxManage.exe
# List all the running container ids
docker ps -q | while read -r i; do
# List all the ports bound by this container&lt;Paste&gt;
for port in $(docker port "$i" | cut -d'-' -f1); do
port_num=$(echo "${port}" | cut -d'/' -f1)
port_type=$(echo "${port}" | cut -d'/' -f2)
echo "Create rule natpf1 for ${port_type} port ${port_num}"
"$VBXMGMT" controlvm "default" natpf1 "${port_type}-port${port_num},${port_type},,${port_num},,${port_num}"
done
done</code></pre><p>I believe you can write a wrapper around Docker to perform this dance each time you run a new container. I admit I haven’t tested it that way, as most of the time I’m satisfied with forwarding a single port.</p><p>I hope this will make your work with Docker on WSL much more pleasant. It certainly did this for me!</p><h3 id="bibliography">Bibliography</h3><p>I wouldn’t have written this article if it wasn’t for the fine people who shared their knowledge. Every time I stumbled over some obstacle I could search for the existing solutions. Below, a list of articles and posts that helped me write this guide:</p><p><a href="https://nickjanetakis.com/blog/setting-up-docker-for-windows-and-wsl-to-work-flawlessly" rel="noopener"><strong>Setting Up Docker for Windows and WSL to Work Flawlessly</strong></a><br><a href="https://nickjanetakis.com/blog/setting-up-docker-for-windows-and-wsl-to-work-flawlessly" rel="noopener"><em>With a couple of tweaks the WSL (Windows Subsystem for Linux, also known as Bash for Windows) can be used with Docker…</em>nickjanetakis.com</a><a href="https://superuser.com/a/1110976" rel="noopener"><strong>How to access linux/Ubuntu files from Windows 10 WSL?</strong></a><br><a href="https://superuser.com/a/1110976" rel="noopener"><em>Super User is a question and answer site for computer enthusiasts and power users. Join them; it only takes a minute…</em>superuser.com</a><a href="https://stackoverflow.com/questions/32174560/port-forwarding-in-docker-machine" rel="noopener"><strong>Port forwarding in docker-machine?</strong></a><br><a href="https://stackoverflow.com/questions/32174560/port-forwarding-in-docker-machine" rel="noopener"><em>You can still access the VBoxmanage.exe command from the VirtualBox used by docker machine: VBoxManage controlvm…</em>stackoverflow.com</a></p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
