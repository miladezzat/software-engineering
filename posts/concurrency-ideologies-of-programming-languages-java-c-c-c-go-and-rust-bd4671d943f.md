---
card: "https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg"
tags: [Programming]
description: "Once, there was a good old time when clock speed doubled ever"
author: "Milad E. Fahmy"
title: "Draconian, free, or nanny state: Concurrency ideologies in Java, C#, C, C++, Go, and Rust"
created: "2021-08-16T11:41:17+02:00"
modified: "2021-08-16T11:41:17+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-programming tag-software-development tag-programming-languages tag-concurrency tag-technology ">
<header class="post-full-header">
<h1 class="post-full-title">Draconian, free, or nanny state: Concurrency ideologies in Java, C#, C, C++, Go, and Rust</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg 300w,
https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg 600w,
https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg 1000w,
https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*9cwOzRARFWi3osKGXCZsSw.jpeg" alt="Draconian, free, or nanny state: Concurrency ideologies in Java, C#, C, C++, Go, and Rust">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<h3 id="why-we-need-concurrency">Why we need Concurrency</h3><p>Once, there was a good old time when clock speed doubled every 18 months. This phenomenon was called Moore’s law. If a programmer’s program was not fast enough, they could wait, and soon computers would catch up.</p><p>It was too good to last, and it did not. CPU designers still kept up with Moore’s Law by adding more cores to computers.</p><p>This created a problem for programmers. In the new world, our programs will run twice as fast every 18 months, but only if it is a parallel program that uses more core.</p><p>Hence, for a programmer, the ability to write code in parallel environments is a critical skill. This post explores how different programming languages support parallel and concurrent programs.</p><h3 id="classical-concurrency-primitives">Classical Concurrency Primitives</h3><p>Almost all operating systems support multiple threads of execution. Concurrent programmers, however, need help to solve two other problems.</p><ul><li>Shared Data — Shared data, if accessed concurrently, may produce unexpected results.</li><li>Signaling between threads — Some use cases need programmers to control the execution order of threads. Other examples are wanting threads to wait at a certain point, wait for another thread, run in specific order, never overtake another thread, and have no more than N threads in the critical region.</li></ul><p>Programming languages provide different primitives to aid programmers in controlling the above situations. Let’s take a look at those classical Primitives:</p><ol><li>Locks (also called Mutex) — ensure that only one thread is executed in selected regions of the code</li><li>Monitors — they do the same, but slightly better than locks, as they force you to unlock</li><li>(Counting) Semaphores — powerful abstractions that can support a wide range of coordination scenarios</li><li>Wait-and-notify — does the same, but is weaker then Semaphores. The programmer has to handle missed notify triggers before the wait</li><li>Conditional Variables — let a thread sleep and awaken when a given condition occurs</li><li>Channels and buffers with conditional waiting — listen to and collect messages if there is no thread to receive (with optionally bounded buffers)</li><li>Non-blocking data structures (such as Nonblocking queue, Atomic counters) — These are clever data structures that allow access from many threads without using locks or a minimal amount of locks.</li></ol><p>These primitives overlap on what they can do. Any programming language can get the full power of concurrency with just a few. For example, locks and semaphores can do every concurrency use case you can imagine.</p><h3 id="language-support-for-primitives">Language Support for Primitives</h3><p>The concurrency primitive is not selected just for its power. Different primitives have different programming models. This necessitates different ways of thinking about the problem. Different programming languages have selected different subsets that best match their language model. The choice depends on the designer’s tastes as well as the language’s philosophy.</p><p>Let’s explore a few of those choices.</p><h4 id="java-and-c-">Java and C#</h4><p>Java and C# have chosen not to choose at all. Both support all primitives.</p><p>Java first started by only supporting monitors (the <strong>synchronized</strong> keyword) and wait-and-notify. It was a nightmare to send signals across threads. I remember spending hours on “missed signal” and still getting it wrong.</p><p>Soon Java designers realized their mistake. They added a concurrency package which has everything including non-blocking data structures.</p><p>The only primitive not supported in its pure forms is channels and buffers. However, if you want them, it is easy to mimic channels with queues and buffers. Although your implementation would never match Go or Erlang in performance.</p><p>C#, coming late, learned from Java. It also has pretty much everything. C# also has a few higher level helper constructs that Java does not. This solves common problems such as barriers. For more detail, check out the <a href="https://msdn.microsoft.com/en-us/library/system.threading%28v=vs.110%29.aspx" rel="noopener">C# Threading package</a>.</p><h3 id="c-and-c-">C and C++</h3><p>C initially depended on operating system calls to do multithreading. Back then code was not portable. Instead, third-party concurrency libraries provided this functionality. Unfortunately, since the language does not pin down the API, there were many libraries available.</p><p>Since C and C++ are languages closest to the OS, cutting edge thread research is often done with these two languages. For example, a quick search revealed <a href="https://en.wikipedia.org/wiki/List_of_C%2B%2B_multi-threading_libraries" rel="noopener">22 C++ concurrency</a> libraries and<a href="https://stackoverflow.com/questions/5613646/threading-in-c-cross-platform" rel="noopener"> 6 C concurrency libraries</a>. There is no lack of power.</p><p>These libraries provide wide-range and cutting-edge technology. However, due to the diversity of APIs, there are not many programmers who are as proficient with a given API.</p><h3 id="erlang">Erlang</h3><p>Erlang was designed from scratch for concurrency. Erlang gives full control of interactions between threads to the programmer. Programmers do all communications via message passing. This is the source of Erlang’s legendary performance on multi-core computers.</p><p>However, there is a price to pay. Erlang does not support sharing state between threads. This is no mistake. Shared state triggers synchronization between threads, which will not be under the programmer’s direct control. Such synchronization often reduces performance.</p><p>Consequently, the Erlang programming experience is foreign to most programmers. Its fully functional nature does not help either.</p><p>The primary concurrency construct in Erlang is channels. It inbuilt buffers and support for waiting on a condition. For example, you can ask a channel to wait until it receives a message that satisfies a given condition. Each process has one channel, and it can only receive from that channel.</p><p>In practice, since Erlang is a functional programming language, shared memory locks are rarely needed. Unfortunately, such use cases exist. Since Erlang does not have shared memory, you can’t lock something. However, you can create a process to represent a lock. You acquire and release a lock by sending messages to the lock just like in a distributed system.</p><p>Unless you are a programming language expert who knows functional programming intimately, resulting programs often tend to be complicated and hard to debug. By choosing Erlang, programmers tradeoff concurrency support and familiarity.</p><p>If you’d like to know more, read these articles: <a href="https://queue.acm.org/detail.cfm?id=1454463" rel="noopener">Erlang for Concurrent Programming</a> and<a href="http://learnyousomeerlang.com/the-hitchhikers-guide-to-concurrency" rel="noopener"> The Hitchhiker’s Guide to Concurrency</a>.</p><h3 id="go">Go</h3><p>Go is much like Erlang. <a href="https://www.golang-book.com/books/intro/10" rel="noopener">Its primary mode of concurrency is through Channel and buffers, and it supports conditional waiting</a>. Its core philosophy for concurrency is: <a href="https://golang.org/doc/effective_go.html#sharing" rel="noopener">Do not communicate by sharing memory; instead, share memory by communicating</a>.</p><p>There is, however, a fundamental difference. Go trusts you to do the right thing. Go let you share data between threads and supports both <a href="https://gobyexample.com/mutexes" rel="noopener">mutexes</a> and <a href="https://github.com/golang/sync/blob/master/semaphore/semaphore.go" rel="noopener">semaphores</a>. Further, they have relaxed the Erlang restriction that each channel is permanently assigned to a thread. You can create a channel and pass it around.</p><p>In summary, Go wants us to program concurrency like Erlang. However, while Erlang enforces it, Go trusts you to do the right thing. If Erlang is draconian, Go is a free state.</p><h3 id="rust">Rust</h3><p>Rust is also much like Erlang and Go. It communicates using channels that have buffers and conditional waiting. Just like Go, it relaxes the restrictions of Erlang <a href="https://doc.rust-lang.org/book/second-edition/ch16-03-shared-state.html" rel="noopener">by letting you do shared memory</a>, by supporting atomic reference counting and locks, and by letting you pass channels from thread to thread.</p><p>However, Rust goes one step further. While Go trusts you to do the right thing, Rust assigns a mentor who sits with you and complains if you try to do the wrong thing. Rust’s mentor is the compiler. It does sophisticated analysis to determine the ownership of values that are passed around threads and provides compilation errors if there are potential problems.</p><p>Following is a quote from the Rust docs.</p><blockquote>The ownership rules play a vital role in message sending because they help us write safe, concurrent code. Preventing errors in concurrent programming is the advantage we get by making the trade-off of having to think about ownership throughout our Rust programs. — <a href="https://doc.rust-lang.org/book/second-edition/ch16-02-message-passing.html" rel="noopener">Message passing with ownership of values</a>.</blockquote><p>If Erlang is draconian and Go is a free state, then Rust is a nanny state.</p><p>Debugging concurrent programs is a nightmare. On a bad day, it can take days. So I appreciate what Rust is trying to do via compiler level analysis.</p><p>However, if you are not experienced in concurrency and try to write a concurrent Rust program, it will annoy you. Whatever you do, it will complain about concurrency in cryptic language. When you change, it will say something else, and then again. Until you understand concurrency in detail, it will not be easy.</p><p>In contrast, Go gives false security to the programmer, who thinks that their task, often falsely, is done. They might pay for it later. However, they will pay only if the code ever gets to production, if the user ever comes across the scenario, and if that error is detected. That is a lot of “if”s. Although it is unfair, the odds are that the programmer might get away with it. Humans are not that good with <a href="https://www.psychologytoday.com/us/blog/your-emotional-meter/201712/the-benefits-delaying-gratification" rel="noopener">delayed gratification</a> and the <a href="http://www.oxfordaspiremuseums.org/long-view-how-futures-thinking-can-help-us-plan-and-innovate" rel="noopener">long view</a> anyway. So programmers often prefer Go over Rust.</p><p>Rust is trying to help, but it is rarely help that gets appreciated. No one likes a nanny state.</p><blockquote><em>Rust is not as popular as it deserves to be, because too many short-sighted devs are annoyed by Rust’s strictness, instead of appreciating the immense power they gain from that strictness.” — <a href="https://www.reddit.com/r/rust/comments/8x1myq/concurrency_ideologies_of_programming_languages/e21xwqy/" rel="noopener">rjc2013</a></em></blockquote><p>For more information, please read <a href="https://news.ycombinator.com/item?id=7851274." rel="noopener">How the concurrency primitives in Rust compare to the ones in Go</a>?</p><h3 id="conclusion">Conclusion</h3><p>When it comes to concurrency ideologies, programming languages give you a choice: a free state (Go), a draconian state (Erlang), or a nanny state (Rust).</p><p>If you’d like to learn more, I would recommend two resources.</p><p>First, read the <a href="http://greenteapress.com/wp/semaphores/" rel="noopener">Little book of semaphores</a>, which teaches you everything about locks and semaphores.</p><p>Second, if you want to understand channels and the Erlang model, <a href="http://mpitutorial.com/" rel="noopener">check out MPI</a>. You might think MPI is a dead language. It is not. Most scientific simulations are done to this day with MPI. Weather is predicted by it, vehicles are designed with it, and drugs are discovered with it. Science literally progresses using MPI. MPI uses concurrency in ways we could never imagine. For a taste of it, please check out <a href="http://www.mathcs.emory.edu/~cheung/Courses/355/Syllabus/92-MPI/group-comm.html" rel="noopener">MPI Communication Primitives</a>.</p><p>If you follow the above two suggestions, you will walk away with an appreciation of the complexity and the possibilities of concurrency. It is a topic that takes a lifetime to master.</p><p>I hope this article was useful. I studied these languages while thinking about a concurrency model for Ballerina. Ballerina is a new programming language designed for distributed environments to write microservices and to integrate APIs. It includes new concurrency features, such as adaptive locking. It analyzes the code and tries to hold locks for as short a time as possible. Check it out at <a href="https://ballerina.io." rel="noopener">https://ballerina.io.</a></p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
