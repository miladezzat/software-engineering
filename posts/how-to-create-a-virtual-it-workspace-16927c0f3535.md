---
card: "https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg"
tags: [Linux]
description: "This article is based on a chapter from my free online book, "
author: "Milad E. Fahmy"
title: "How to create a virtual IT workspace"
created: "2021-08-16T14:40:58+02:00"
modified: "2021-08-16T14:40:58+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-linux tag-technology tag-programming tag-life-lessons tag-web-development ">
<header class="post-full-header">
<h1 class="post-full-title">How to create a virtual IT workspace</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg 300w,
https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg 600w,
https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg 1000w,
https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*2p-yQIIofCUjFNfQ3KII1A.jpeg" alt="How to create a virtual IT workspace">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
“Ubuntu-16.04-template” {c00d3b2b-6c77–4919–85e2–6f6f28c63d56}
“centos-7-template” {e2613f6d-1d0d-489c-8d9f-21a36b2ed6e7}
“Kali-Linux-template” {b7a3aea2–0cfb-4763–9ca9–096f587b2b20}
“website-project” {2387a5ab-a65e-4a1d-8e2c-25ee81bc7203}
“Ubuntu-16-lxd” {62bb89f8–7b45–4df6-a8ea-3d4265dfcc2f}</code></pre><p><code>vboxmanage clonevm</code> will pull off the same kind of clone action I described above using the GUI. Here, I'm making a clone of the Kali-Linux-template VM, naming the copy "newkali":</p><pre><code>$ vboxmanage clonevm Kali-Linux-template --name newkali</code></pre><p>That will work nicely as long as I only need to use the new VM here on my local computer. But suppose I wanted other members of my team to have an exact copy of that VM — perhaps so they could test something I’ve been working on. For that, I’ll need to convert the VM to some standardized file format. Here’s how I might export a local VM to a file using the Open Virtualization Format (.OVA):</p><pre><code>$ vboxmanage export website-project -o website.ova
0%…10%…20%…30%…40%…50%…60%…70%…80%…90%…100%
Successfully exported 1 machine(s).</code></pre><p>Next, you’ll need to copy the .OVA file to your colleague’s computer. Bear in mind that the file won’t, by any standard, be considered small and dainty. If you haven’t got network bandwidth to spare for a multiple GB transfer, then consider moving it via a USB device.</p><p>Once the transfer is complete, all that’s left is, from the remote computer, to import the VM into that machine’s VirtualBox. The command is simple:</p><pre><code>$ vboxmanage import docker.ova</code></pre><p>Confirm that the import operation worked using <code>list vms</code> and try launching the VM from the desktop.</p><pre><code>$ vboxmanage list vms“docker-project” {30ec7f7d-912b-40a9–8cc1-f9283f4edc61}</code></pre><p>If you don’t need any fancy remote access, you can also share a VM from the GUI. With the machine you want to share highlighted, click on the File menu and then on Export Appliance.</p><p>Coming next: the wondrous and mysterious world of LXC.</p><p>VirtualBox is great for running operations requiring kernel access, for when you need GUI desktop sessions, or for testing niche market edge-case operating systems. But if you’re on a Linux machine and you just need fast access to a clean Linux environment and you’re not looking for any special release version, then you’d be hard pressed to beat Linux Containers.</p><p>Just how fast are LXC containers? You’ll see for yourself soon enough. But, because they skillfully share many system resources with both the host and other containers, they work like full-bore standalone servers while using only minimal storage space and memory.</p><blockquote>NOTE: We’re going to discuss the classic LXC, but you should be aware that there’s a similar environment from the same developers called LXD. LXD is essentially a newer implementation of the LXC interface. It still uses LXC under the hood, but provides a different set of commands that extend functionality to remote network administration.</blockquote><h3 id="getting-started-with-lxc">Getting started with LXC</h3><p>Install LXC on your Ubuntu workstation? Piece of cake:</p><pre><code>sudo apt updatesudo apt install lxc</code></pre><p>That’s it. We’re ready to get down to business. The basic LXC skill set is actually quite simple. I’m going to show you the three or four commands you’ll need to make it all work, and then an insider tip that, once you understand how LXC organizes itself, will just blow you away.</p><h4 id="launch-your-first-container">Launch your first container</h4><p>Why not dive right in and create your first container? The value given to <code>-n</code>sets the name I want to use for the container, and <code>-t</code> tells LXC to build the container from the Ubuntu template.</p><pre><code>$ sudo lxc-create -n mycont -t ubuntu</code></pre><p>If you decided to create, say, a CentOS container, then you should make a note of the final few lines of the output, as it contains information about the password you should use to log in:</p><pre><code>$ sudo lxc-create -n centos_lxc -t centos
[...]
The temporary root password is stored in:
'/var/lib/lxc/centos_lxc/tmp_root_pass'</code></pre><p>You will log in using the user name “root” and the password contained in that file. If, on the other hand, your container used the Ubuntu template, then you’ll use “ubuntu” for both your user name and password. Naturally, if you plan to use this container for anything serious, you’ll want to change that password right away.</p><p>Use <code>lxc-ls --fancy</code> to check the status of your container:</p><pre><code>$ sudo lxc-ls --fancy
NAME    STATE   AUTOSTART GROUPS IPV4    IPV6
mycont  STOPPED 0   -      -       -</code></pre><p>Well, it exists, but apparently it needs starting. As before, the <code>-n</code> specifies by name the container you want to start. <code>-d</code> stands for "detach" - meaning you <em>don't</em> want to be automatically dropped into an interactive session as the container starts.</p><pre><code>$ sudo lxc-start -d -n mycont</code></pre><p>Listing your containers should now display something like this:</p><pre><code>$ sudo lxc-ls --fancy
NAME    STATE   AUTOSTART GROUPS IPV4  IPV6
mycont  RUNNING 0   -      10.0.3.142  -</code></pre><p>This time, the container is running and has been given an IP address. You could use this address to log in using a secure shell session.</p><pre><code>$ ssh ubuntu@10.0.3.142</code></pre><p>Alternatively, you can launch a root shell session within a running container using <code>lxc-attach</code>.</p><pre><code>$ sudo lxc-attach -n mycontroot@mycont:/#</code></pre><p>When you’re done playing with your new container, you can either run <code>exit</code>to log out leaving the container running:</p><pre><code>root@mycont:/# exitexit</code></pre><p>…or shut the container down using <code>shutdown -h now</code>.</p><p>But before you do that, let’s find out just how blazing fast LXC containers are. The <code>-h</code>flag I added to <code>shutdown</code> just before stands for "halt". If I would use <code>r</code>instead, rather than shutting down for good, the container would reboot. So let's run reboot and then try to log in again right away to see how long it takes for the container to get back up on its feet.</p><pre><code>root@mycont:/# shutdown -r nowsudo lxc-attach -n mycont</code></pre><p>How did that go? I’ll bet that, by the time you managed to retype the <code>lxc-attach</code>command, mycont was awake and ready for action. But did you know that hitting the up arrow key in Bash will populate the command line with the previous command. Using that would make it even faster to request a login. In my case, there was no noticeable delay. The container shut down and fully rebooted in <em>less than 2 seconds</em>!</p><blockquote>Linux containers are also really easy on system resources. Unlike my experience with VirtualBox VMs — where running three concurrently already starts to seriously impact my 8GB host workstation performance — I can launch all kinds of LXC containers without suffering any slowdown.</blockquote><h4 id="fixing-a-cold-lxc-container">Fixing a cold LXC container</h4><p>Now what about that insider tip I promised you? Well, back in a terminal on the host machine (as opposed to the container), you’ll need to open an administrator shell using <code>sudo su</code>. From here on in - until you type <code>exit</code> - you will be <code>sudo</code> full-time.</p><pre><code>$ sudo su[sudo] password for username:#</code></pre><p>Now change directory to <code>/var/lib/lxc/</code> and list the contents. You should see a directory with the name of your container. If you've got other containers on the system, they'll have their own directories as well.</p><pre><code># cd /var/lib/lxc
# ls
mycont</code></pre><p>Move to your container directory and list its contents. There will be a file called “config” and a directory called “rootfs”. The “fs” stands for “file system”.</p><pre><code># cd mycont
# ls
config rootfs</code></pre><p>It’s the rootfs directory that I really want you to see right now:</p><pre><code># cd rootfs
# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr</code></pre><p>All those subdirectories that fill rootfs…do they look familiar to you? Of course! They’re all part of the Linux Filesystem Hierarchy Standard. This is essentially the container’s root (/) directory…but within the <em>host’s</em> file system. As long as you have admin permissions on the host, you’ll be able to browse through those directories and edit any files you want — even when the container isn’t running.</p><p>There are all kinds of things you’ll be able to do with this access, but here’s one that can quite possibly save your (professional) life one day. Suppose you do something dumb on a container and lock yourself out, there’s now nothing stopping you from navigating through the file system, fixing the configuration file that you messed up, and getting back to work. Go ahead: tell me that’s not cool.</p><p>Need to mount a single process on a stopped container? Just <a href="https://hackernoon.com/chroot-the-magical-healing-powers-of-the-original-linux-virtualization-tool-9aa4c3928711" rel="noopener">use chroot the way I describe in this article</a>.</p><p>But it gets better. It’s true that the <a href="https://hackernoon.com/too-many-choices-how-to-pick-the-right-tool-to-manage-your-docker-clusters-b5b3061b84b7" rel="noopener">Docker ecosystem</a> has gained many layers of features and sophistication since the technology moved out from under LXC’s shadow some years ago. Under the hood, however, it’s still built on top of a basic structural paradigm that will be instantly recognizable to anyone familiar with LXC.</p><p>Which means that, should you be inclined to test drive the fastest-growing virtualization technology of the decade, you’ve already got skin in the game.</p><h3 id="writing-code-on-a-remote-server">Writing code on a remote server</h3><p>Now that you’ve got those virtual environment thingies all figured out, what can you do with ‘em? Well, it’s obvious that such setups are perfect for playing with system tools and architectures.</p><p>Suppose you’re not into system stuff, but you would like a safe place to build applications. What do I mean by “safe?” I’m talking about an environment where you can freely install libraries and dependency packages without having to worry about destabilizing your personal work computer.</p><p>But there are limits to how far that can take you. There’s a lot going on beneath the surface of IDEs like Eclipse or Visual Studio, and people become very attached to their convenience. But expecting to be able to easily run all those layers of complexity over a remote connection — and especially on a headless remote server — is perhaps a bit ambitious.</p><p>But still, wouldn’t it be nice to work on the IDE on your laptop and have the code saved, compiled, and run remotely…say, on a hosted VM or cloud instance? That way you could build your applications on the servers where they’ll actually be run without having to risk the stability of your own workstation.</p><p>It can be done. Generally, the trick is to get your IDE to ride on top of a Secure Shell (SSH) session. For details, search the internet for something like “eclipse edit java code on remote server”.</p><p><em>This article is based on a chapter from my free online book, <a href="https://learntech.bootstrap-it.com/" rel="noopener">Solving for Technology: how to quickly learn valuable new skills in a madly changing technology world</a>. There’s lots more where that came from at my Bootstrap IT site, including links to my book, <a href="https://www.manning.com/books/linux-in-action?a_aid=bootstrap-it&amp;a_bid=4ca15fc9" rel="noopener">Linux in Action</a>, and a hybrid course called <a href="https://www.manning.com/livevideo/linux-in-motion?a_aid=bootstrap-it&amp;a_bid=0c56986f&amp;chan=motion1" rel="noopener">Linux in Motion</a> that’s made up of more than two hours of video and around 40% of the text of Linux in Action.</em></p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
