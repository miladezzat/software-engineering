---
card: "https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png"
tags: [JavaScript]
description: "The React Handbook follows the 80/20 rule: learn in 20% of th"
author: "Milad E. Fahmy"
title: "The React Handbook"
created: "2021-08-16T11:33:55+02:00"
modified: "2021-08-16T11:33:55+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-javascript tag-react tag-tech tag-programming tag-technology ">
<header class="post-full-header">
<h1 class="post-full-title">The React Handbook</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*m5aPLXkrWJs7xKsfYViJEg.png" alt="The React Handbook">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>The React Handbook follows the 80/20 rule: learn in 20% of the time the 80% of a topic.</p><p>I find this approach gives a well-rounded overview. This book does not try to cover everything under the sun related to React, but it should give you the basic building blocks to get out there and become a great React developer. If you think some specific topic should be included, tell me. You can reach me on Twitter <a href="https://twitter.com/flaviocopes" rel="noopener">@flaviocopes</a>.</p><p>I hope the contents of this book will help you achieve what you want: <strong>learn the basics of React</strong>.</p><p>You can get this ebook in PDF, ePub and Mobi format at <a href="https://reacthandbook.com" rel="noopener">reacthandbook.com</a></p><h3 id="book-index">Book Index</h3><h4 id="table-of-contents">Table of Contents</h4><p><a href="/news/the-react-handbook-b71c27b0a795/#an-introduction-to-the-react-view-library">An introduction to React</a><br><a href="/news/the-react-handbook-b71c27b0a795/#how-to-use-create-react-app">How to use create-react-app</a></p><p><strong><strong>SECTION 1</strong></strong>: MODERN JAVASCRIPT CORE CONCEPTS YOU NEED TO KNOW TO USE REACT</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#variables">Variables</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#arrow-functions">Arrow functions</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#rest-and-spread">Rest and spread</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#object-and-array-destructuring">Object and array destructuring</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#template-literals">Template literals</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#classes">Classes</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#callbacks">Callbacks</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#promises">Promises</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#async-await">Async/Await</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#es-modules">ES Modules</a></li></ul><p><strong><strong>SECTION 2</strong></strong>: REACT CONCEPTS</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#single-page-applications">Single Page Applications</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#declarative">Declarative</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#immutability">Immutability</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#purity">Purity</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#composition">Composition</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#the-virtual-dom">The Virtual DOM</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#unidirectional-data-flow">Unidirectional Data Flow</a></li></ul><p><strong><strong>SECTION 3</strong></strong>: IN-DEPTH REACT</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#jsx">JSX</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#components">Components</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#state">State</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#props">Props</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#presentational-vs-container-components">Presentational vs container components</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#state-vs-props">State vs props</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#proptypes">PropTypes</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#react-fragment">React Fragment</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#events">Events</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#lifecycle-events">Lifecycle Events</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#forms-in-react">Forms in React</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#reference-a-dom-element">Reference a DOM element</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#server-side-rendering">Server side rendering</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#the-context-api">The Context API</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#higher-order-components">Higher order components</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#render-props">Render Props</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#hooks">Hooks</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#code-splitting">Code splitting</a></li></ul><p><strong><strong>SECTION 4</strong></strong>: PRACTICAL EXAMPLES</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#build-a-simple-counter">Build a simple counter</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#fetch-and-display-github-users-information-via-api">Fetch and display GitHub users information via API</a></li></ul><p><strong><strong>SECTION 5</strong></strong>: STYLING</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#css-in-react">CSS in React</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#sass-in-react">SASS in React</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#styled-components">Styled Components</a></li></ul><p><strong><strong>SECTION 6</strong></strong>: TOOLING</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#babel">Babel</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#webpack">Webpack</a></li></ul><p><strong><strong>SECTION 7</strong></strong>: TESTING</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#jest">Jest</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#testing-react-components">Testing React components</a></li></ul><p><strong><strong>SECTION 8</strong></strong>: THE REACT ECOSYSTEM</p><ul><li><a href="/news/the-react-handbook-b71c27b0a795/#react-router">React Router</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#redux">Redux</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#next-js">Next.js</a></li><li><a href="/news/the-react-handbook-b71c27b0a795/#gatsby">Gatsby</a></li></ul><p><a href="/news/the-react-handbook-b71c27b0a795/#wrapping-up">Wrapping up</a></p><h3 id="an-introduction-to-the-react-view-library">An introduction to the React view library</h3><h4 id="what-is-react">What is React?</h4><p>React is a JavaScript library that aims to simplify development of visual interfaces.</p><p>Developed at Facebook and released to the world in 2013, it drives some of the most widely used apps, powering Facebook and Instagram among countless other applications.</p><p>Its primary goal is to make it easy to reason about an interface and its state at any point in time, by dividing the UI into a collection of components.</p><h4 id="why-is-react-so-popular">Why is React so popular?</h4><p>React has taken the frontend web development world by storm. Why?</p><h4 id="less-complex-than-the-other-alternatives">Less complex than the other alternatives</h4><p>At the time when React was announced, Ember.js and Angular 1.x were the predominant choices as a framework. Both these imposed so many conventions on the code that porting an existing app was not convenient at all.</p><p>React made a choice to be very easy to integrate into an existing project, because that’s how they had to do it at Facebook in order to introduce it to the existing codebase. Also, those 2 frameworks brought too much to the table, while React only chose to implement the View layer instead of the full MVC stack.</p><h4 id="perfect-timing">Perfect timing</h4><p>At the time, Angular 2.x was announced by Google, along with the backwards incompatibility and major changes it was going to bring. Moving from Angular 1 to 2 was like moving to a different framework, so this, along with execution speed improvements that React promised, made it something developers were eager to try.</p><h4 id="backed-by-facebook">Backed by Facebook</h4><p>Being backed by Facebook is, of course, going to benefit a project if it turns out to be successful.</p><p>Facebook currently has a strong interest in React, sees the value of it being Open Source, and this is a huge plus for all the developers using it in their own projects.</p><h4 id="is-react-simple-to-learn">Is React simple to learn?</h4><p>Even though I said that React is simpler than alternative frameworks, diving into React is still complicated, but mostly because of the corollary technologies that can be integrated with React, like Redux and GraphQL.</p><p>React in itself has a very small API, and you basically need to understand 4 concepts to get started:</p><ul><li>Components</li><li>JSX</li><li>State</li><li>Props</li></ul><p>All these (and more) are explained in this handbook.</p><h4 id="how-to-install-react-on-your-development-computer">How to install React on your development computer</h4><p>How do you install React?</p><p>React is a library, so saying <em>install</em> might sound a bit weird. Maybe <em>setup</em> is a better word, but you get the concept.</p><p>There are various ways to setup React so that it can be used on your app or site.</p><h4 id="load-react-directly-in-the-web-page">Load React directly in the web page</h4><p>The simplest one is to add the React JavaScript file into the page directly. This is best when your React app will interact with the elements present on a single page, and not actually controls the whole navigation aspect.</p><p>In this case, you add 2 script tags to the end of the <code>body</code> tag:</p><pre><code class="language-html">&lt;html&gt;
...
&lt;body&gt;
...
&lt;script
src="https://cdnjs.cloudflare.com/ajax/libs/react/16.8.3/umd/react.development.js"
crossorigin
&gt;&lt;/script&gt;
&lt;script
src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.8.3/umd/react-dom.production.min.js"
crossorigin
&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><blockquote><em>Please change the version number to the latest version of React available.</em></blockquote><p>Here we loaded both React and React DOM. Why 2 libraries? Because React is 100% independent from the browser and can be used outside it (for example on Mobile devices with React Native). Hence the need for React DOM, to add the wrappers for the browser.</p><p>After those tags you can load your JavaScript files that use React, or even inline JavaScript in a <code>script</code> tag:</p><pre><code class="language-html">&lt;script src="app.js"&gt;&lt;/script&gt;
&lt;!-- or --&gt;
&lt;script&gt;
//my app
&lt;/script&gt;</code></pre><p>To use JSX you need an extra step: load Babel</p><pre><code class="language-html">&lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt;</code></pre><p>and load your scripts with the special <code>text/babel</code> MIME type:</p><pre><code class="language-html">&lt;script src="app.js" type="text/babel"&gt;&lt;;/script&gt;</code></pre><p>Now you can add JSX in your app.js file:</p><pre><code class="language-jsx">const Button = () =&gt; {
return &lt;button&gt;Click me!&lt;/button&gt;
}
//...
}</code></pre><p>to</p><pre><code class="language-jsx">const myFunction = () =&gt; {
//...
}</code></pre><p>If the function body contains just a single statement, you can omit the brackets and write all on a single line:</p><pre><code class="language-jsx">const myFunction = () =&gt; doSomething()</code></pre><p>Parameters are passed in the parentheses:</p><pre><code class="language-jsx">const myFunction = (param1, param2) =&gt; doSomething(param1, param2)</code></pre><p>If you have one (and just one) parameter, you could omit the parentheses completely:</p><pre><code class="language-jsx">const myFunction = param =&gt; doSomething(param)</code></pre><p>Thanks to this short syntax, arrow functions <strong>encourage the use of small functions</strong>.</p><h3 id="implicit-return">Implicit return</h3><p>Arrow functions allow you to have an implicit return: values are returned without having to use the <code>return</code> keyword.</p><p>It works when there is a one-line statement in the function body:</p><pre><code class="language-jsx">const myFunction = () =&gt; 'test'
myFunction() //'test'</code></pre><p>Another example, when returning an object, remember to wrap the curly brackets in parentheses to avoid it being considered the wrapping function body brackets:</p><pre><code class="language-jsx">const myFunction = () =&gt; ({ value: 'test' })
myFunction() //{value: 'test'}</code></pre><h3 id="how-this-works-in-arrow-functions">How this works in arrow functions</h3><p><code>this</code> is a concept that can be complicated to grasp, as it varies a lot depending on the context and also varies depending on the mode of JavaScript (<em>strict mode</em> or not).</p><p>It’s important to clarify this concept because arrow functions behave very differently compared to regular functions.</p><p>When defined as a method of an object, in a regular function <code>this</code> refers to the object, so you can do:</p><pre><code class="language-jsx">const car = {
model: 'Fiesta',
manufacturer: 'Ford',
fullName: function() {
return `${this.manufacturer} ${this.model}`
}
}</code></pre><p>calling <code>car.fullName()</code> will return <code>"Ford Fiesta"</code>.</p><p>The <code>this</code> scope with arrow functions is <strong>inherited</strong> from the execution context. An arrow function does not bind <code>this</code> at all, so its value will be looked up in the call stack, so in this code <code>car.fullName()</code> will not work, and will return the string <code>"undefined undefined"</code>:</p><pre><code class="language-jsx">const car = {
model: 'Fiesta',
manufacturer: 'Ford',
fullName: () =&gt; {
return `${this.manufacturer} ${this.model}`
}
}</code></pre><p>Due to this, arrow functions are not suited as object methods.</p><p>Arrow functions cannot be used as constructors either, when instantiating an object will raise a <code>TypeError</code>.</p><p>This is where regular functions should be used instead, <strong>when dynamic context is not needed</strong>.</p><p>This is also a problem when handling events. DOM Event listeners set <code>this</code> to be the target element, and if you rely on <code>this</code> in an event handler, a regular function is necessary:</p><pre><code class="language-jsx">const link = document.querySelector('#link')
link.addEventListener('click', () =&gt; {
// this === window
})
const link = document.querySelector('#link')
link.addEventListener('click', function() {
// this === link
})</code></pre><h3 id="rest-and-spread">Rest and spread</h3><p>You can expand an array, an object or a string using the spread operator <code>...</code>.</p><p>Let’s start with an array example. Given</p><pre><code class="language-jsx">const a = [1, 2, 3]</code></pre><p>you can create a new array using</p><pre><code class="language-jsx">const b = [...a, 4, 5, 6]</code></pre><p>You can also create a copy of an array using</p><pre><code class="language-jsx">const c = [...a]</code></pre><p>This works for objects as well. Clone an object with:</p><pre><code class="language-jsx">const newObj = { ...oldObj }</code></pre><p>Using strings, the spread operator creates an array with each char in the string:</p><pre><code class="language-jsx">const hey = 'hey'
const arrayized = [...hey] // ['h', 'e', 'y']</code></pre><p>This operator has some pretty useful applications. The most important one is the ability to use an array as function argument in a very simple way:</p><pre><code class="language-jsx">const f = (foo, bar) =&gt; {}
const a = [1, 2]
f(...a)</code></pre><p>(in the past you could do this using <code>f.apply(null, a)</code> but that's not as nice and readable)</p><p>The <strong>rest element</strong> is useful when working with <strong>array destructuring</strong>:</p><pre><code class="language-jsx">const numbers = [1, 2, 3, 4, 5]
[first, second, ...others] = numbers</code></pre><p>and <strong>spread elements</strong>:</p><pre><code class="language-jsx">const numbers = [1, 2, 3, 4, 5]
const sum = (a, b, c, d, e) =&gt; a + b + c + d + e
const sumOfNumbers = sum(...numbers)</code></pre><p>ES2018 introduces rest properties, which are the same but for objects.</p><p><strong>Rest properties</strong>:</p><pre><code class="language-jsx">const { first, second, ...others } = {
first: 1,
second: 2,
third: 3,
fourth: 4,
fifth: 5
}
first // 1
second // 2
others // { third: 3, fourth: 4, fifth: 5 }</code></pre><p><strong>Spread properties</strong> allow to create a new object by combining the properties of the object passed after the spread operator:</p><pre><code class="language-jsx">const items = { first, second, ...others }
items //{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</code></pre><h3 id="object-and-array-destructuring">Object and array destructuring</h3><p>Given an object, using the destructuring syntax you can extract just some values and put them into named variables:</p><pre><code class="language-jsx">const person = {
firstName: 'Tom',
lastName: 'Cruise',
actor: true,
age: 54 //made up
}
const { firstName: name, age } = person //name: Tom, age: 54</code></pre><p><code>name</code> and <code>age</code> contain the desired values.</p><p>The syntax also works on arrays:</p><pre><code class="language-jsx">const a = [1, 2, 3, 4, 5]
const [first, second] = a</code></pre><p>This statement creates 3 new variables by getting the items with index 0, 1, 4 from the array <code>a</code>:</p><pre><code class="language-jsx">const [first, second, , , fifth] = a</code></pre><h3 id="template-literals">Template literals</h3><p>Template Literals are a new ES2015 / ES6 feature that allows you to work with strings in a novel way compared to ES5 and below.</p><p>The syntax at a first glance is very simple, just use backticks instead of single or double quotes:</p><pre><code class="language-jsx">const a_string = `something`</code></pre><p>They are unique because they provide a lot of features that normal strings built with quotes do not, in particular:</p><ul><li>they offer a great syntax to define multiline strings</li><li>they provide an easy way to interpolate variables and expressions in strings</li><li>they allow you to create DSLs with template tags (DSL means domain specific language, and it’s for example used in React by Styled Components, to define CSS for a component)</li></ul><p>Let’s dive into each of these in detail.</p><h4 id="multiline-strings">Multiline strings</h4><p>Pre-ES6, to create a string spanning over two lines you had to use the <code>\</code> character at the end of a line:</p><pre><code class="language-jsx">const string =
'first part \
second part'</code></pre><p>This allows to create a string on 2 lines, but it’s rendered on just one line:</p><p><code>first part second part</code></p><p>To render the string on multiple lines as well, you explicitly need to add <code>\n</code> at the end of each line, like this:</p><pre><code>const string =
'first line\n \
second line'</code></pre><p>or</p><pre><code>const string = 'first line\n' + 'second line'</code></pre><p>Template literals make multiline strings much simpler.</p><p>Once a template literal is opened with the backtick, you just press enter to create a new line, with no special characters, and it’s rendered as-is:</p><pre><code>const string = `Hey
this
string
is awesome!`</code></pre><p>Keep in mind that space is meaningful, so doing this:</p><pre><code>const string = `First
Second`</code></pre><p>is going to create a string like this:</p><pre><code class="language-jsx">First
Second</code></pre><p>an easy way to fix this problem is by having an empty first line, and appending the trim() method right after the closing backtick, which will eliminate any space before the first character:</p><pre><code class="language-jsx">const string = `
First
Second`.trim()</code></pre><h4 id="interpolation">Interpolation</h4><p>Template literals provide an easy way to interpolate variables and expressions into strings.</p><p>You do so by using the <code>${...}</code> syntax:</p><pre><code class="language-jsx">const myVariable = 'test'
const string = `something ${myVariable}` //something test</code></pre><p>inside the <code>${}</code> you can add anything, even expressions:</p><pre><code class="language-jsx">const string = `something ${1 + 2 + 3}`
const string2 = `something ${foo() ? 'x' : 'y'}`</code></pre><h3 id="classes">Classes</h3><p>In 2015 the ECMAScript 6 (ES6) standard introduced classes.</p><p>JavaScript has a quite uncommon way to implement inheritance: prototypical inheritance. <a href="https://flaviocopes.com/javascript-prototypal-inheritance/" rel="noopener">Prototypal inheritance</a>, while in my opinion great, is unlike most other popular programming language’s implementation of inheritance, which is class-based.</p><p>People coming from Java or Python or other languages had a hard time understanding the intricacies of prototypal inheritance, so the ECMAScript committee decided to sprinkle syntactic sugar on top of prototypical inheritance so that it resembles how class-based inheritance works in other popular implementations.</p><p>This is important: JavaScript under the hood is still the same, and you can access an object prototype in the usual way.</p><h4 id="a-class-definition">A class definition</h4><p>This is how a class looks.</p><pre><code class="language-jsx">class Person {
constructor(name) {
this.name = name
}
hello() {
return 'Hello, I am ' + this.name + '.'
}
}</code></pre><p>A class has an identifier, which we can use to create new objects using <code>new ClassIdentifier()</code>.</p><p>When the object is initialized, the <code>constructor</code> method is called, with any parameters passed.</p><p>A class also has as many methods as it needs. In this case <code>hello</code> is a method and can be called on all objects derived from this class:</p><pre><code>const flavio = new Person('Flavio')
flavio.hello()</code></pre><h4 id="class-inheritance">Class inheritance</h4><p>A class can extend another class, and objects initialized using that class inherit all the methods of both classes.</p><p>If the inherited class has a method with the same name as one of the classes higher in the hierarchy, the closest method takes precedence:</p><pre><code class="language-jsx">class Programmer extends Person {
hello() {
return super.hello() + ' I am a programmer.'
}
}
const flavio = new Programmer('Flavio')
flavio.hello()</code></pre><p>(the above program prints “<em>Hello, I am Flavio. I am a programmer.</em>”)</p><p>Classes do not have explicit class variable declarations, but you must initialize any variable in the constructor.</p><p>Inside a class, you can reference the parent class calling <code>super()</code>.</p><h4 id="static-methods">Static methods</h4><p>Normally methods are defined on the instance, not on the class.</p><p>Static methods are executed on the class instead:</p><pre><code class="language-jsx">class Person {
static genericHello() {
return 'Hello'
}
}
Person.genericHello() //Hello</code></pre><h4 id="private-methods">Private methods</h4><p>JavaScript does not have a built-in way to define private or protected methods.</p><p>There are workarounds, but I won’t describe them here.</p><h4 id="getters-and-setters">Getters and setters</h4><p>You can add methods prefixed with <code>get</code> or <code>set</code> to create a getter and setter, which are two different pieces of code that are executed based on what you are doing: accessing the variable, or modifying its value.</p><pre><code class="language-jsx">class Person {
constructor(name) {
this.name = name
}
set name(value) {
this.name = value
}
get name() {
return this.name
}
}</code></pre><p>If you only have a getter, the property cannot be set, and any attempt at doing so will be ignored:</p><pre><code>class Person {
constructor(name) {
this.name = name
}
get name() {
return this.name
}
}</code></pre><p>If you only have a setter, you can change the value but not access it from the outside:</p><pre><code class="language-jsx">class Person {
constructor(name) {
this.name = name
}
set name(value) {
this.name = value
}
}</code></pre><h3 id="callbacks">Callbacks</h3><p>Computers are asynchronous by design.</p><p>Asynchronous means that things can happen independently of the main program flow.</p><p>In the current consumer computers, every program runs for a specific time slot, and then it stops its execution to let another program continue its execution. This thing runs in a cycle so fast that’s impossible to notice, and we think our computers run many programs simultaneously, but this is an illusion (except on multiprocessor machines).</p><p>Programs internally use <em>interrupts</em>, a signal that’s emitted to the processor to gain the attention of the system.</p><p>I won’t go into the internals of this, but just keep in mind that it’s normal for programs to be asynchronous, and halt their execution until they need attention, and the computer can execute other things in the meantime. When a program is waiting for a response from the network, it cannot halt the processor until the request finishes.</p><p>Normally, programming languages are synchronous, and some provide a way to manage asynchronicity, in the language or through libraries. C, Java, C#, PHP, Go, Ruby, Swift, Python, they are all synchronous by default. Some of them handle async by using threads, spawning a new process.</p><p>JavaScript is <strong>synchronous</strong> by default and is single threaded. This means that code cannot create new threads and run in parallel.</p><p>Lines of code are executed in series, one after another, for example:</p><pre><code class="language-jsx">const a = 1
const b = 2
const c = a * b
console.log(c)
doSomething()</code></pre><p>But JavaScript was born inside the browser, its main job, in the beginning, was to respond to user actions, like <code>onClick</code>, <code>onMouseOver</code>, <code>onChange</code>, <code>onSubmit</code> and so on. How could it do this with a synchronous programming model?</p><p>The answer was in its environment. The <strong>browser</strong> provides a way to do it by providing a set of APIs that can handle this kind of functionality.</p><p>More recently, Node.js introduced a non-blocking I/O environment to extend this concept to file access, network calls and so on.</p><p>You can’t know when a user is going to click a button, so what you do is, you <strong>define an event handler for the click event</strong>. This event handler accepts a function, which will be called when the event is triggered:</p><pre><code>document.getElementById('button').addEventListener('click', () =&gt; {
//item clicked
})</code></pre><p>This is the so-called <strong>callback</strong>.</p><p>A callback is a simple function that’s passed as a value to another function, and will only be executed when the event happens. We can do this because JavaScript has first-class functions, which can be assigned to variables and passed around to other functions (called <strong>higher-order functions</strong>)</p><p>It’s common to wrap all your client code in a <code>load</code> event listener on the <code>window</code>object, which runs the callback function only when the page is ready:</p><pre><code>window.addEventListener('load', () =&gt; {
//window loaded
//do what you want
})</code></pre><p>Callbacks are used everywhere, not just in DOM events.</p><p>One common example is by using timers:</p><pre><code>setTimeout(() =&gt; {
// runs after 2 seconds
}, 2000)</code></pre><p>XHR requests also accept a callback, in this example by assigning a function to a property that will be called when a particular event occurs (in this case, the state of the request changes):</p><pre><code>const xhr = new XMLHttpRequest()
xhr.onreadystatechange = () =&gt; {
if (xhr.readyState === 4) {
xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')
}
}
xhr.open('GET', 'https://yoursite.com')
xhr.send()</code></pre><h4 id="handling-errors-in-callbacks">Handling errors in callbacks</h4><p>How do you handle errors with callbacks? One very common strategy is to use what Node.js adopted: the first parameter in any callback function is the error object: <strong>error-first callbacks</strong></p><p>If there is no error, the object is <code>null</code>. If there is an error, it contains some description of the error and other information.</p><pre><code>fs.readFile('/file.json', (err, data) =&gt; {
if (err !== null) {
//handle error
console.log(err)
return
}
//no errors, process data
console.log(data)
})</code></pre><h4 id="the-problem-with-callbacks">The problem with callbacks</h4><p>Callbacks are great for simple cases!</p><p>However every callback adds a level of nesting, and when you have lots of callbacks, the code starts to be complicated very quickly:</p><pre><code>window.addEventListener('load', () =&gt; {
document.getElementById('button').addEventListener('click', () =&gt; {
setTimeout(() =&gt; {
items.forEach(item =&gt; {
//your code here
})
}, 2000)
})
})</code></pre><p>This is just a simple 4-levels code, but I’ve seen much more levels of nesting and it’s not fun.</p><p>How do we solve this?</p><h3 id="alternatives-to-callbacks">ALTERNATIVES TO CALLBACKS</h3><p>Starting with ES6, JavaScript introduced several features that help us with asynchronous code that do not involve using callbacks:</p><ul><li>Promises (ES6)</li><li>Async/Await (ES8)</li></ul><h3 id="promises">Promises</h3><p>Promises are one way to deal with asynchronous code, without writing too many callbacks in your code.</p><p>Although they’ve been around for years, they were standardized and introduced in ES2015, and now they have been superseded in ES2017 by async functions.</p><p><strong>Async functions</strong> use the promises API as their building block, so understanding them is fundamental even if in newer code you’ll likely use async functions instead of promises.</p><h4 id="how-promises-work-in-brief">How promises work, in brief</h4><p>Once a promise has been called, it will start in <strong>pending state</strong>. This means that the caller function continues the execution, while it waits for the promise to do its own processing, and give the caller function some feedback.</p><p>At this point, the caller function waits for it to either return the promise in a <strong>resolved state</strong>, or in a <strong>rejected state</strong>, but as you know JavaScript is asynchronous, so <em>the function continues its execution while the promise does it work</em>.</p><h4 id="which-js-api-use-promises">Which JS API use promises?</h4><p>In addition to your own code and library code, promises are used by standard modern Web APIs like <a href="https://flaviocopes.com/fetch-api/" rel="noopener">Fetch</a> or <a href="https://flaviocopes.com/service-workers/" rel="noopener">Service Workers</a>.</p><p>It’s unlikely that in modern JavaScript you’ll find yourself <em>not</em> using promises, so let’s start diving right into them.</p><h4 id="creating-a-promise">Creating a promise</h4><p>The Promise API exposes a Promise constructor, which you initialize using <code>new Promise()</code>:</p><pre><code>let done = true
const isItDoneYet = new Promise((resolve, reject) =&gt; {
if (done) {
const workDone = 'Here is the thing I built'
resolve(workDone)
} else {
const why = 'Still working on something else'
reject(why)
}
})</code></pre><p>As you can see the promise checks the <code>done</code> global constant, and if that's true, we return a resolved promise, otherwise a rejected promise.</p><p>Using <code>resolve</code> and <code>reject</code> we can communicate back a value, in the above case we just return a string, but it could be an object as well.</p><h4 id="consuming-a-promise">Consuming a promise</h4><p>In the last section, we introduced how a promise is created.</p><p>Now let’s see how the promise can be <em>consumed</em> or used.</p><pre><code>const isItDoneYet = new Promise()
//...
const checkIfItsDone = () =&gt; {
isItDoneYet
.then(ok =&gt; {
console.log(ok)
})
.catch(err =&gt; {
console.error(err)
})
}</code></pre><p>Running <code>checkIfItsDone()</code> will execute the <code>isItDoneYet()</code> promise and will wait for it to resolve, using the <code>then</code> callback, and if there is an error, it will handle it in the <code>catch</code> callback.</p><h4 id="chaining-promises">Chaining promises</h4><p>A promise can be returned to another promise, creating a chain of promises.</p><p>A great example of chaining promises is given by the <a href="https://flaviocopes.com/fetch-api/" rel="noopener">Fetch API</a>, a layer on top of the XMLHttpRequest API, which we can use to get a resource and queue a chain of promises to execute when the resource is fetched.</p><p>The Fetch API is a promise-based mechanism, and calling <code>fetch()</code> is equivalent to defining our own promise using <code>new Promise()</code>.</p><p>Example:</p><pre><code>const status = response =&gt; {
if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
return Promise.resolve(response)
}
return Promise.reject(new Error(response.statusText))
}
const json = response =&gt; response.json()
fetch('/todos.json')
.then(status)
.then(json)
.then(data =&gt; {
console.log('Request succeeded with JSON response', data)
})
.catch(error =&gt; {
console.log('Request failed', error)
})</code></pre><p>In this example, we call <code>fetch()</code> to get a list of TODO items from the <code>todos.json</code> file found in the domain root, and we create a chain of promises.</p><p>Running <code>fetch()</code> returns a <a href="https://fetch.spec.whatwg.org/#concept-response" rel="noopener">response</a>, which has many properties, and within those we reference:</p><ul><li><code>status</code>, a numeric value representing the HTTP status code</li><li><code>statusText</code>, a status message, which is <code>OK</code> if the request succeeded</li></ul><p><code>response</code> also has a <code>json()</code> method, which returns a promise that will resolve with the content of the body processed and transformed into JSON.</p><p>So given those premises, this is what happens: the first promise in the chain is a function that we defined, called <code>status()</code>, that checks the response status and if it's not a success response (between 200 and 299), it rejects the promise.</p><p>This operation will cause the promise chain to skip all the chained promises listed and will skip directly to the <code>catch()</code> statement at the bottom, logging the <code>Request failed</code> text along with the error message.</p><p>If that succeeds instead, it calls the json() function we defined. Since the previous promise, when successful, returned the <code>response</code> object, we get it as an input to the second promise.</p><p>In this case, we return the data JSON processed, so the third promise receives the JSON directly:</p><pre><code>.then((data) =&gt; {
console.log('Request succeeded with JSON response', data)
})</code></pre><p>and we simply log it to the console.</p><h4 id="handling-errors">Handling errors</h4><p>In the above example, in the previous section, we had a <code>catch</code> that was appended to the chain of promises.</p><p>When anything in the chain of promises fails and raises an error or rejects the promise, the control goes to the nearest <code>catch()</code> statement down the chain.</p><pre><code>new Promise((resolve, reject) =&gt; {
throw new Error('Error')
}).catch(err =&gt; {
console.error(err)
})
// or
new Promise((resolve, reject) =&gt; {
reject('Error')
}).catch(err =&gt; {
console.error(err)
})</code></pre><h4 id="cascading-errors">Cascading errors</h4><p>If inside the <code>catch()</code> you raise an error, you can append a second <code>catch()</code> to handle it, and so on.</p><pre><code>new Promise((resolve, reject) =&gt; {
throw new Error('Error')
})
.catch(err =&gt; {
throw new Error('Error')
})
.catch(err =&gt; {
console.error(err)
})</code></pre><h4 id="orchestrating-promises-with-promise-all-">Orchestrating promises with <code>Promise.all()</code></h4><p>If you need to synchronize different promises, <code>Promise.all()</code> helps you define a list of promises, and execute something when they are all resolved.</p><p>Example:</p><pre><code>const f1 = fetch('/something.json')
const f2 = fetch('/something2.json')
Promise.all([f1, f2])
.then(res =&gt; {
console.log('Array of results', res)
})
.catch(err =&gt; {
console.error(err)
})</code></pre><p>The ES2015 destructuring assignment syntax allows you to also do</p><pre><code class="language-jsx">Promise.all([f1, f2]).then(([res1, res2]) =&gt; {
console.log('Results', res1, res2)
})</code></pre><p>You are not limited to using <code>fetch</code> of course, <strong>any promise is good to go</strong>.</p><h4 id="orchestrating-promises-with-promise-race-">Orchestrating promises with <code>Promise.race()</code></h4><p><code>Promise.race()</code> runs as soon as one of the promises you pass to it resolves, and it runs the attached callback just once with the result of the first promise resolved.</p><p>Example:</p><pre><code>const promiseOne = new Promise((resolve, reject) =&gt; {
setTimeout(resolve, 500, 'one')
})
const promiseTwo = new Promise((resolve, reject) =&gt; {
setTimeout(resolve, 100, 'two')
})
Promise.race([promiseOne, promiseTwo]).then(result =&gt; {
console.log(result) // 'two'
})</code></pre><h3 id="async-await">Async/Await</h3><p>JavaScript evolved in a very short time from callbacks to promises (ES2015), and since ES2017 asynchronous JavaScript is even simpler with the async/await syntax.</p><p>Async functions are a combination of promises and generators, and basically, they are a higher level abstraction over promises. Let me repeat: <strong>async/await is built on promises</strong>.</p><h4 id="why-were-async-await-introduced">Why were async/await introduced?</h4><p>They reduce the boilerplate around promises, and the “don’t break the chain” limitation of chaining promises.</p><p>When Promises were introduced in ES2015, they were meant to solve a problem with asynchronous code, and they did, but over the 2 years that separated ES2015 and ES2017, it was clear that <em>promises could not be the final solution</em>.</p><p>Promises were introduced to solve the famous <em>callback hell</em> problem, but they introduced complexity on their own, and syntax complexity.</p><p>They were good primitives around which a better syntax could be exposed to developers, so when the time was right we got <strong>async functions</strong>.</p><p>They make the code look like it’s synchronous, but it’s asynchronous and non-blocking behind the scenes.</p><h4 id="how-it-works">How it works</h4><p>An async function returns a promise, like in this example:</p><pre><code class="language-jsx">const doSomethingAsync = () =&gt; {
return new Promise(resolve =&gt; {
setTimeout(() =&gt; resolve('I did something'), 3000)
})
}</code></pre><p>When you want to <strong>call</strong> this function you prepend <code>await</code>, and <strong>the calling code will stop until the promise is resolved or rejected</strong>. One caveat: the client function must be defined as <code>async</code>. Here's an example:</p><pre><code>const doSomething = async () =&gt; {
console.log(await doSomethingAsync())
}</code></pre><h4 id="a-quick-example">A quick example</h4><p>This is a simple example of async/await used to run a function asynchronously:</p><pre><code>const doSomethingAsync = () =&gt; {
return new Promise(resolve =&gt; {
setTimeout(() =&gt; resolve('I did something'), 3000)
})
}
const doSomething = async () =&gt; {
console.log(await doSomethingAsync())
}
console.log('Before')
doSomething()
console.log('After')</code></pre><p>The above code will print the following to the browser console:</p><pre><code>Before
After
I did something //after 3s</code></pre><h4 id="promise-all-the-things">Promise all the things</h4><p>Prepending the <code>async</code> keyword to any function means that the function will return a promise.</p><p>Even if it’s not doing so explicitly, it will internally make it return a promise.</p><p>This is why this code is valid:</p><pre><code>const aFunction = async () =&gt; {
return 'test'
}
aFunction().then(alert) // This will alert 'test'</code></pre><p>and it’s the same as:</p><pre><code>const aFunction = async () =&gt; {
return Promise.resolve('test')
}
aFunction().then(alert) // This will alert 'test'</code></pre><h4 id="the-code-is-much-simpler-to-read">The code is much simpler to read</h4><p>As you can see in the example above, our code looks very simple. Compare it to code using plain promises, with chaining and callback functions.</p><p>And this is a very simple example, the major benefits will arise when the code is much more complex.</p><p>For example here’s how you would get a JSON resource, and parse it, using promises:</p><pre><code>const getFirstUserData = () =&gt; {
return fetch('/users.json') // get users list
.then(response =&gt; response.json()) // parse JSON
.then(users =&gt; users[0]) // pick first user
.then(user =&gt; fetch(`/users/${user.name}`)) // get user data
.then(userResponse =&gt; userResponse.json()) // parse JSON
}
getFirstUserData()</code></pre><p>And here is the same functionality provided using await/async:</p><pre><code>const getFirstUserData = async () =&gt; {
const response = await fetch('/users.json') // get users list
const users = await response.json() // parse JSON
const user = users[0] // pick first user
const userResponse = await fetch(`/users/${user.name}`) // get user data
const userData = await userResponse.json() // parse JSON
return userData
}
getFirstUserData()</code></pre><h4 id="multiple-async-functions-in-series">Multiple async functions in series</h4><p>Async functions can be chained very easily, and the syntax is much more readable than with plain promises:</p><pre><code>const promiseToDoSomething = () =&gt; {
return new Promise(resolve =&gt; {
setTimeout(() =&gt; resolve('I did something'), 10000)
})
}
const watchOverSomeoneDoingSomething = async () =&gt; {
const something = await promiseToDoSomething()
return something + ' and I watched'
}
const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; {
const something = await watchOverSomeoneDoingSomething()
return something + ' and I watched as well'
}
watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; {
console.log(res)
})</code></pre><p>Will print:</p><pre><code>I did something and I watched and I watched as well</code></pre><h4 id="easier-debugging">Easier debugging</h4><p>Debugging promises is hard because the debugger will not step over asynchronous code.</p><p>Async/await makes this very easy because to the compiler it’s just like synchronous code.</p><h3 id="es-modules">ES Modules</h3><p>ES Modules is the ECMAScript standard for working with modules.</p><p>While Node.js has been using the CommonJS standard for years, the browser never had a module system, as every major decision such as a module system must be first standardized by ECMAScript and then implemented by the browser.</p><p>This standardization process completed with ES6 and browsers started implementing this standard trying to keep everything well aligned, working all in the same way, and now ES Modules are supported in Chrome, Safari, Edge and Firefox (since version 60).</p><p>Modules are very cool, because they let you encapsulate all sorts of functionality, and expose this functionality to other JavaScript files, as libraries.</p><h4 id="the-es-modules-syntax">The ES Modules Syntax</h4><p>The syntax to import a module is:</p><pre><code>import package from 'module-name'</code></pre><p>while CommonJS uses</p><pre><code>const package = require('module-name')</code></pre><p>A module is a JavaScript file that <strong>exports</strong> one or more values (objects, functions or variables), using the <code>export</code> keyword. For example, this module exports a function that returns a string uppercase:</p><blockquote><em>uppercase.js</em></blockquote><pre><code>export default str =&gt; str.toUpperCase()</code></pre><p>In this example, the module defines a single, <strong>default export</strong>, so it can be an anonymous function. Otherwise it would need a name to distinguish it from other exports.</p><p>Now, <strong>any other JavaScript module</strong> can import the functionality offered by uppercase.js by importing it.</p><p>An HTML page can add a module by using a <code>&lt;scri</code>pt&gt; tag with the sp<code>ecial type="m</code>odule" attribute:</p><pre><code>&lt;script type="module" src="index.js"&gt;&lt;;/script&gt;</code></pre><blockquote><em>Note: this module import behaves like a <code>defer</code> script load. See <a href="https://flaviocopes.com/javascript-async-defer/" rel="noopener">efficiently load JavaScript with defer and async</a></em></blockquote><p>It’s important to note that any script loaded with <code>type="module"</code> is loaded in <a href="https://flaviocopes.com/javascript-strict-mode/" rel="noopener">strict mode</a>.</p><p>In this example, the <code>uppercase.js</code> module defines a <strong>default export</strong>, so when we import it, we can assign it a name we prefer:</p><pre><code>import toUpperCase from './uppercase.js'</code></pre><p>and we can use it:</p><pre><code>toUpperCase('test') //'TEST'</code></pre><p>You can also use an absolute path for the module import, to reference modules defined on another domain:</p><pre><code>import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js'</code></pre><p>This is also valid import syntax:</p><pre><code>import { foo } from '/uppercase.js'import { foo } from '../uppercase.js'</code></pre><p>This is not:</p><pre><code>import { foo } from 'uppercase.js'
import { foo } from 'utils/uppercase.js'</code></pre><p>It’s either absolute, or has a <code>./</code> or <code>/</code> before the name.</p><h3 id="other-import-export-options">Other import/export options</h3><p>We saw this example above:</p><pre><code class="language-jsx">export default str =&gt; str.toUpperCase()</code></pre><p>This creates one default export. In a file however you can export more than one thing, by using this syntax:</p><pre><code>const a = 1
const b = 2
const c = 3
export { a, b, c }</code></pre><p>Another module can import all those exports using</p><pre><code class="language-jsx">import * from 'module'</code></pre><p>You can import just a few of those exports, using the destructuring assignment:</p><pre><code>import { a } from 'module'
import { a, b } from 'module'</code></pre><p>You can rename any import, for convenience, using <code>as</code>:</p><pre><code>import { a, b as two } from 'module'</code></pre><p>You can import the default export, and any non-default export by name, like in this common React import:</p><pre><code class="language-jsx">import React, { Component } from 'react'</code></pre><p>You can see an ES Modules example here: <a href="https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html" rel="noopener">https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html</a></p><h4 id="cors">CORS</h4><p>Modules are fetched using <a href="https://flaviocopes.com/cors/" rel="noopener">CORS</a>. This means that if you reference scripts from other domains, they must have a valid CORS header that allows cross-site loading (like <code>Access-Control-Allow-Origin: *</code>)</p><h4 id="what-about-browsers-that-do-not-support-modules">What about browsers that do not support modules?</h4><p>Use a combination of <code>type="module"</code> and <code>nomodule</code>:</p><pre><code class="language-html">&lt;script type="module" src="module.js"&gt;&lt;/script&gt;
&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt;</code></pre><p>ES Modules are one of the biggest features introduced in modern browsers. They are part of ES6 but the road to implement them has been long.</p><p>We can now use them! But we must also remember that having more than a few modules is going to have a performance hit on our pages, as it’s one more step that the browser must perform at runtime.</p><p>Webpack is probably going to still be a huge player even if ES Modules land in the browser, but having such a feature directly built in the language is huge for a unification of how modules work client-side and on Node.js as well.</p><h3 id="section-2-react-concepts">SECTION 2: REACT CONCEPTS</h3><h3 id="single-page-applications">Single Page Applications</h3><p>React Applications are also called Single Page Applications. What does this mean?</p><p>In the past, when browsers were much less capable than today, and JavaScript performance was poor, every page was coming from a server. Every time you clicked something, a new request was made to the server and the browser subsequently loaded the new page.</p><p>Only very innovative products worked differently, and experimented with new approaches.</p><p>Today, popularized by modern frontend JavaScript frameworks like React, an app is usually built as a single page application: you only load the application code (HTML, <a href="https://flaviocopes.com/css/" rel="noopener">CSS</a>, <a href="https://flaviocopes.com/javascript/" rel="noopener">JavaScript</a>) once, and when you interact with the application, what generally happens is that JavaScript intercepts the browser events and instead of making a new request to the server that then returns a new document, the client requests some JSON or performs an action on the server but the page that the user sees is never completely wiped away, and behaves more like a desktop application.</p><p>Single page applications are built in JavaScript (or at least compiled to JavaScript) and work in the browser.</p><p>The technology is always the same, but the philosophy and some key components of how the application works are different.</p><h4 id="examples-of-single-page-applications">Examples of Single Page Applications</h4><p>Some notable examples:</p><ul><li>Gmail</li><li>Google Maps</li><li>Facebook</li><li>Twitter</li><li>Google Drive</li></ul><h4 id="pros-and-cons-of-spas">Pros and cons of SPAs</h4><p>An SPA feels much faster to the user, because instead of waiting for the client-server communication to happen, and wait for the browser to re-render the page, you can now have instant feedback. This is the responsibility of the application maker, but you can have transitions and spinners and any kind of UX improvement that is certainly better than the traditional workflow.</p><p>In addition to making the experience faster to the user, the server will consume less resources because you can focus on providing an efficient API instead of building the layouts server-side.</p><p>This makes it ideal if you also build a mobile app on top of the API, as you can completely reuse your existing server-side code.</p><p>Single Page Applications are easy to transform into Progressive Web Apps, which in turn enables you to provide local caching and to support offline experiences for your services (or simply a better error message if your users need to be online).</p><p>SPAs are best used when there is no need for SEO (search engine optimization). For example for apps that work behind a login.</p><p>Search engines, while improving every day, still have trouble indexing sites built with an SPA approach rather than the traditional server-rendered pages. This is the case for blogs. If you are going to rely on search engines, don’t even bother with creating a single page application without having a server rendered part as well.</p><p>When coding an SPA, you are going to write a great deal of JavaScript. Since the app can be long-running, you are going to need to pay a lot more attention to possible memory leaks — if in the past your page had a lifespan that was counted in minutes, now an SPA might stay open for hours at a time and if there is any memory issue that’s going to increase the browser memory usage by a lot more and it’s going to cause an unpleasantly slow experience if you don’t take care of it.</p><p>SPAs are great when working in teams. Backend developers can just focus on the API, and frontend developers can focus on creating the best user experience, making use of the API built in the backend.</p><p>As a con, Single Page Apps rely heavily on JavaScript. This might make using an application running on low power devices a poor experience in terms of speed. Also, some of your visitors might just have JavaScript disabled, and you also need to consider accessibility for anything you build.</p><h4 id="overriding-the-navigation">Overriding the navigation</h4><p>Since you get rid of the default browser navigation, URLs must be managed manually.</p><p>This part of an application is called the router. Some frameworks already take care of them for you (like Ember), others require libraries that will do this job (like <a href="https://flaviocopes.com/react-router/" rel="noopener">React Router</a>).</p><p>What’s the problem? In the beginning, this was an afterthought for developers building Single Page Applications. This caused the common “broken back button” issue: when navigating inside the application the URL didn’t change (since the browser default navigation was hijacked) and hitting the back button, a common operation that users do to go to the previous screen, might move to a website you visited a long time ago.</p><p>This problem can now be solved using the <a href="https://flaviocopes.com/history-api/" rel="noopener">History API</a> offered by browsers, but most of the time you’ll use a library that internally uses that API, like <strong>React Router</strong>.</p><h3 id="declarative">Declarative</h3><p>What does it mean when you read that React is declarative? You’ll run across articles describing React as a <strong>declarative approach to building UIs</strong>.</p><p>React made its “declarative approach” quite popular and upfront so it permeated the frontend world along with React.</p><p>It’s really not a new concept, but React took building UIs a lot more declaratively than with HTML templates:</p><ul><li>you can build Web interfaces without even touching the DOM directly</li><li>you can have an event system without having to interact with the actual DOM Events.</li></ul><p>The opposite of declarative is <strong>imperative</strong>. A common example of an imperative approach is looking up elements in the DOM using jQuery or DOM events. You tell the browser exactly what to do, instead of telling it what you need.</p><p>The React declarative approach abstracts that for us. We just tell React we want a component to be rendered in a specific way, and we never have to interact with the DOM to reference it later.</p><h3 id="immutability">Immutability</h3><p>One concept you will likely meet when programming in React is immutability (and its opposite, mutability).</p><p>It’s a controversial topic, but whatever you might think about the concept of immutability, React and most of its ecosystem kind of forces this, so you need to at least have a grasp of why it’s so important and the implications of it.</p><p>In programming, a variable is immutable when its value cannot change after it’s created.</p><p>You are already using immutable variables without knowing it when you manipulate a string. Strings are immutable by default, when you change them in reality you create a new string and assign it to the same variable name.</p><p>An immutable variable can never be changed. To update its value, you create a new variable.</p><p>The same applies to objects and arrays.</p><p>Instead of changing an array, to add a new item you create a new array by concatenating the old array, plus the new item.</p><p>An object is never updated, but copied before changing it.</p><p>This applies to React in many places.</p><p>For example, you should never mutate the <code>state</code> property of a component directly, but only through the <code>setState()</code> method.</p><p>In Redux, you never mutate the state directly, but only through reducers, which are functions.</p><p>The question is, why?</p><p>There are various reasons, the most important of which are:</p><ul><li>Mutations can be centralized, like in the case of Redux, which improves your debugging capabilities and reduces sources of errors.</li><li>Code looks cleaner and simpler to understand. You never expect a function to change some value without you knowing, which gives you <strong>predictability</strong>. When a function does not mutate objects but just returns a new object, it’s called a pure function.</li><li>The library can optimize the code because for example JavaScript is faster when swapping an old object reference for an entirely new object, rather than mutating an existing object. This gives you <strong>performance</strong>.</li></ul><h3 id="purity">Purity</h3><p>In JavaScript, when a function does not mutate objects but just returns a new object, it’s called a pure function.</p><p>A function, or a method, in order to be called <em>pure</em> should not cause side effects and should return the same output when called multiple times with the same input.</p><p>A pure function takes an input and returns an output without changing the input nor anything else.</p><p>Its output is only determined by the arguments. You could call this function 1M times, and given the same set of arguments, the output will always be the same.</p><p>React applies this concept to components. A React component is a pure component when its output is only dependant on its props.</p><p>All functional components are pure components:</p><pre><code>const Button = props =&gt; {
return &lt;button&gt;{props.message}&lt;/button&gt;
}</code></pre><p>Class components can be pure if their output only depends on the props:</p><pre><code>class Button extends React.Component {
render() {
return &lt;button&gt;{this.props.message}&lt;/button&gt;
}
}</code></pre><h3 id="composition">Composition</h3><p>In programming, composition allows you to build more complex functionality by combining small and focused functions.</p><p>For example, think about using <code>map()</code> to create a new array from an initial set, and then filtering the result using <code>filter()</code>:</p><pre><code>const list = ['Apple', 'Orange', 'Egg']
list.map(item =&gt; item[0]).filter(item =&gt; item === 'A') //'A'</code></pre><p>In React, composition allows you to have some pretty cool advantages.</p><p>You create small and lean components and use them to <em>compose</em> more functionality on top of them. How?</p><h4 id="create-specialized-version-of-a-component">Create specialized version of a component</h4><p>Use an outer component to expand and specialize a more generic component:</p><pre><code>const Button = props =&gt; {
return &lt;button&gt;{props.text}&lt;/button&gt;
}
const SubmitButton = () =&gt; {
return &lt;Button text="Submit" /&gt;
}
const LoginButton = () =&gt; {
return &lt;Button text="Login" /&gt;
}</code></pre><h4 id="pass-methods-as-props">Pass methods as props</h4><p>A component can focus on tracking a click event, for example, and what actually happens when the click event happens is up to the container component:</p><pre><code>const Button = props =&gt; {
return &lt;button onClick={props.onClickHandler}&gt;{props.text}&lt;/button&gt;
}
const LoginButton = props =&gt; {
return &lt;Button text="Login" onClickHandler={props.onClickHandler} /&gt;
}
const Container = () =&gt; {
const onClickHandler = () =&gt; {
alert('clicked')
}
return &lt;LoginButton onClickHandler={onClickHandler} /&gt;
}</code></pre><h4 id="using-children">Using children</h4><p>The <code>props.children</code> property allows you to inject components inside other components.</p><p>The component needs to output <code>props.children</code> in its JSX:</p><pre><code>const Sidebar = props =&gt; {
return &lt;aside&gt;{props.children}&lt;/aside&gt;
}</code></pre><p>and you embed more components into it in a transparent way:</p><pre><code>&lt;Sidebar&gt;
&lt;Link title="First link" /&gt;
&lt;Link title="Second link" /&gt;
&lt;/Sidebar&gt;</code></pre><h4 id="higher-order-components">Higher order components</h4><p>When a component receives a component as a prop and returns a component, it’s called higher order component.</p><p>We’ll see them in a little while.</p><h3 id="the-virtual-dom">The Virtual DOM</h3><p>Many existing frameworks, before React came on the scene, were directly manipulating the DOM on every change.</p><p>First, what is the DOM?</p><p>The DOM (<em>Document Object Model</em>) is a Tree representation of the page, starting from the <code>&lt;ht</code>ml&gt; tag, going down into every child, which are called nodes.</p><p>It’s kept in the browser memory, and directly linked to what you see in a page. The DOM has an API that you can use to traverse it, access every single node, filter them, modify them.</p><p>The API is the familiar syntax you have likely seen many times, if you were not using the abstract API provided by jQuery and friends:</p><pre><code>document.getElementById(id)
document.getElementsByTagName(name)
document.createElement(name)
parentNode.appendChild(node)
element.innerHTML
element.style.left
element.setAttribute()
element.getAttribute()
element.addEventListener()
window.content
window.onload
window.dump()
window.scrollTo()</code></pre><p>React keeps a copy of the DOM representation, for what concerns the React rendering: the Virtual DOM</p><h4 id="the-virtual-dom-explained">The Virtual DOM Explained</h4><p>Every time the DOM changes, the browser has to do two intensive operations: repaint (visual or content changes to an element that do not affect the layout and positioning relative to other elements) and reflow (recalculate the layout of a portion of the page — or the whole page layout).</p><p>React uses a Virtual DOM to help the browser use less resources when changes need to be done on a page.</p><p>When you call <code>setState()</code> on a Component, specifying a state different than the previous one, React marks that Component as <strong>dirty</strong>. This is key: React only updates when a Component changes the state explicitly.</p><p>What happens next is:</p><ul><li>React updates the Virtual DOM relative to the components marked as dirty (with some additional checks, like triggering <code>shouldComponentUpdate()</code>)</li><li>Runs the diffing algorithm to reconcile the changes</li><li>Updates the real DOM</li></ul><h4 id="why-is-the-virtual-dom-helpful-batching">Why is the Virtual DOM helpful: batching</h4><p>The key thing is that React batches much of the changes and performs a unique update to the real DOM, by changing all the elements that need to be changed at the same time, so the repaint and reflow the browser must perform to render the changes are executed just once.</p><h3 id="unidirectional-data-flow">Unidirectional Data Flow</h3><p>Working with React you might encounter the term Unidirectional Data Flow. What does it mean? Unidirectional Data Flow is not a concept unique to React, but as a JavaScript developer this might be the first time you hear it.</p><p>In general this concept means that data has one, and only one, way to be transferred to other parts of the application.</p><p>In React this means that:</p><ul><li>state is passed to the view and to child components</li><li>actions are triggered by the view</li><li>actions can update the state</li><li>the state change is passed to the view and to child components</li></ul><p>The view is a result of the application state. State can only change when actions happen. When actions happen, the state is updated.</p><p>Thanks to one-way bindings, data cannot flow in the opposite way (as would happen with two-way bindings, for example), and this has some key advantages:</p><ul><li>it’s less error prone, as you have more control over your data</li><li>it’s easier to debug, as you know <em>what</em> is coming from <em>where</em></li><li>it’s more efficient, as the library already knows what the boundaries are of each part of the system</li></ul><p>A state is always owned by one Component. Any data that’s affected by this state can only affect Components below it: its children.</p><p>Changing state on a Component will never affect its parent, or its siblings, or any other Component in the application: just its children.</p><p>This is the reason that the state is often moved up in the Component tree, so that it can be shared between components that need to access it.</p><h3 id="section-3-in-depth-react">SECTION 3: IN-DEPTH REACT</h3><h3 id="jsx">JSX</h3><p>JSX is a technology that was introduced by React.</p><p>Although React can work completely fine without using JSX, it’s an ideal technology to work with components, so React benefits a lot from JSX.</p><p>At first, you might think that using JSX is like mixing HTML and <a href="https://flaviocopes.com/javascript/" rel="noopener">JavaScript</a> (and as you’ll see CSS).</p><p>But this is not true, because what you are really doing when using JSX syntax is writing a declarative syntax of what a component UI should be.</p><p>And you’re describing that UI not using strings, but instead using JavaScript, which allows you to do many nice things.</p><h4 id="a-jsx-primer">A JSX primer</h4><p>Here is how you define a h1 tag containing a string:</p><pre><code class="language-jsx">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;</code></pre><p>It looks like a strange mix of JavaScript and HTML, but in reality it’s all JavaScript.</p><p>What looks like HTML, is actually syntactic sugar for defining components and their positioning inside the markup.</p><p>Inside a JSX expression, attributes can be inserted very easily:</p><pre><code>const myId = 'test'
const element = &lt;h1 id={myId}&gt;Hello, world!&lt;/h1&gt;</code></pre><p>You just need to pay attention when an attribute has a dash (<code>-</code>) which is converted to camelCase syntax instead, and these 2 special cases:</p><ul><li><code>class</code> becomes <code>className</code></li><li><code>for</code> becomes <code>htmlFor</code></li></ul><p>because they are reserved words in JavaScript.</p><p>Here’s a JSX snippet that wraps two components into a <code>div</code> tag:</p><pre><code>&lt;div&gt;
&lt;BlogPostsList /&gt;
&lt;Sidebar /&gt;
&lt;/div&gt;</code></pre><p>A tag always needs to be closed, because this is more XML than HTML (if you remember the XHTML days, this will be familiar, but since then the HTML5 loose syntax won). In this case a self-closing tag is used.</p><p>Notice how I wrapped the 2 components into a <code>div</code>. Why? Because <strong>the render() function can only return a single node</strong>, so in case you want to return 2 siblings, just add a parent. It can be any tag, not just <code>div</code>.</p><h4 id="transpiling-jsx">Transpiling JSX</h4><p>A browser cannot execute JavaScript files containing JSX code. They must be first transformed to regular JS.</p><p>How? By doing a process called <strong>transpiling</strong>.</p><p>We already said that JSX is optional, because to every JSX line, a corresponding plain JavaScript alternative is available, and that’s what JSX is transpiled to.</p><p>For example the following two constructs are equivalent:</p><blockquote><em>Plain JS</em></blockquote><pre><code>ReactDOM.render(
React.DOM.div(
{ id: 'test' },
React.DOM.h1(null, 'A title'),
React.DOM.p(null, 'A paragraph')
),
document.getElementById('myapp')
)</code></pre><blockquote><em>JSX</em></blockquote><pre><code>ReactDOM.render(
&lt;div id="test"&gt;
&lt;h1&gt;A title&lt;/h1&gt;
&lt;p&gt;A paragraph&lt;/p&gt;
&lt;/div&gt;,
document.getElementById('myapp')
)</code></pre><p>This very basic example is just the starting point, but you can already see how more complicated the plain JS syntax is compared to using JSX.</p><p>At the time of writing the most popular way to perform the <strong>transpilation</strong> is to use <strong>Babel</strong>, which is the default option when running <code>create-react-app</code>, so if you use it you don't have to worry, everything happens under the hood for you.</p><p>If you don’t use <code>create-react-app</code> you need to setup Babel yourself.</p><h4 id="js-in-jsx">JS in JSX</h4><p>JSX accepts any kind of JavaScript mixed into it.</p><p>Whenever you need to add some JS, just put it inside curly braces <code>{}</code>. For example here's how to use a constant value defined elsewhere:</p><pre><code>const paragraph = 'A paragraph'
ReactDOM.render(
&lt;div id="test"&gt;
&lt;h1&gt;A title&lt;/h1&gt;
&lt;p&gt;{paragraph}&lt;/p&gt;
&lt;/div&gt;,
document.getElementById('myapp')
)</code></pre><p>This is a basic example. Curly braces accept <em>any</em> JS code:</p><pre><code>const paragraph = 'A paragraph'
ReactDOM.render(
&lt;table&gt;
{rows.map((row, i) =&gt; {
return &lt;tr&gt;{row.text}&lt;/tr&gt;
})}
&lt;/table&gt;,
document.getElementById('myapp')
)</code></pre><p>As you can see <em>we nested JavaScript inside JSX defined inside JavaScript nested in JSX</em>. You can go as deep as you need.</p><h4 id="html-in-jsx">HTML in JSX</h4><p>JSX resembles HTML a lot, but it’s actually XML syntax.</p><p>In the end you render HTML, so you need to know a few differences between how you would define some things in HTML, and how you define them in JSX.</p><h4 id="you-need-to-close-all-tags">You need to close all tags</h4><p>Just like in XHTML, if you have ever used it, you need to close all tags: no more <code>&lt;br&gt;</code> but instead use the self-closing tag: <code>&lt;br /&gt;</code> (the same goes for other tags)</p><h4 id="camelcase-is-the-new-standard">camelCase is the new standard</h4><p>In HTML you’ll find attributes without any case (e.g. <code>onchange</code>). In JSX, they are renamed to their camelCase equivalent:</p><ul><li><code>onchange</code> =&gt; <code>onChange</code></li><li><code>onclick</code> =&gt; <code>onClick</code></li><li><code>onsubmit</code> =&gt; <code>onSubmit</code></li></ul><h4 id="class-becomes-classname"><code>class</code> becomes <code>className</code></h4><p>Due to the fact that JSX is JavaScript, and <code>class</code> is a reserved word, you can't write</p><pre><code>&lt;p class="description"&gt;</code></pre><p>but you need to use</p><pre><code>&lt;p className="description"&gt;</code></pre><p><strong>The same applies to <code>for</code></strong> which is translated to <code>htmlFor</code>.</p><h4 id="css-in-react">CSS in React</h4><p>JSX provides a cool way to define CSS.</p><p>If you have a little experience with HTML inline styles, at first glance you’ll find yourself pushed back 10 or 15 years, to a world where inline CSS was completely normal (nowadays it’s demonized and usually just a “quick fix” go-to solution).</p><p>JSX style is not the same thing: first of all, instead of accepting a string containing CSS properties, the JSX <code>style</code> attribute only accepts an object. This means you define properties in an object:</p><pre><code>var divStyle = {
color: 'white'
}
ReactDOM.render(&lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;, mountNode)</code></pre><p>or</p><pre><code>ReactDOM.render(&lt;div style={{ color: 'white' }}&gt;Hello World!&lt;/div&gt;, mountNode)</code></pre><p>The CSS values you write in JSX are slightly different from plain CSS:</p><ul><li>the keys property names are camelCased</li><li>values are just strings</li><li>you separate each tuple with a comma</li></ul><h4 id="why-is-this-preferred-over-plain-css-sass-less">Why is this preferred over plain CSS / SASS / LESS?</h4><p>CSS is an <strong>unsolved problem</strong>. Since its inception, dozens of tools around it rose and then fell. The main problem with JS is that there is no scoping and it’s easy to write CSS that is not enforced in any way, thus a “quick fix” can impact elements that should not be touched.</p><p>JSX allows components (defined in React for example) to completely encapsulate their style.</p><h4 id="is-this-the-go-to-solution">Is this the go-to solution?</h4><p>Inline styles in JSX are good until you need to</p><ol><li>write media queries</li><li>style animations</li><li>reference pseudo classes (e.g. <code>:hover</code>)</li><li>reference pseudo elements (e.g. <code>::first-letter</code>)</li></ol><p>In short, they cover the basics, but it’s not the final solution.</p><h4 id="forms-in-jsx">Forms in JSX</h4><p>JSX adds some changes to how HTML forms work, with the goal of making things easier for the developer.</p><h4 id="value-and-defaultvalue"><code>value</code> and <code>defaultValue</code></h4><p>The <code>value</code> attribute always holds the current value of the field.</p><p>The <code>defaultValue</code> attribute holds the default value that was set when the field was created.</p><p><em>This helps solve some weird behavior of regular <a href="https://flaviocopes.com/dom/" rel="noopener">DOM</a> interaction when inspecting <code>input.value</code> and <code>input.getAttribute('value')</code> returning one the current value and one the original default value.</em></p><p>This also applies to the <code>textarea</code> field, e.g.</p><pre><code>&lt;textarea&gt;Some text&lt;/textarea&gt;</code></pre><p>but instead</p><pre><code>&lt;textarea defaultValue={'Some text'} /&gt;</code></pre><p>For <code>select</code> fields, instead of using</p><pre><code>&lt;select&gt;
&lt;option value="x" selected&gt;
...
&lt;/option&gt;
&lt;/select&gt;</code></pre><p>use</p><pre><code class="language-jsx">&lt;select defaultValue="x"&gt;
&lt;option value="x"&gt;...&lt;/option&gt;
&lt;/select&gt;</code></pre><h4 id="a-more-consistent-onchange">A more consistent onChange</h4><p>Passing a function to the <code>onChange</code> attribute you can subscribe to events on form fields.</p><p>It works consistently across fields, even <code>radio</code>, <code>select</code> and <code>checkbox</code> input fields fire a <code>onChange</code> event.</p><p><code>onChange</code> also fires when typing a character into an <code>input</code> or <code>textarea</code> field.</p><h4 id="jsx-auto-escapes">JSX auto escapes</h4><p>To mitigate the ever present risk of XSS exploits, JSX forces automatic escaping in expressions.</p><p>This means that you might run into issues when using an HTML entity in a string expression.</p><p>You expect the following to print <code>© 2017</code>:</p><pre><code class="language-jsx">&lt;p&gt;{'© 2017'}&lt;/p&gt;</code></pre><p>But it’s not, it’s printing <code>© 2017</code> because the string is escaped.</p><p>To fix this you can either move the entities outside the expression:</p><pre><code>&lt;p&gt;© 2017&lt;/p&gt;</code></pre><p>or by using a constant that prints the Unicode representation corresponding to the HTML entity you need to print:</p><pre><code>&lt;p&gt;{'\u00A9 2017'}&lt;/p&gt;</code></pre><h4 id="white-space-in-jsx">White space in JSX</h4><p>To add white space in JSX there are 2 rules:</p><p><strong>Rule 1: Horizontal white space is trimmed to 1</strong></p><p>If you have white space between elements in the same line, it’s all trimmed to 1 white space.</p><pre><code>&lt;p&gt;Something becomes               this&lt;/p&gt;</code></pre><p>becomes</p><pre><code>&lt;p&gt;Something becomes this&lt;/p&gt;</code></pre><p><strong>Rule 2: Vertical white space is eliminated</strong></p><pre><code>&lt;p&gt;
Something
becomes
this
&lt;/p&gt;</code></pre><p>becomes</p><pre><code>&lt;p&gt;Somethingbecomesthis&lt;/p&gt;</code></pre><p>To fix this problem you need to explicitly add white space, by adding a space expression like this:</p><pre><code>&lt;p&gt;
Something
{' '}becomes
{' '}this
&lt;/p&gt;</code></pre><p>or by embedding the string in a space expression:</p><pre><code>&lt;p&gt;
Something
{' becomes '}
this
&lt;/p&gt;</code></pre><h4 id="adding-comments-in-jsx">Adding comments in JSX</h4><p>You can add comments to JSX by using the normal JavaScript comments inside an expression:</p><pre><code>&lt;p&gt;
{/* a comment */}
{
//another comment
}
&lt;/p&gt;</code></pre><h4 id="spread-attributes">Spread attributes</h4><p>In JSX a common operation is assigning values to attributes.</p><p>Instead of doing it manually, e.g.</p><pre><code>&lt;div&gt;
&lt;BlogPost title={data.title} date={data.date} /&gt;
&lt;/div&gt;</code></pre><p>you can pass</p><pre><code>&lt;div&gt;
&lt;BlogPost {...data} /&gt;
&lt;/div&gt;</code></pre><p>and the properties of the <code>data</code> object will be used as attributes automatically, thanks to the <em>ES6 spread operator</em>.</p><h4 id="how-to-loop-in-jsx">How to loop in JSX</h4><p>If you have a set of elements you need to loop upon to generate a JSX partial, you can create a loop, and then add JSX to an array:</p><pre><code>const elements = [] //..some array
const items = []
for (const [index, value] of elements.entries()) {
items.push(&lt;Element key={index} /&gt;)
}</code></pre><p>Now when rendering the JSX you can embed the <code>items</code> array simply by wrapping it in curly braces:</p><pre><code>const elements = ['one', 'two', 'three'];
const items = []
for (const [index, value] of elements.entries()) {
items.push(&lt;li key={index}&gt;{value}&lt;/li&gt;)
}
return (
&lt;div&gt;
{items}
&lt;/div&gt;
)</code></pre><p>You can do the same directly in the JSX, using <code>map</code> instead of a for-of loop:</p><pre><code>const elements = ['one', 'two', 'three'];
return (
&lt;ul&gt;
{elements.map((value, index) =&gt; {
return &lt;li key={index}&gt;{value}&lt;/li&gt;
})}
&lt;/ul&gt;
)</code></pre><h3 id="components">Components</h3><p>A component is one isolated piece of interface. For example in a typical blog homepage you might find the Sidebar component, and the Blog Posts List component. They are in turn composed of components themselves, so you could have a list of Blog post components, each for every blog post, and each with its own peculiar properties.</p><p>React makes it very simple: everything is a component.</p><p>Even plain HTML tags are component on their own, and they are added by default.</p><p>The next 2 lines are equivalent, they do the same thing. One with <strong><strong>JSX</strong></strong>, one without, by injecting <code>&lt;h1&gt;Hello World!&lt;/h1&gt;</code> into an element with id <code>app</code>.</p><pre><code>import React from 'react'
import ReactDOM from 'react-dom'
ReactDOM.render(&lt;h1&gt;Hello World!&lt;/h1&gt;, document.getElementById('app'))
ReactDOM.render(
React.DOM.h1(null, 'Hello World!'),
document.getElementById('app')
)</code></pre><p>See, <code>React.DOM</code> exposed us an <code>h1</code> component. Which other HTML tags are available? All of them! You can inspect what <code>React.DOM</code> offers by typing it in the Browser Console:</p><p>(the list is longer)</p><p>The built-in components are nice, but you’ll quickly outgrow them. What React excels in is letting us compose a UI by composing custom components.</p><h4 id="custom-components">Custom components</h4><p>There are 2 ways to define a component in React.</p><p>A function component:</p><pre><code>const BlogPostExcerpt = () =&gt; {
return (
&lt;div&gt;
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/div&gt;
)
}</code></pre><p>A class component:</p><pre><code>import React, { Component } from 'react'
class BlogPostExcerpt extends Component {
render() {
return (
&lt;div&gt;
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/div&gt;
)
}
}</code></pre><p>Up until recently, class components were the only way to define a component that had its own state, and could access the lifecycle methods so you could do things when the component was first rendered, updated or removed.</p><p>React Hooks changed this, so our function components are now much more powerful than ever and I believe we’ll see fewer and fewer class components in the future, although it will still be perfectly valid way to create components.</p><p>There is also a third syntax which uses the <code>ES5</code> syntax, without the classes:</p><pre><code>import React from 'react'
React.createClass({
render() {
return (
&lt;div&gt;
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/div&gt;
)
}
})</code></pre><p>You’ll rarely see this in modern, <code>&gt; ES6</code> codebases.</p><h3 id="state">State</h3><h4 id="setting-the-default-state-of-a-component">Setting the default state of a component</h4><p>In the Component constructor, initialize <code>this.state</code>. For example the BlogPostExcerpt component might have a <code>clicked</code> state:</p><pre><code>class BlogPostExcerpt extends Component {
constructor(props) {
super(props)
this.state = { clicked: false }
}
render() {
return (
&lt;div&gt;
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/div&gt;
)
}
}</code></pre><h4 id="accessing-the-state">Accessing the state</h4><p>The <em>clicked</em> state can be accessed by referencing <code>this.state.clicked</code>:</p><pre><code>class BlogPostExcerpt extends Component {
constructor(props) {
super(props)
this.state = { clicked: false }
}
render() {
return (
&lt;div&gt;
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;Clicked: {this.state.clicked}&lt;/p&gt;
&lt;/div&gt;
)
}
}</code></pre><h4 id="mutating-the-state">Mutating the state</h4><p>A state should never be mutated by using</p><pre><code>this.state.clicked = true</code></pre><p>Instead, you should always use <code>setState()</code> instead, passing it an object:</p><pre><code>this.setState({ clicked: true })</code></pre><p>The object can contain a subset, or a superset, of the state. Only the properties you pass will be mutated, the ones omitted will be left in their current state.</p><h4 id="why-you-should-always-use-setstate-">Why you should always use <code>setState()</code></h4><p>The reason is that using this method, React knows that the state has changed. It will then start the series of events that will lead to the Component being re-rendered, along with any <a href="https://flaviocopes.com/dom/" rel="noopener">DOM</a> update.</p><h4 id="unidirectional-data-flow-1">Unidirectional Data Flow</h4><p>A state is always owned by one Component. Any data that’s affected by this state can only affect Components below it: its children.</p><p>Changing the state on a Component will never affect its parent, or its siblings, or any other Component in the application: just its children.</p><p>This is the reason the state is often moved up in the Component tree.</p><h4 id="moving-the-state-up-in-the-tree">Moving the State Up in the Tree</h4><p>Because of the Unidirectional Data Flow rule, if two components need to share state, the state needs to be moved up to a common ancestor.</p><p>Many times the closest ancestor is the best place to manage the state, but it’s not a mandatory rule.</p><p>The state is passed down to the components that need that value via props:</p><pre><code>class Converter extends React.Component {
constructor(props) {
super(props)
this.state = { currency: '€' }
}
render() {
return (
&lt;div&gt;
&lt;Display currency={this.state.currency} /&gt;
&lt;CurrencySwitcher currency={this.state.currency} /&gt;
&lt;/div&gt;
)
}
}</code></pre><p>The state can be mutated by a child component by passing a mutating function down as a prop:</p><pre><code>class Converter extends React.Component {
constructor(props) {
super(props)
this.state = { currency: '€' }
}
handleChangeCurrency = event =&gt; {
this.setState({ currency: this.state.currency === '€' ? '$' : '€' })
}
render() {
return (
&lt;div&gt;
&lt;Display currency={this.state.currency} /&gt;
&lt;CurrencySwitcher
currency={this.state.currency}
handleChangeCurrency={this.handleChangeCurrency}
/&gt;
&lt;/div&gt;
)
}
}
const CurrencySwitcher = props =&gt; {
return (
&lt;button onClick={props.handleChangeCurrency}&gt;
Current currency is {props.currency}. Change it!
&lt;/button&gt;
)
}
const Display = props =&gt; {
return &lt;p&gt;Current currency is {props.currency}.&lt;/p&gt;
}</code></pre><h3 id="props">Props</h3><p>Props is how Components get their properties. Starting from the top component, every child component gets its props from the parent. In a function component, props is all it gets passed, and they are available by adding <code>props</code> as the function argument:</p><pre><code>const BlogPostExcerpt = props =&gt; {
return (
&lt;div&gt;
&lt;h1&gt;{props.title}&lt;/h1&gt;
&lt;p&gt;{props.description}&lt;/p&gt;
&lt;/div&gt;
)
}</code></pre><p>In a class component, props are passed by default. There is no need to add anything special, and they are accessible as <code>this.props</code> in a Component instance.</p><pre><code>import React, { Component } from 'react'
class BlogPostExcerpt extends Component {
render() {
return (
&lt;div&gt;
&lt;h1&gt;{this.props.title}&lt;/h1&gt;
&lt;p&gt;{this.props.description}&lt;/p&gt;
&lt;/div&gt;
)
}
}</code></pre><p>Passing props down to child components is a great way to pass values around in your application. A component either holds data (has state) or receives data through its props.</p><p>It gets complicated when:</p><ul><li>you need to access the state of a component from a child that’s several levels down (all the previous children need to act as a pass-through, even if they do not need to know the state, complicating things)</li><li>you need to access the state of a component from a completely unrelated component.</li></ul><h4 id="default-values-for-props">Default values for props</h4><p>If any value is not required we need to specify a default value for it if it’s missing when the Component is initialized.</p><pre><code>BlogPostExcerpt.propTypes = {
title: PropTypes.string,
description: PropTypes.string
}
BlogPostExcerpt.defaultProps = {
title: '',
description: ''
}</code></pre><p>Some tooling like <a href="https://flaviocopes.com/eslint/" rel="noopener">ESLint</a> have the ability to enforce defining the defaultProps for a Component with some propTypes not explicitly required.</p><h4 id="how-props-are-passed">How props are passed</h4><p>When initializing a component, pass the props in a way similar to HTML attributes:</p><pre><code>const desc = 'A description'
//...
&lt;BlogPostExcerpt title="A blog post" description={desc} /&gt;</code></pre><p>We passed the title as a plain string (something we can <em>only</em> do with strings!), and description as a variable.</p><h4 id="children">Children</h4><p>A special prop is <code>children</code>. That contains the value of anything that is passed in the <code>body</code> of the component, for example:</p><pre><code>&lt;BlogPostExcerpt title="A blog post" description="{desc}"&gt;
Something
&lt;/BlogPostExcerpt&gt;</code></pre><p>In this case, inside <code>BlogPostExcerpt</code> we could access "Something" by looking up <code>this.props.children</code>.</p><p>While Props allow a Component to receive properties from its parent, to be “instructed” to print some data for example, state allows a component to take on life itself, and be independent of the surrounding environment.</p><h3 id="presentational-vs-container-components">Presentational vs container components</h3><p>In React, components are often divided into 2 big buckets: <strong>presentational components</strong> and <strong>container components</strong>.</p><p>Each of those have their unique characteristics.</p><p>Presentational components are mostly concerned with generating some markup to be outputted.</p><p>They don’t manage any kind of state, except for state related the the presentation</p><p>Container components are mostly concerned with the “backend” operations.</p><p>They might handle the state of various sub-components. They might wrap several presentational components. They might interface with Redux.</p><p>As a way to simplify the distinction, we can say <strong>presentational components are concerned with the look</strong>, <strong>container components are concerned with making things work</strong>.</p><p>For example, this is a presentational component. It gets data from its props, and just focuses on showing an element:</p><pre><code>const Users = props =&gt; (
&lt;ul&gt;
{props.users.map(user =&gt; (
&lt;li&gt;{user}&lt;/li&gt;
))}
&lt;/ul&gt;
)</code></pre><p>On the other hand this is a container component. It manages and stores its own data, and uses the presentational component to display it.</p><pre><code>class UsersContainer extends React.Component {
constructor() {
this.state = {
users: []
}
}
componentDidMount() {
axios.get('/users').then(users =&gt;
this.setState({ users: users }))
)
}
render() {
return &lt;Users users={this.state.users} /&gt;
}
}</code></pre><h3 id="state-vs-props">State vs props</h3><p>In a React component, <strong>props</strong> are variables passed to it by its parent component. <strong>State</strong> on the other hand is still variables, but directly initialized and managed by the component.</p><p>The state can be initialized by props.</p><p>For example, a parent component might include a child component by calling</p><pre><code>&lt;ChildComponent /&gt;</code></pre><p>The parent can pass a prop by using this syntax:</p><pre><code>&lt;ChildComponent color=green /&gt;</code></pre><p>Inside the ChildComponent constructor we could access the prop:</p><pre><code>class ChildComponent extends React.Component {
constructor(props) {
super(props)
console.log(props.color)
}
}</code></pre><p>and any other method in this class can reference the props using <code>this.props</code>.</p><p>Props can be used to set the internal state based on a prop value in the constructor, like this:</p><pre><code>class ChildComponent extends React.Component {
constructor(props) {
super(props)
this.state.colorName = props.color
}
}</code></pre><p>Of course a component can also initialize the state without looking at props.</p><p>In this case there’s nothing useful going on, but imagine doing something different based on the prop value, probably setting a state value is best.</p><p>Props should never be changed in a child component, so if there’s something going on that alters some variable, that variable should belong to the component state.</p><p>Props are also used to allow child components to access methods defined in the parent component. This is a good way to centralize managing the state in the parent component, and avoid children having the need to have their own state.</p><p>Most of your components will just display some kind of information based on the props they received, and stay <strong>stateless</strong>.</p><h3 id="proptypes">PropTypes</h3><p>Since JavaScript is a dynamically typed language, we don’t really have a way to enforce the type of a variable at compile time, and if we pass invalid types, they will fail at runtime or give weird results if the types are compatible but not what we expect.</p><p>Flow and TypeScript help a lot, but React has a way to directly help with props types, and even before running the code, our tools (editors, linters) can detect when we are passing the wrong values:</p><pre><code>import PropTypes from 'prop-types'
import React from 'react'
class BlogPostExcerpt extends Component {
render() {
return (
&lt;div&gt;
&lt;h1&gt;{this.props.title}&lt;/h1&gt;
&lt;p&gt;{this.props.description}&lt;/p&gt;
&lt;/div&gt;
)
}
}
BlogPostExcerpt.propTypes = {
title: PropTypes.string,
description: PropTypes.string
}
export default BlogPostExcerpt</code></pre><h4 id="which-types-can-we-use">Which types can we use</h4><p>These are the fundamental types we can accept:</p><ul><li>PropTypes.array</li><li>PropTypes.bool</li><li>PropTypes.func</li><li>PropTypes.number</li><li>PropTypes.object</li><li>PropTypes.string</li><li>PropTypes.symbol</li></ul><p>We can accept one of two types:</p><pre><code>PropTypes.oneOfType([
PropTypes.string,
PropTypes.number
]),</code></pre><p>We can accept one of many values:</p><pre><code>PropTypes.oneOf(['Test1', 'Test2']),</code></pre><p>We can accept an instance of a class:</p><pre><code>PropTypes.instanceOf(Something)</code></pre><p>We can accept any React node:</p><pre><code>PropTypes.node</code></pre><p>or even any type at all:</p><pre><code>PropTypes.any</code></pre><p>Arrays have a special syntax that we can use to accept an array of a particular type:</p><pre><code class="language-jsx">PropTypes.arrayOf(PropTypes.string)</code></pre><p>We can compose object properties by using</p><pre><code>PropTypes.shape({
color: PropTypes.string,
fontSize: PropTypes.number
})</code></pre><h4 id="requiring-properties">Requiring properties</h4><p>Appending <code>isRequired</code> to any PropTypes option will cause React to return an error if that property is missing:</p><pre><code>PropTypes.arrayOf(PropTypes.string).isRequired,
PropTypes.string.isRequired,</code></pre><h3 id="react-fragment">React Fragment</h3><p>Notice how I wrap return values in a <code>div</code>. This is because a component can only return one single element, and if you want more than one, you need to wrap it with another container tag.</p><p>This, however, causes an unnecessary <code>div</code> in the output. You can avoid this by using <code>React.Fragment</code>:</p><pre><code>import React, { Component } from 'react'
class BlogPostExcerpt extends Component {
render() {
return (
&lt;React.Fragment&gt;
&lt;h1&gt;{this.props.title}&lt;/h1&gt;
&lt;p&gt;{this.props.description}&lt;/p&gt;
&lt;/React.Fragment&gt;
)
}
}</code></pre><p>which also has a very nice shorthand syntax <code>&lt;&gt;&lt;/&gt;</code> that is supported only in recent releases (and Babel 7+):</p><pre><code>import React, { Component } from 'react'
class BlogPostExcerpt extends Component {
render() {
return (
&lt;&gt;
&lt;h1&gt;{this.props.title}&lt;/h1&gt;
&lt;p&gt;{this.props.description}&lt;/p&gt;
&lt;/&gt;
)
}
}</code></pre><h3 id="events">Events</h3><p>React provides an easy way to manage events. Prepare to say goodbye to <code>addEventListener</code>.</p><p>In the previous article about the State you saw this example:</p><pre><code>const CurrencySwitcher = props =&gt; {
return (
&lt;button onClick={props.handleChangeCurrency}&gt;
Current currency is {props.currency}. Change it!
&lt;/button&gt;
)
}</code></pre><p>If you’ve been using JavaScript for a while, this is just like plain old <a href="https://flaviocopes.com/javascript-events/" rel="noopener">JavaScript event handlers</a>, except that this time you’re defining everything in JavaScript, not in your HTML, and you’re passing a function, not a string.</p><p>The actual event names are a little bit different because in React you use camelCase for everything, so <code>onclick</code> becomes <code>onClick</code>, <code>onsubmit</code> becomes <code>onSubmit</code>.</p><p>For reference, this is old school HTML with JavaScript events mixed in:</p><pre><code>&lt;button onclick="handleChangeCurrency()"&gt;...&lt;;/button&gt;</code></pre><h4 id="event-handlers">Event handlers</h4><p>It’s a convention to have event handlers defined as methods on the Component class:</p><pre><code>class Converter extends React.Component {
handleChangeCurrency = event =&gt; {
this.setState({ currency: this.state.currency === '€' ? '$' : '€' })
}
}</code></pre><p>All handlers receive an event object that adheres, cross-browser, to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/" rel="noopener">W3C UI Events spec</a>.</p><h4 id="bind-this-in-methods">Bind <code>this</code> in methods</h4><p>If you use class components, don’t forget to bind methods. The methods of ES6 classes by default are not bound. What this means is that <code>this</code> is not defined unless you define methods as arrow functions:</p><pre><code>class Converter extends React.Component {
handleClick = e =&gt; {
/* ... */
}
//...
}</code></pre><p>when using the the property initializer syntax with Babel (enabled by default in <code>create-react-app</code>), otherwise you need to bind it manually in the constructor:</p><pre><code>class Converter extends React.Component {
constructor(props) {
super(props)
this.handleClick = this.handleClick.bind(this)
}
handleClick(e) {}
}</code></pre><h3 id="the-events-reference">The events reference</h3><p>There are lots of events supported, here’s a summary list.</p><h4 id="clipboard">Clipboard</h4><ul><li>onCopy</li><li>onCut</li><li>onPaste</li></ul><h4 id="composition-1">Composition</h4><ul><li>onCompositionEnd</li><li>onCompositionStart</li><li>onCompositionUpdate</li></ul><h4 id="keyboard">Keyboard</h4><ul><li>onKeyDown</li><li>onKeyPress</li><li>onKeyUp</li></ul><h4 id="focus">Focus</h4><ul><li>onFocus</li><li>onBlur</li></ul><h4 id="form">Form</h4><ul><li>onChange</li><li>onInput</li><li>onSubmit</li></ul><h4 id="mouse">Mouse</h4><ul><li>onClick</li><li>onContextMenu</li><li>onDoubleClick</li><li>onDrag</li><li>onDragEnd</li><li>onDragEnter</li><li>onDragExit</li><li>onDragLeave</li><li>onDragOver</li><li>onDragStart</li><li>onDrop</li><li>onMouseDown</li><li>onMouseEnter</li><li>onMouseLeave</li><li>onMouseMove</li><li>onMouseOut</li><li>onMouseOver</li><li>onMouseUp</li></ul><h4 id="selection">Selection</h4><ul><li>onSelect</li></ul><h4 id="touch">Touch</h4><ul><li>onTouchCancel</li><li>onTouchEnd</li><li>onTouchMove</li><li>onTouchStart</li></ul><h4 id="ui">UI</h4><ul><li>onScroll</li></ul><h4 id="mouse-wheel">Mouse Wheel</h4><ul><li>onWheel</li></ul><h4 id="media">Media</h4><ul><li>onAbort</li><li>onCanPlay</li><li>onCanPlayThrough</li><li>onDurationChange</li><li>onEmptied</li><li>onEncrypted</li><li>onEnded</li><li>onError</li><li>onLoadedData</li><li>onLoadedMetadata</li><li>onLoadStart</li><li>onPause</li><li>onPlay</li><li>onPlaying</li><li>onProgress</li><li>onRateChange</li><li>onSeeked</li><li>onSeeking</li><li>onStalled</li><li>onSuspend</li><li>onTimeUpdate</li><li>onVolumeChange</li><li>onWaiting</li></ul><h4 id="image">Image</h4><ul><li>onLoad</li><li>onError</li></ul><h4 id="animation">Animation</h4><ul><li>onAnimationStart</li><li>onAnimationEnd</li><li>onAnimationIteration</li></ul><h4 id="transition">Transition</h4><ul><li>onTransitionEnd</li></ul><h3 id="lifecycle-events">Lifecycle Events</h3><p>React class components can have hooks for several lifecycle events.</p><blockquote><em>Hooks allow function components to access them too, in a different way.</em></blockquote><p>During the lifetime of a component, there’s a series of events that gets called, and to each event you can hook and provide custom functionality.</p><p>What hook is best for what functionality is something we’re going to see here.</p><p>First, there are 3 phases in a React component lifecycle:</p><ul><li>Mounting</li><li>Updating</li><li>Unmounting</li></ul><p>Let’s see those 3 phases in detail and the methods that get called for each.</p><h4 id="mounting">Mounting</h4><p>When mounting you have 4 lifecycle methods before the component is mounted in the DOM: the <code>constructor</code>, <code>getDerivedStateFromProps</code>, <code>render</code> and <code>componentDidMount</code>.</p><h4 id="constructor-function Array() { [native code] }1">Constructor</h4><p>The constructor is the first method that is called when mounting a component.</p><p>You usually use the constructor to set up the initial state using <code>this.state = ...</code>.</p><h4 id="getderivedstatefromprops-">getDerivedStateFromProps()</h4><p>When the state depends on props, <code>getDerivedStateFromProps</code> can be used to update the state based on the props value.</p><p>It was added in React 16.3, aiming to replace the <code>componentWillReceiveProps</code> deprecated method.</p><p>In this method you haven’t access to <code>this</code> as it's a static method.</p><p>It’s a pure method, so it should not cause side effects and should return the same output when called multiple times with the same input.</p><p>Returns an object with the updated elements of the state (or null if the state does not change)</p><h4 id="render-">render()</h4><p>From the render() method you return the JSX that builds the component interface.</p><p>It’s a pure method, so it should not cause side effects and should return the same output when called multiple times with the same input.</p><h4 id="componentdidmount-">componentDidMount()</h4><p>This method is the one that you will use to perform API calls, or process operations on the DOM.</p><h4 id="updating">Updating</h4><p>When updating you have 5 lifecycle methods before the component is mounted in the DOM: the <code>getDerivedStateFromProps</code>, <code>shouldComponentUpdate</code>, <code>render</code>, <code>getSnapshotBeforeUpdate</code> and <code>componentDidUpdate</code>.</p><h4 id="getderivedstatefromprops--1">getDerivedStateFromProps()</h4><p>See the above description for this method.</p><h4 id="shouldcomponentupdate-">shouldComponentUpdate()</h4><p>This method returns a boolean, <code>true</code> or <code>false</code>. You use this method to tell React if it should go on with the rerendering, and defaults to <code>true</code>. You will return <code>false</code> when rerendering is expensive and you want to have more control on when this happens.</p><h4 id="render--1">render()</h4><p>See the above description for this method.</p><h4 id="getsnapshotbeforeupdate-">getSnapshotBeforeUpdate()</h4><p>In this method you have access to the props and state of the previous render, and of the current render.</p><p>Its use cases are very niche, and it’s probably the one that you will use less.</p><h4 id="componentdidupdate-">componentDidUpdate()</h4><p>This method is called when the component has been updated in the DOM. Use this to run any 3rd party DOM API or call APIs that must be updated when the DOM changes.</p><p>It corresponds to the <code>componentDidMount()</code> method from the mounting phase.</p><h4 id="unmounting">Unmounting</h4><p>In this phase we only have one method, <code>componentWillUnmount</code>.</p><h4 id="componentwillunmount-">componentWillUnmount()</h4><p>The method is called when the component is removed from the DOM. Use this to do any sort of cleanup you need to perform.</p><h4 id="legacy">Legacy</h4><p>If you are working on an app that uses <code>componentWillMount</code>, <code>componentWillReceiveProps</code> or <code>componentWillUpdate</code>, those were deprecated in React 16.3 and you should migrate to other lifecycle methods.</p><h3 id="forms-in-react">Forms in React</h3><p>Forms are one of the few HTML elements that are interactive by default.</p><p>They were designed to allow the user to interact with a page.</p><p>Common uses of forms?</p><ul><li>Search</li><li>Contact forms</li><li>Shopping carts checkout</li><li>Login and registration</li><li>and more!</li></ul><p>Using React we can make our forms much more interactive and less static.</p><p>There are two main ways of handling forms in React, which differ on a fundamental level: how data is managed.</p><ul><li>if the data is handled by the DOM, we call them <strong>uncontrolled components</strong></li><li>if the data is handled by the components we call them <strong>controlled components</strong></li></ul><p>As you can imagine, controlled components is what you will use most of the time. The component state is the single source of truth, rather than the DOM. Some form fields are inherently uncontrolled because of their behavior, like the <code>&lt;input type="file"&gt;</code> field.</p><p>When an element state changes in a form field managed by a component, we track it using the <code>onChange</code> attribute.</p><pre><code class="language-jsx">class Form extends React.Component {
constructor(props) {
super(props)
this.state = { username: '' }
}
handleChange(event) {}
render() {
return (
&lt;form&gt;
Username:
&lt;input
type="text"
value={this.state.username}
onChange={this.handleChange}
/&gt;
&lt;/form&gt;
)
}
}</code></pre><p>In order to set the new state, we must bind <code>this</code> to the <code>handleChange</code> method, otherwise <code>this</code> is not accessible from within that method:</p><pre><code>class Form extends React.Component {
constructor(props) {
super(props)
this.state = { username: '' }
this.handleChange = this.handleChange.bind(this)
}
handleChange(event) {
this.setState({ value: event.target.value })
}
render() {
return (
&lt;form&gt;
&lt;input
type="text"
value={this.state.username}
onChange={this.handleChange}
/&gt;
&lt;/form&gt;
)
}
}</code></pre><p>Similarly, we use the <code>onSubmit</code> attribute on the form to call the <code>handleSubmit</code> method when the form is submitted:</p><pre><code>class Form extends React.Component {
constructor(props) {
super(props)
this.state = { username: '' }
this.handleChange = this.handleChange.bind(this)
this.handleSubmit = this.handleSubmit.bind(this)
}
handleChange(event) {
this.setState({ value: event.target.value })
}
handleSubmit(event) {
alert(this.state.username)
event.preventDefault()
}
render() {
return (
&lt;form onSubmit={this.handleSubmit}&gt;
&lt;input
type="text"
value={this.state.username}
onChange={this.handleChange}
/&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
)
}
}</code></pre><p>Validation in a form can be handled in the <code>handleChange</code> method: you have access to the old value of the state, and the new one. You can check the new value and if not valid reject the updated value (and communicate it in some way to the user).</p><p>HTML Forms are inconsistent. They have a long history, and it shows. React however makes things more consistent for us, and you can get (and update) fields using its <code>value</code> attribute.</p><p>Here’s a <code>textarea</code>, for example:</p><pre><code>&lt;textarea value={this.state.address} onChange={this.handleChange} /&gt;</code></pre><p>The same goes for the <code>select</code> tag:</p><pre><code class="language-jsx">&lt;select value="{this.state.age}" onChange="{this.handleChange}"&gt;
&lt;option value="teen"&gt;Less than 18&lt;/option&gt;
&lt;option value="adult"&gt;18+&lt;/option&gt;
&lt;/select&gt;</code></pre><p>Previously we mentioned the <code>&lt;input type="file"&gt;</code> field. That works a bit differently.</p><p>In this case you need to get a reference to the field by assigning the <code>ref</code> attribute to a property defined in the constructor with <code>React.createRef()</code>, and use that to get the value of it in the submit handler:</p><pre><code class="language-jsx">class FileInput extends React.Component {
constructor(props) {
super(props)
this.curriculum = React.createRef()
this.handleSubmit = this.handleSubmit.bind(this)
}
handleSubmit(event) {
alert(this.curriculum.current.files[0].name)
event.preventDefault()
}
render() {
return (
&lt;form onSubmit={this.handleSubmit}&gt;
&lt;input type="file" ref={this.curriculum} /&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
)
}
}</code></pre><p>This is the <strong>uncontrolled components</strong> way. The state is stored in the DOM rather than in the component state (notice we used <code>this.curriculum</code> to access the uploaded file, and have not touched the <code>state</code>.</p><p>I know what you’re thinking — beyond those basics, there must be a library that simplifies all this form handling stuff and automates validation, error handling and more, right? There is a great one, <a href="https://github.com/jaredpalmer/formik" rel="noopener">Formik</a>.</p><h3 id="reference-a-dom-element">Reference a DOM element</h3><p>React is great at abstracting away the DOM from you when building apps.</p><p>But what if you want to access the DOM element that a React component represents?</p><p>Maybe you have to add a library that interacts directly with the DOM like a chart library, maybe you need to call some DOM API, or add focus on an element.</p><blockquote><em>Whatever the reason is, a good practice is making sure there’s no other way of doing so without accessing the DOM directly.</em></blockquote><p>In the JSX of your component, you can assign the reference of the DOM element to a component property using this attribute:</p><pre><code>ref={el =&gt; this.someProperty = el}</code></pre><p>Put this into context, for example with a <code>button</code> element:</p><pre><code>&lt;button ref={el =&gt; (this.button = el)} /&gt;</code></pre><p><code>button</code> refers to a property of the component, which can then be used by the component's lifecycle methods (or other methods) to interact with the DOM:</p><pre><code>class SomeComponent extends Component {
render() {
return &lt;button ref={el =&gt; (this.button = el)} /&gt;
}
}</code></pre><p>In a function component the mechanism is the same, you just avoid using <code>this</code> (since it does not point to the component instance) and use a property instead:</p><pre><code class="language-jsx">function SomeComponent() {
let button
return &lt;button ref={el =&gt; (button = el)} /&gt;
}</code></pre><h3 id="server-side-rendering">Server side rendering</h3><p><strong>Server Side Rendering</strong>, also called <strong>SSR</strong>, is the ability of a JavaScript application to render on the server rather than in the browser.</p><p>Why would we ever want to do so?</p><ul><li>it allows your site to have a faster first page load time, which is the key to a good user experience</li><li>it is essential for SEO: search engines cannot (yet?) efficiently and correctly index applications that exclusively render client-side. Despite the latest improvements to indexing in Google, there are other search engines too, and Google is not perfect at it in any case. Also, Google favors sites with fast load times, and having to load client-side is not good for speed</li><li>it’s great when people share a page of your site on social media, as they can easily gather the metadata needed to nicely share the link (images, title, description..)</li></ul><p>Without Server Side Rendering, all your server ships is an HTML page with no body, just some script tags that are then used by the browser to render the application.</p><p>Client-rendered apps are great at any subsequent user interaction after the first page load. Server Side Rendering allows us to get the sweet spot in the middle of client-rendered apps and backend-rendered apps: the page is generated server-side, but all interactions with the page once it’s been loaded are handled client-side.</p><p>However Server Side Rendering has its drawback too:</p><ul><li>it’s fair to say that a simple SSR proof of concept is simple, but the complexity of SSR can grow with the complexity of your application</li><li>rendering a big application server-side can be quite resource-intensive, and under heavy load it could even provide a slower experience than client-side rendering, since you have a single bottleneck</li></ul><h3 id="a-very-simplistic-example-of-what-it-takes-to-server-side-render-a-react-app">A very simplistic example of what it takes to Server-Side render a React app</h3><p>SSR setups can grow very, very complex and most tutorials will bake in Redux, React Router and many other concepts from the start.</p><p>To understand how SSR works, let’s start from the basics to implement a proof of concept.</p><blockquote><em>Feel free to skip this paragraph if you just want to look into the libraries that provide SSR and not bother with the ground work</em></blockquote><p>To implement basic SSR we’re going to use Express.</p><blockquote><em>If you are new to Express, or need some catch-up, check out my free Express Handbook here: <a href="https://flaviocopes.com/page/ebooks/" rel="noopener">https://flaviocopes.com/page/ebooks/</a>.</em></blockquote><p>Warning: the complexity of SSR can grow with the complexity of your application. This is the bare minimum setup to render a basic React app. For more complex needs you might need to do a bit more work or also check out SSR libraries for React.</p><p>I assume you started a React app with <code>create-react-app</code>. If you are just trying, install one now using <code>npx create-react-app ssr</code>.</p><p>Go to the main app folder with the terminal, then run:</p><pre><code class="language-bash">npm install express</code></pre><p>You have a set of folders in your app directory. Create a new folder called <code>server</code>, then go into it and create a file named <code>server.js</code>.</p><p>Following the <code>create-react-app</code> conventions, the app lives in the <code>src/App.js</code> file. We're going to load that component, and render it to a string using <a href="https://reactjs.org/docs/react-dom-server.html" rel="noopener">ReactDOMServer.renderToString()</a>, which is provided by <code>react-dom</code>.</p><p>You get the contents of the <code>./build/index.html</code> file, and replace the <code>&lt;div id="root"&gt;&lt;/div&gt;</code>placeholder, which is the tag where the application hooks by default, with <code>`&lt;div id="root"&gt;\${ReactDOMServer.renderToString(&lt;App /&gt;)}&lt;/div&gt;</code>.</p><p>All the content inside the <code>build</code> folder is going to be served as-is, statically by Express.</p><pre><code>import path from 'path'
import fs from 'fs'
import express from 'express'
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import App from '../src/App'
const PORT = 8080
const app = express()
const router = express.Router()
const serverRenderer = (req, res, next) =&gt; {
fs.readFile(path.resolve('./build/index.html'), 'utf8', (err, data) =&gt; {
if (err) {
console.error(err)
return res.status(500).send('An error occurred')
}
return res.send(
data.replace(
'&lt;div id="root"&gt;&lt;/div&gt;',
`&lt;div id="root"&gt;${ReactDOMServer.renderToString(&lt;App /&gt;)}&lt;/div&gt;`
)
)
})
}
router.use('^/$', serverRenderer)
router.use(
express.static(path.resolve(__dirname, '..', 'build'), { maxAge: '30d' })
)
// tell the app to use the above rules
app.use(router)
// app.use(express.static('./build'))
app.listen(PORT, () =&gt; {
console.log(`SSR running on port ${PORT}`)
})</code></pre><p>Now, in the client application, in your <code>src/index.js</code>, instead of calling <code>ReactDOM.render()</code>:</p><pre><code>ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))</code></pre><p>call <code><a href="https://reactjs.org/docs/react-dom.html#hydrate" rel="noopener">ReactDOM.hydrate()</a></code>, which is the same but has the additional ability to attach event listeners to existing markup once React loads:</p><pre><code>ReactDOM.hydrate(&lt;App /&gt;, document.getElementById('root'))</code></pre><p>All the Node.js code needs to be transpiled by Babel, as server-side Node.js code does not know anything about JSX, nor ES Modules (which we use for the <code>include</code> statements).</p><p>Install these 3 packages:</p><pre><code class="language-bash">npm install @babel/register @babel/preset-env @babel/preset-react ignore-styles express</code></pre><p><code><a href="https://www.npmjs.com/package/ignore-styles" rel="noopener">ignore-styles</a></code> is a Babel utility that will tell it to ignore CSS files imported using the <code>import</code> syntax.</p><p>Let’s create an entry point in <code>server/index.js</code>:</p><pre><code>require('ignore-styles')
require('@babel/register')({
ignore: [/(node_modules)/],
presets: ['@babel/preset-env', '@babel/preset-react']
})
require('./server')</code></pre><p>Build the React application, so that the build/ folder is populated:</p><pre><code class="language-bash">npm run build</code></pre><p>and let’s run this:</p><pre><code class="language-bash">node server/index.js</code></pre><p>I said this is a simplistic approach, and it is:</p><ul><li>it does not handle rendering images correctly when using imports, which need Webpack in order to work (and which complicates the process a lot)</li><li>it does not handle page header metadata, which is essential for SEO and social sharing purposes (among other things)</li></ul><p>So while this is a good example of using <code>ReactDOMServer.renderToString()</code> and <code>ReactDOM.hydrate</code> to get this basic server-side rendering, it's not enough for real world usage.</p><h4 id="server-side-rendering-using-libraries">Server Side Rendering using libraries</h4><p>SSR is hard to do right, and React has no de-facto way to implement it.</p><p>It’s still very much debatable if it’s worth the trouble, complication and overhead to get the benefits, rather than using a different technology to serve those pages. <a href="https://www.reddit.com/r/reactjs/comments/7o6oj6/serverside_rendering_not_worth_it/" rel="noopener">This discussion on Reddit</a> has lots of opinions in that regard.</p><p>When Server Side Rendering is an important matter, my suggestion is to rely on pre-made libraries and tools that have had this goal in mind since the beginning.</p><p>In particular, I suggest <strong>Next.js</strong> and <strong>Gatsby</strong>, two projects we’ll see later on.</p><h3 id="the-context-api">The Context API</h3><p>The Context API is a neat way to pass state across the app without having to use props. It was introduced to allow you to pass state (and enable the state to update) across the app, without having to use props for it.</p><p>The React team suggests to stick to props if you have just a few levels of children to pass, because it’s still a much less complicated API than the Context API.</p><p>In many cases, it enables us to avoid using Redux, simplifying our apps a lot, and also learning how to use React.</p><p>How does it work?</p><p>You create a context using <code>React.createContext()</code>, which returns a Context object:</p><pre><code>const { Provider, Consumer } = React.createContext()</code></pre><p>Then you create a wrapper component that returns a <strong>Provider</strong> component, and you add as children all the components from which you want to access the context:</p><pre><code>class Container extends React.Component {
constructor(props) {
super(props)
this.state = {
something: 'hey'
}
}
render() {
return (
&lt;Provider value={{ state: this.state }}&gt;{this.props.children}&lt;/Provider&gt;
)
}
}
class HelloWorld extends React.Component {
render() {
return (
&lt;Container&gt;
&lt;Button /&gt;
&lt;/Container&gt;
)
}
}</code></pre><p>I used Container as the name of this component because this will be a global provider. You can also create smaller contexts.</p><p>Inside a component that’s wrapped in a Provider, you use a <strong>Consumer</strong> component to make use of the context:</p><pre><code>class Button extends React.Component {
render() {
return (
&lt;Consumer&gt;
{context =&gt; &lt;button&gt;{context.state.something}&lt;/button&gt;}
&lt;/Consumer&gt;
)
}
}</code></pre><p>You can also pass functions into a Provider value, and those functions will be used by the Consumer to update the context state:</p><pre><code>&lt;Provider value={{
state: this.state,
updateSomething: () =&gt; this.setState({something: 'ho!'})
{this.props.children}
&lt;/Provider&gt;
/* ... */
&lt;Consumer&gt;
{(context) =&gt; (
&lt;button onClick={context.updateSomething}&gt;{context.state.something}&lt;/button&gt;
)}
&lt;/Consumer&gt;</code></pre><p>You can see this in action <a href="https://glitch.com/edit/#!/flavio-react-context-api-example?path=app/components/HelloWorld.jsx" rel="noopener">in this Glitch</a>.</p><p>You can create multiple contexts, to make your state distributed across components, yet expose it and make it reachable by any component you want.</p><p>When using multiple files, you create the content in one file, and import it in all the places you use it:</p><pre><code>//context.js
import React from 'react'
export default React.createContext()
//component1.js
import Context from './context'
//... use Context.Provider
//component2.js
import Context from './context'
//... use Context.Consumer</code></pre><h3 id="higher-order-components-1">Higher order components</h3><p>You might be familiar with Higher Order Functions in JavaScript. Those are functions that accept functions as arguments, and/or return functions.</p><p>Two examples of those functions are <code>Array.map()</code> or <code>Array.filter()</code>.</p><p>In React, we extend this concept to components, and so we have a <strong>Higher Order Component (HOC)</strong>when the component accepts a component as input and returns a component as its output.</p><p>In general, higher order components allow you to create code that’s composable and reusable, and also more encapsulated.</p><p>We can use a HOC to add methods or properties to the state of a component, or a Redux store for example.</p><p>You might want to use Higher Order Components when you want to enhance an existing component, operate on the state or props, or its rendered markup.</p><p>There is a convention of prepending a Higher Order Component with the <code>with</code> string (it's a convention, so it's not mandatory), so if you have a <code>Button</code> component, its HOC counterpart should be called <code>withButton</code>.</p><p>Let’s create one.</p><p>The simplest example ever of a HOC is one that simply returns the component unaltered:</p><pre><code>const withElement = Element =&gt; () =&gt; &amp;lt;Element /&gt;</code></pre><p>Let’s make this a little bit more useful and add a property to that button, in addition to all the props it already came with, the color:</p><pre><code>const withColor = Element =&gt; props =&gt; &lt;Element {...props} color="red" /&gt;</code></pre><p>We use this HOC in a component JSX:</p><pre><code>const Button = () =&gt; {
return &lt;button&gt;test&lt;/button&gt;
}
const ColoredButton = withColor(Button)</code></pre><p>and we can finally render the ColoredButton component in our app JSX:</p><pre><code class="language-jsx">function App() {
return (
&lt;div className="App"&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
&lt;ColoredButton /&gt;
&lt;/div&gt;
)
}</code></pre><p>This is a very simple example but hopefully you can get the gist of HOCs before applying those concepts to more complex scenarios.</p><h3 id="render-props">Render Props</h3><p>A common pattern used to share state between components is to use the <code>children</code> prop.</p><p>Inside a component JSX you can render <code>{this.props.children}</code> which automatically injects any JSX passed in the parent component as a children:</p><pre><code>class Parent extends React.Component {
constructor(props) {
super(props)
this.state = {
/*...*/
}
}
render() {
return &lt;div&gt;{this.props.children}&lt;/div&gt;
}
}
const Children1 = () =&gt; {}
const Children2 = () =&gt; {}
const App = () =&gt; (
&lt;Parent&gt;
&lt;Children1 /&gt;
&lt;Children2 /&gt;
&lt;/Parent&gt;
)</code></pre><p>However, there is a problem here: the state of the parent component cannot be accessed from the children.</p><p>To be able to share the state, you need to use a render prop component, and instead of passing components as children of the parent component, you pass a function which you then execute in <code>{this.props.children()}</code>. The function can accept arguments:</p><pre><code>class Parent extends React.Component {
constructor(props) {
super(props)
this.state = { name: 'Flavio' }
}
render() {
return &lt;div&gt;{this.props.children(this.state.name)}&lt;/div&gt;
}
}
const Children1 = props =&gt; {
return &lt;p&gt;{props.name}&lt;/p&gt;
}
const App = () =&gt; &lt;Parent&gt;{name =&gt; &lt;Children1 name={name} /&gt;}&lt;/Parent&gt;</code></pre><p>Instead of using the <code>children</code> prop, which has a very specific meaning, you can use any prop, and so you can use this pattern multiple times on the same component:</p><pre><code>class Parent extends React.Component {
constructor(props) {
super(props)
this.state = { name: 'Flavio', age: 35 }
}
render() {
return (
&lt;div&gt;
&lt;p&gt;Test&lt;/p&gt;
{this.props.someprop1(this.state.name)}
{this.props.someprop2(this.state.age)}
&lt;/div&gt;
)
}
}
const Children1 = props =&gt; {
return &lt;p&gt;{props.name}&lt;/p&gt;
}
const Children2 = props =&gt; {
return &lt;p&gt;{props.age}&lt;/p&gt;
}
const App = () =&gt; (
&lt;Parent
someprop1={name =&gt; &lt;Children1 name={name} /&gt;}
someprop2={age =&gt; &lt;Children2 age={age} /&gt;}
/&gt;
)
ReactDOM.render(&lt;App /&gt;, document.getElementById('app'))</code></pre><h3 id="hooks">Hooks</h3><p>Hooks is a feature that will be introduced in React 16.7, and is going to change how we write React apps in the future.</p><p>Before Hooks appeared, some key things in components were only possible using class components: having their own state, and using lifecycle events. Function components, lighter and more flexible, were limited in functionality.</p><p><strong>Hooks allow function components to have state and to respond to lifecycle events</strong> too, and kind of make class components obsolete. They also allow function components to have a good way to handle events.</p><h4 id="access-state">Access state</h4><p>Using the <code>useState()</code> API, you can create a new state variable, and have a way to alter it. <code>useState()</code> accepts the initial value of the state item and returns an array containing the state variable, and the function you call to alter the state. Since it returns an array we use <a href="https://flaviocopes.com/es6/#destructuring-assignments" rel="noopener">array destructuring</a> to access each individual item, like this: <code>const [count, setCount] = useState(0)</code></p><p>Here’s a practical example:</p><pre><code>import { useState } from 'react'
const Counter = () =&gt; {
const [count, setCount] = useState(0)
return (
&lt;div&gt;
&lt;p&gt;You clicked {count} times&lt;/p&gt;
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
&lt;/div&gt;
)
}
ReactDOM.render(&lt;Counter /&gt;, document.getElementById('app'))</code></pre><p>You can add as many <code>useState()</code> calls you want, to create as many state variables as you want. Just make sure you call it in the top level of a component (not in an <code>if</code> or in any other block).</p><p><a href="https://codepen.io/flaviocopes/pen/maVPKa" rel="noopener">Example on Codepen</a></p><h4 id="access-lifecycle-hooks">Access lifecycle hooks</h4><p>Another very important feature of Hooks is allowing function components to have access to the lifecycle hooks.</p><p>Using class components you can register a function on the <code>componentDidMount</code>, <code>componentWillUnmount</code> and <code>componentDidUpdate</code> events, and those will serve many use cases, from variables initialization to API calls to cleanup.</p><p>Hooks provide the <code>useEffect()</code> API. The call accepts a function as argument.</p><p>The function runs when the component is first rendered, and on every subsequent re-render/update. React first updates the DOM, then calls any function passed to <code>useEffect()</code>. All without blocking the UI rendering even on blocking code, unlike the old <code>componentDidMount</code> and <code>componentDidUpdate</code>, which makes our apps feel faster.</p><p>Example:</p><pre><code>const { useEffect, useState } = React
const CounterWithNameAndSideEffect = () =&gt; {
const [count, setCount] = useState(0)
const [name, setName] = useState('Flavio')
useEffect(() =&gt; {
console.log(`Hi ${name} you clicked ${count} times`)
})
return (
&lt;div&gt;
&lt;p&gt;
Hi {name} you clicked {count} times
&lt;/p&gt;
&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
&lt;button onClick={() =&gt; setName(name === 'Flavio' ? 'Roger' : 'Flavio')}&gt;
Change name
&lt;/button&gt;
&lt;/div&gt;
)
}
ReactDOM.render(
&lt;CounterWithNameAndSideEffect /&gt;,
document.getElementById('app')
)</code></pre><p>The same <code>componentWillUnmount</code> job can be achieved by optionally <strong>returning</strong> a function from our <code>useEffect()</code> parameter:</p><pre><code>useEffect(() =&gt; {
console.log(`Hi ${name} you clicked ${count} times`)
return () =&gt; {
console.log(`Unmounted`)
}
})</code></pre><p><code>useEffect()</code> can be called multiple times, which is nice to separate unrelated logic (something that plagues the class component lifecycle events).</p><p>Since the <code>useEffect()</code> functions are run on every subsequent re-render/update, we can tell React to skip a run, for performance purposes, by adding a second parameter which is an array that contains a list of state variables to watch for. React will only re-run the side effect if one of the items in this array changes.</p><pre><code>useEffect(
() =&gt; {
console.log(`Hi ${name} you clicked ${count} times`)
},
[name, count]
)</code></pre><p>Similarly you can tell React to only execute the side effect once (at mount time), by passing an empty array:</p><pre><code>useEffect(() =&gt; {
console.log(`Component mounted`)
}, [])</code></pre><p><code>useEffect()</code> is great for adding logs, accessing 3rd party APIs and much more.</p><p><a href="https://codepen.io/flaviocopes/pen/WLrxXp" rel="noopener">Example on Codepen</a></p><h4 id="handle-events-in-function-components">Handle events in function components</h4><p>Before hooks, you either used class components, or you passed an event handler using props.</p><p>Now we can use the <code>useCallback()</code> built-in API:</p><pre><code>const Button = () =&gt; {
const handleClick = useCallback(() =&gt; {
//...do something
})
return &lt;button onClick={handleClick} /&gt;
}</code></pre><p>Any parameter used inside the function must be passed through a second parameter to <code>useCallback()</code>, in an array:</p><pre><code>const Button = () =&gt; {
let name = '' //... add logic
const handleClick = useCallback(
() =&gt; {
//...do something
},
[name]
)
return &lt;button onClick={handleClick} /&gt;
}</code></pre><h4 id="enable-cross-component-communication-using-custom-hooks">Enable cross-component communication using custom hooks</h4><p>The ability to write your own hooks is the feature that is going to significantly alter how you write React apps in the future.</p><p>Using custom hooks you have one more way to share state and logic between components, adding a significant improvement to the patterns of render props and higher order components. Which are still great, but now with custom hooks have less relevance in many use cases.</p><p>How do you create a custom hook?</p><p>A hook is just a function that conventionally starts with <code>use</code>. It can accept an arbitrary number of arguments, and return anything it wants.</p><p>Examples:</p><pre><code>const useGetData() {
//...
return data
}</code></pre><p>or</p><pre><code>const useGetUser(username) {
//...const user = fetch(...)
//...const userData = ...
return [user, userData]
}</code></pre><p>In your own components, you can use the hook like this:</p><pre><code>const MyComponent = () =&gt; {
const data = useGetData()
const [user, userData] = useGetUser('flavio')
//...
}</code></pre><p>When exactly to add hooks instead of regular functions should be determined on a use case basis, and only experience will tell.</p><h3 id="code-splitting">Code splitting</h3><p>Modern JavaScript applications can be quite huge in terms of bundle size. You don’t want your users to have to download a 1MB package of JavaScript (your code and the libraries you use) just to load the first page, right? But this is what happens by default when you ship a modern Web App built with Webpack bundling.</p><p>That bundle will contain code that might never run because the user only stops on the login page and never sees the rest of your app.</p><p>Code splitting is the practice of only loading the JavaScript you need the moment when you need it.</p><p>This improves:</p><ul><li>the performance of your app</li><li>the impact on memory, and so battery usage on mobile devices</li><li>the downloaded KiloBytes (or MegaBytes) size</li></ul><p>React 16.6.0, released in October 2018, introduced a way of performing code splitting that should take the place of every previously used tool or library: <strong>React.lazy</strong> and <strong>Suspense</strong>.</p><p><code>React.lazy</code> and <code>Suspense</code> form the perfect way to lazily load a dependency and only load it when needed.</p><p>Let’s start with <code>React.lazy</code>. You use it to import any component:</p><pre><code>import React from 'react'
const TodoList = React.lazy(() =&gt; import('./TodoList'))
export default () =&gt; {
return (
&lt;div&gt;
&lt;TodoList /&gt;
&lt;/div&gt;
)
}</code></pre><p>the TodoList component will be dynamically added to the output as soon as it’s available. Webpack will create a separate bundle for it, and will take care of loading it when necessary.</p><p><code>Suspense</code> is a component that you can use to wrap any lazily loaded component:</p><pre><code>import React from 'react'
const TodoList = React.lazy(() =&gt; import('./TodoList'))
export default () =&gt; {
return (
&lt;div&gt;
&lt;React.Suspense&gt;
&lt;TodoList /&gt;
&lt;/React.Suspense&gt;
&lt;/div&gt;
)
}</code></pre><p>It takes care of handling the output while the lazy loaded component is fetched and rendered.</p><p>Use its <code>fallback</code> prop to output some JSX or a component output:</p><pre><code>...
&lt;React.Suspense fallback={&lt;p&gt;Please wait&lt;/p&gt;}&gt;
&lt;TodoList /&gt;
&lt;/React.Suspense&gt;
...</code></pre><p>All this plays well with React Router:</p><pre><code class="language-jsx">import React from 'react'
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'
const TodoList = React.lazy(() =&gt; import('./routes/TodoList'))
const NewTodo = React.lazy(() =&gt; import('./routes/NewTodo'))
const App = () =&gt; (
&lt;Router&gt;
&lt;React.Suspense fallback={&lt;p&gt;Please wait&lt;/p&gt;}&gt;
&lt;Switch&gt;
&lt;Route exact path="/" component={TodoList} /&gt;
&lt;Route path="/new" component={NewTodo} /&gt;
&lt;/Switch&gt;
&lt;/React.Suspense&gt;
&lt;/Router&gt;
)</code></pre><h3 id="section-4-practical-examples">SECTION 4: PRACTICAL EXAMPLES</h3><p>2 very simple applications to explain some of the concepts introduced so far.</p><h3 id="a-very-simple-example-of-building-a-counter-in-react">A very simple example of building a counter in React</h3><p>In this short example we’ll build a very simple example of a counter in React, applying many of the concepts and theory outlined before.</p><p>Let’s use Codepen for this. We start by forking the <a href="https://codepen.io/flaviocopes/pen/VqeaxB" rel="noopener">React template pen</a>.</p><blockquote><em>In Codepen we don’t need to import React and ReactDOM as they are already added in the scope.</em></blockquote><p>We show the count in a div, and we add a few buttons to increment this count:</p><pre><code>const Button = ({ increment }) =&gt; {
return &lt;button&gt;+{increment}&lt;/button&gt;
}
const App = () =&gt; {
let count = 0
return (
&lt;div&gt;
&lt;Button increment={1} /&gt;
&lt;Button increment={10} /&gt;
&lt;Button increment={100} /&gt;
&lt;Button increment={1000} /&gt;
&lt;span&gt;{count}&lt;/span&gt;
&lt;/div&gt;
)
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('app'))</code></pre><p>Let’s add the functionality that lets us change the count by clicking the buttons, by adding a <code>onClickFunction</code> prop:</p><pre><code class="language-jsx">const Button = ({ increment, onClickFunction }) =&gt; {
const handleClick = () =&gt; {
onClickFunction(increment)
}
return &lt;button onClick={handleClick}&gt;+{increment}&lt;/button&gt;
}
const App = () =&gt; {
let count = 0
const incrementCount = increment =&gt; {
//TODO
}
return (
&lt;div&gt;
&lt;Button increment={1} onClickFunction={incrementCount} /&gt;
&lt;Button increment={10} onClickFunction={incrementCount} /&gt;
&lt;Button increment={100} onClickFunction={incrementCount} /&gt;
&lt;Button increment={1000} onClickFunction={incrementCount} /&gt;
&lt;span&gt;{count}&lt;/span&gt;
&lt;/div&gt;
)
}
ReactDOM.render(&lt;App /&gt;, document.getElementById('app'))</code></pre><p>Here, every Button element has 2 props: <code>increment</code> and <code>onClickFunction</code>. We create 4 different buttons, with 4 increment values: 1, 10, 100, 1000.</p><p>When the button in the Button component is clicked, the <code>incrementCount</code> function is called.</p><p>This function must increment the local count. How can we do so? We can use hooks:</p><pre><code class="language-jsx">const { useState } = React
const Button = ({ increment, onClickFunction }) =&gt; {
const handleClick = () =&gt; {
onClickFunction(increment)
}
return &lt;button onClick={handleClick}&gt;+{increment}&lt;/button&gt;
}
const App = () =&gt; {
const [count, setCount] = useState(0)
const incrementCount = increment =&gt; {
setCount(count + increment)
}
return (
&lt;div&gt;
&lt;Button increment={1} onClickFunction={incrementCount} /&gt;
&lt;Button increment={10} onClickFunction={incrementCount} /&gt;
&lt;Button increment={100} onClickFunction={incrementCount} /&gt;
&lt;Button increment={1000} onClickFunction={incrementCount} /&gt;
&lt;span&gt;{count}&lt;/span&gt;
&lt;/div&gt;
)
}
return (
&lt;div style={{ margin: '1em' }}&gt;
&lt;img alt="avatar" style={{ width: '70px' }} src={props.avatar_url} /&gt;
&lt;div&gt;
&lt;div style={{ fontWeight: 'bold' }}&gt;{props.name}&lt;/div&gt;
&lt;div&gt;{props.blog}&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
)
&lt;div&gt;
))}
&lt;/div&gt;
return (
&lt;div&gt;
&lt;/div&gt;
)
}</code></pre><p>Cool! We must have a way now to ask GitHub for the details of a single username. We’ll do so using a <code>Form</code> component, where we manage our own state (<code>username</code>), and we ask GitHub for information about a user using their public APIs, via Axios:</p><pre><code class="language-jsx">const Form = props =&gt; {
const [username, setUsername] = useState('')
handleSubmit = event =&gt; {
event.preventDefault()
axios.get(`https://api.github.com/users/${username}`).then(resp =&gt; {
props.onSubmit(resp.data)
setUsername('')
})
}
return (
&lt;form onSubmit={handleSubmit}&gt;
&lt;input
type="text"
value={username}
onChange={event =&gt; setUsername(event.target.value)}
placeholder="GitHub username"
required
/&gt;
&lt;/form&gt;
)
}
return (
&lt;div&gt;
&lt;Form onSubmit={addNewCard} /&gt;
&lt;/div&gt;
)
}</code></pre><p>Finally we render the app:</p><pre><code>ReactDOM.render(&lt;App /&gt;, document.getElementById('app'))</code></pre><p>Here is the full source code of our little React app:</p><pre><code class="language-jsx">const { useState } = React
const Card = props =&gt; {
return (
&lt;div style={{ margin: '1em' }}&gt;
&lt;img alt="avatar" style={{ width: '70px' }} src={props.avatar_url} /&gt;
&lt;div&gt;
&lt;div style={{ fontWeight: 'bold' }}&gt;{props.name}&lt;/div&gt;
&lt;div&gt;{props.blog}&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
)
}
const Form = props =&gt; {
const [username, setUsername] = useState('')
handleSubmit = event =&gt; {
event.preventDefault()
axios
.get(`https://api.github.com/users/${username}`)
.then(resp =&gt; {
props.onSubmit(resp.data)
setUsername('')
})
}
return (
&lt;form onSubmit={handleSubmit}&gt;
&lt;input
type="text"
value={username}
onChange={event =&gt; setUsername(event.target.value)}
placeholder="GitHub username"
required
/&gt;
&lt;/form&gt;
)
}
const App = () =&gt; {
}
return (
&lt;div&gt;
&lt;Form onSubmit={addNewCard} /&gt;
&lt;/div&gt;
)
}
return &lt;button className="button"&gt;A button&lt;/button&gt;
}
.button {
background-color: yellow;
}</code></pre><p>You can import the stylesheet using an import statement, like this:</p><pre><code>import './style.css'</code></pre><p>and <a href="https://flaviocopes.com/webpack/" rel="noopener">Webpack</a> will take care of adding the CSS property to the bundle.</p><h4 id="using-the-style-attribute">Using the style attribute</h4><p>A second method is to use the <code>style</code> attribute attached to a JSX element. Using this approach you don't need a separate CSS file.</p><pre><code>const Button = () =&gt; {
return &lt;button style={{ backgroundColor: 'yellow' }}&gt;A button&lt;/button&gt;
}</code></pre><p>CSS is defined in a slightly different way now. First, notice the double curly brackets: it’s because <code>style</code> accepts an object. We pass in a JavaScript object, which is defined in curly braces. We could also do this:</p><pre><code>const buttonStyle = { backgroundColor: 'yellow' }
const Button = () =&gt; {
return &lt;button style={buttonStyle}&gt;A button&lt;/button&gt;
}</code></pre><p>When using <code>create-react-app</code>, those styles are autoprefixed by default thanks to its use of <a href="https://github.com/postcss/autoprefixer" rel="noopener">Autoprefixer</a>.</p><p>Also, the style now is camelCased instead of using dashes. Every time a CSS property has a dash, remove it and start the next word capitalized.</p><p>Styles have the benefit of being local to the component, and they cannot leak to other components in other parts of the app, something that using classes and an external CSS file can’t provide.</p><h4 id="using-css-modules">Using CSS Modules</h4><p><strong>CSS Modules</strong> seem to be a perfect spot in the middle: you use classes, but CSS is scoped to the component, which means that any styling you add cannot be applied to other components without your permission. And yet your styles are defined in a separate CSS file, which is easier to maintain than CSS in JavaScript (and you can use your good old CSS property names).</p><p>Start by creating a CSS file that ends with <code>.module.css</code>, for example <code>Button.module.css</code>. A great choice is to give it the same name as the component you are going to style</p><p>Add your CSS here, then import it inside the component file you want to style:</p><pre><code>import style from './Button.module.css'</code></pre><p>now you can use it in your JSX:</p><pre><code>const Button = () =&gt; {
return &lt;button className={style.content}&gt;A button&lt;/button&gt;
}</code></pre><p>That’s it! In the resulting markup, React will generate a specific, unique class for each rendered component, and assign the CSS to that class, so that the CSS is not affecting other markup.</p><h3 id="sass-in-react">SASS in React</h3><p>When you build a React application using <code><a href="https://flaviocopes.com/react-create-react-app/" rel="noopener">create-react-app</a></code>, you have many options at your disposal when it comes to styling.</p><blockquote><em>Of course, if not using <code>create-react-app</code>, you have all the choices in the world, but we limit the discussion to the <code>create-react-app</code>-provided options.</em></blockquote><p>You can style using plain classes and CSS files, using the style attribute or CSS Modules, to start with.</p><p>SASS/SCSS is a very popular option, a much loved one by many developers.</p><p>You can use it without any configuration at all, starting with <code>create-react-app</code> 2.</p><p>All you need is a <code>.sass</code> or <code>.scss</code> file, and you just import it in a component:</p><pre><code>import './styles.scss'</code></pre><p>You can see an example of it working at <a href="https://codesandbox.io/s/18qq31rp3" rel="noopener">https://codesandbox.io/s/18qq31rp3</a>.</p><h3 id="styled-components">Styled Components</h3><p>Styled Components are one of the new ways to use CSS in modern JavaScript. It is the meant to be a successor of CSS Modules, a way to write CSS that’s scoped to a single component, and not leak to any other element in the page</p><h4 id="a-brief-history">A brief history</h4><p>Once upon a time, the Web was really simple and CSS didn’t even exist. We laid out pages using <strong>tables </strong>and frames. Good times.</p><p>Then <strong>CSS</strong> came to life, and after some time it became clear that frameworks could greatly help especially in building grids and layouts, Bootstrap and Foundation playing a big part in this.</p><p>Preprocessors like <strong>SASS</strong> and others helped a lot to slow down the adoption of frameworks, and to better organize the code, conventions like <strong>BEM</strong> and <strong>SMACSS</strong> grew in use, especially within teams.</p><p>Conventions are not a solution to everything, and they are complex to remember, so in the last few years with the increasing adoption of <a href="https://flaviocopes.com/javascript/" rel="noopener">JavaScript</a> and build processes in every frontend project, CSS found its way into JavaScript (<strong>CSS-in-JS</strong>).</p><p>New tools explored new ways of doing CSS-in-JS and a few succeeded with increasing popularity:</p><ul><li>React Style</li><li>jsxstyle</li><li>Radium</li></ul><p>and more.</p><h4 id="introducing-styled-components">Introducing Styled Components</h4><p>One of the most popular of these tools is <strong>Styled Components</strong>.</p><p>It is the meant to be a successor to <strong>CSS Modules</strong>, a way to write CSS that’s scoped to a single component, and not leak to any other element in the page.</p><p>(more on CSS modules <a href="https://css-tricks.com/css-modules-part-1-need/" rel="noopener">here</a> and <a href="https://glenmaddern.com/articles/css-modules" rel="noopener">here</a>)</p><p>Styled Components allow you to write plain CSS in your components without worrying about class name collisions.</p><h4 id="installation">Installation</h4><p>Simply install styled-components using <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a> or <a href="https://flaviocopes.com/yarn/" rel="noopener">yarn</a>:</p><pre><code class="language-bash">npm install styled-components
yarn add styled-components</code></pre><p>That’s it! Now all you have to do is to add this import:</p><pre><code>import styled from 'styled-components'</code></pre><h4 id="your-first-styled-component">Your first styled component</h4><p>With the <code>styled</code> object imported, you can now start creating Styled Components. Here's the first one:</p><pre><code class="language-jsx">const Button = styled.button`
font-size: 1.5em;
background-color: black;
color: white;
`</code></pre><p><code>Button</code> is now a React Component in all its greatness.</p><p>We created it using a function of the styled object, called <code>button</code> in this case, and passing some CSS properties in a <a href="https://flaviocopes.com/ecmascript/#template-literals" rel="noopener">template literal</a>.</p><p>Now this component can be rendered in our container using the normal React syntax:</p><pre><code>render(&lt;Button /&gt;)</code></pre><p>Styled Components offer other functions you can use to create other components, not just <code>button</code>, like <code>section</code>, <code>h1</code>, <code>input</code> and many others.</p><p>The syntax used, with the backtick, might be weird at first, but it’s called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener">Tagged Templates</a>, it’s plain JavaScript and it’s a way to pass an argument to the function.</p><h4 id="using-props-to-customize-components">Using props to customize components</h4><p>When you pass some props to a Styled Component, it will pass them down to the <a href="https://flaviocopes.com/dom/" rel="noopener">DOM</a> node mounted.</p><p>For example here’s how we pass the <code>placeholder</code> and <code>type</code> props to an <code>input</code> component:</p><pre><code>const Input = styled.input`
//...
`
render(
&lt;div&gt;
&lt;Input placeholder="..." type="text" /&gt;
&lt;/div&gt;
)</code></pre><p>This will do just what you think, inserting those props as HTML attributes.</p><p>Props instead of just being blindly passed down to the <a href="https://flaviocopes.com/dom/" rel="noopener">DOM</a> can also be used to customize a component based on the prop value. Here’s an example:</p><pre><code>const Button = styled.button`
background: ${props =&gt; (props.primary ? 'black' : 'white')};
color: ${props =&gt; (props.primary ? 'white' : 'black')};
`
render(
&lt;div&gt;
&lt;Button&gt;A normal button&lt;/Button&gt;
&lt;Button&gt;A normal button&lt;/Button&gt;
&lt;Button primary&gt;The primary button&lt;/Button&gt;
&lt;/div&gt;
)</code></pre><p>Setting the <code>primary</code> prop changes the color of the button.</p><h4 id="extending-an-existing-styled-component">Extending an existing Styled Component</h4><p>If you have one component and you want to create a similar one, just styled slightly differently, you can use <code>extend</code>:</p><pre><code>const Button = styled.button`
color: black;
//...
`
const WhiteButton = Button.extend`
color: white;
`
render(
&lt;div&gt;
&lt;Button&gt;A black button, like all buttons&lt;/Button&gt;
&lt;WhiteButton&gt;A white button&lt;/WhiteButton&gt;
&lt;/div&gt;
)</code></pre><h4 id="it-s-regular-css">It’s Regular CSS</h4><p>In Styled Components, you can use the CSS you already know and love. It’s just plain CSS. It is not pseudo CSS nor inline CSS with its limitations.</p><p>You can use media queries, <a href="https://tabatkins.github.io/specs/css-nesting/" rel="noopener">nesting</a> and anything else you might need.</p><h4 id="using-vendor-prefixes">Using Vendor Prefixes</h4><p>Styled Components automatically add all the vendor prefixes needed, so you don’t need to worry about this problem.</p><h3 id="section-6-tooling">SECTION 6: TOOLING</h3><h3 id="babel">Babel</h3><p>Babel is an awesome tool, and it’s been around for quite some time, but nowadays almost every JavaScript developer relies on it. This will continue, because Babel is now indispensable and has solved a big problem for everyone.</p><p>Which problem?</p><p>The problem that every Web Developer has surely had: a feature of JavaScript is available in the latest release of a browser, but not in the older versions. Or maybe Chrome or Firefox implement it, but Safari iOS and Edge do not.</p><p>For example, ES6 introduced the <strong>arrow function</strong>:</p><pre><code>[1, 2, 3].map((n) =&gt; n + 1)</code></pre><p>Which is now supported by all modern browsers. IE11 does not support it, nor Opera Mini (How do I know? By checking the <a href="http://kangax.github.io/compat-table/es6/#test-arrow_functions" rel="noopener">ES6 Compatibility Table</a>).</p><p>So how should you deal with this problem? Should you move on and leave those customers with older/incompatible browsers behind, or should you write older JavaScript code to make all your users happy?</p><p>Enter Babel. Babel is a <strong>compiler</strong>: it takes code written in one standard, and it transpiles it to code written into another standard.</p><p>You can configure Babel to transpile modern ES2017 JavaScript into JavaScript ES5 syntax:</p><pre><code>[1, 2, 3].map(function(n) {
return n + 1
})</code></pre><p>This must happen at build time, so you must setup a workflow that handles this for you. <a href="https://flaviocopes.com/webpack/" rel="noopener">Webpack</a> is a common solution.</p><p>(P.S. if all this <em>ES</em> thing sounds confusing to you, see more about ES versions <a href="https://flaviocopes.com/ecmascript/" rel="noopener">in the ECMAScript guide</a>)</p><h4 id="installing-babel">Installing Babel</h4><p>Babel is easily installed using <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a>, locally in a project:</p><pre><code>npm install --save-dev @babel/core @babel/cli</code></pre><p>Since npm now comes with <code><a href="https://flaviocopes.com/node/npx/" rel="noopener">npx</a></code>, locally installed CLI packages can run by typing the command in the project folder:</p><p>So we can run Babel by just running</p><pre><code>npx babel script.js</code></pre><h4 id="an-example-babel-configuration">An example Babel configuration</h4><p>Babel out of the box does not do anything useful, you need to configure it and add plugins.</p><blockquote><a href="https://babeljs.io/docs/en/plugins" rel="noopener"><em>Here is a list of Babel plugins</em></a></blockquote><p>To solve the problem we talked about in the introduction (using arrow functions in every browser), we can run</p><pre><code>npm install --save-dev \
@babel/plugin-transform-es2015-arrow-functions</code></pre><p>to download the package in the <code>node_modules</code> folder of our app, then we need to add</p><pre><code class="language-json">{
"plugins": ["transform-es2015-arrow-functions"]
}</code></pre><p>to the <code>.babelrc</code> file present in the application root folder. If you don't have that file already, you just create a blank file, and put that content into it.</p><blockquote><em>TIP: If you have never seen a dot file (a file starting with a dot) it might be odd at first because that file might not appear in your file manager, as it’s a hidden file.</em></blockquote><p>Now if we have a <code>script.js</code> file with this content:</p><pre><code class="language-jsx">var a = () =&gt; {};
var a = (b) =&gt; b;
const double = [1,2,3].map((num) =&gt; num * 2);
console.log(double); // [2,4,6]
var bob = {
_name: "Bob",
_friends: ["Sally", "Tom"],
printFriends() {
this._friends.forEach(f =&gt;
console.log(this._name + " knows " + f));
}
};
console.log(bob.printFriends());</code></pre><p>running <code>babel script.js</code> will output the following code:</p><pre><code class="language-jsx">var a = function () {};var a = function (b) {
return b;
};
const double = [1, 2, 3].map(function (num) {
return num * 2;
});
console.log(double); // [2,4,6]
var bob = {
_name: "Bob",
_friends: ["Sally", "Tom"],
printFriends() {
var _this = this;
this._friends.forEach(function (f) {
return console.log(_this._name + " knows " + f);
});
}
};
console.log(bob.printFriends());</code></pre><p>As you can see arrow functions have all been converted to JavaScript ES5 functions.</p><h4 id="babel-presets">Babel presets</h4><p>We just saw in the previous article how Babel can be configured to transpile specific JavaScript features.</p><p>You can add much more plugins, but you can’t add to the configuration features one by one, it’s not practical.</p><p>This is why Babel offers <strong>presets</strong>.</p><p>The most popular presets are <code>env</code> and <code>react</code>.</p><blockquote><em>Tip: Babel 7 deprecated (and removed) yearly presets like <code>preset-es2017</code>, and stage presets. Use <code>@babel/preset-env</code> instead.</em></blockquote><h4 id="env-preset"><code>env</code> preset</h4><p>The <code>env</code> preset is very nice: you tell it which environments you want to support, and it does everything for you, <strong>supporting all modern JavaScript features</strong>.</p><p>E.g. “support the last 2 versions of every browser, but for Safari let’s support all versions since Safari 7”</p><pre><code>{
"presets": [
["env", {
"targets": {
"browsers": ["last 2 versions", "safari &gt;= 7"]
}
}]
]
}</code></pre><p>or “I don’t need browser support, just let me work with <a href="https://flaviocopes.com/node/" rel="noopener">Node.js</a> 6.10”</p><pre><code>{
"presets": [
["env", {
"targets": {
"node": "6.10"
}
}]
]
}</code></pre><h4 id="react-preset"><code>react</code> preset</h4><p>The <code>react</code> preset is very convenient when writing React apps: adding <code>preset-flow</code>, <code>syntax-jsx</code>, <code>transform-react-jsx</code>, <code>transform-react-display-name</code>.</p><p>By including it, you are all ready to go developing React apps, with JSX transforms and Flow support.</p><h4 id="more-info-on-presets">More info on presets</h4><p><a href="https://babeljs.io/docs/plugins/" rel="noopener">https://babeljs.io/docs/plugins/</a></p><h4 id="using-babel-with-webpack">Using Babel with webpack</h4><p>If you want to run modern JavaScript in the browser, Babel on its own is not enough, you also need to bundle the code. Webpack is the perfect tool for this.</p><p>Modern JS needs two different stages: a compile stage, and a runtime stage. This is because some ES6+ features need a polyfill or a runtime helper.</p><p>To install the Babel polyfill runtime functionality, run</p><pre><code>npm install @babel/polyfill \
@babel/runtime \
@babel/plugin-transform-runtime</code></pre><p>Now in your <code>webpack.config.js</code> file add:</p><pre><code class="language-js">entry: [
'babel-polyfill',
// your app scripts should be here
],
module: {
loaders: [
// Babel loader compiles ES2015 into ES5 for
// complete cross-browser support
{
loader: 'babel-loader',
test: /\.js$/,
// only include files present in the `src` subdirectory
include: [path.resolve(__dirname, "src")],
// exclude node_modules, equivalent to the above line
exclude: /node_modules/,
query: {
// Use the default ES2015 preset
// to include all ES2015 features
presets: ['es2015'],
plugins: ['transform-runtime']
}
}
]
}</code></pre><p>By keeping the presets and plugins information inside the <code>webpack.config.js</code> file, we can avoid having a <code>.babelrc</code> file.</p><h3 id="webpack">Webpack</h3><p>Webpack is a tool that lets you compile JavaScript modules, also known as <strong>module bundler</strong>. Given a large number of files, it generates a single file (or a few files) that run your app.</p><p>It can perform many operations:</p><ul><li>helps you bundle your resources.</li><li>watches for changes and re-runs the tasks.</li><li>can run Babel transpilation to ES5, allowing you to use the latest JavaScript features without worrying about browser support.</li><li>can transpile CoffeeScript to JavaScript</li><li>can convert inline images to data URIs.</li><li>allows you to use require() for CSS files.</li><li>can run a development webserver.</li><li>can handle hot module replacement.</li><li>can split the output files into multiple files, to avoid having a huge js file to load in the first page hit.</li><li>can perform <a href="https://flaviocopes.com/javascript-glossary/#tree-shaking" rel="noopener">tree shaking</a>.</li></ul><p>Webpack is not limited to be use on the frontend, it’s also useful in backend Node.js development as well.</p><p>Predecessors of webpack, and still widely used tools, include:</p><ul><li>Grunt</li><li>Broccoli</li><li>Gulp</li></ul><p>There are lots of similarities in what those and Webpack can do, but the main difference is that those are known as <strong>task runners</strong>, while webpack was born as a module bundler.</p><p>It’s a more focused tool: you specify an entry point to your app (it could even be an HTML file with script tags) and webpack analyzes the files and bundles all you need to run the app in a single JavaScript output file (or in more files if you use code splitting).</p><h4 id="installing-webpack">Installing webpack</h4><p>Webpack can be installed globally or locally for each project.</p><h4 id="global-install">Global install</h4><p>Here’s how to install it globally with <a href="https://flaviocopes.com/yarn/" rel="noopener">Yarn</a>:</p><pre><code class="language-bash">yarn global add webpack webpack-cli</code></pre><p>with <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a>:</p><pre><code>npm i -g webpack webpack-cli</code></pre><p>once this is done, you should be able to run</p><pre><code>webpack-cli</code></pre><h4 id="local-install">Local install</h4><p>Webpack can be installed locally as well. It’s the recommended setup, because webpack can be updated per-project, and you have less resistance to using the latest features just for a small project rather than updating all the projects you have that use webpack.</p><p>With <a href="https://flaviocopes.com/yarn/" rel="noopener">Yarn</a>:</p><pre><code>yarn add webpack webpack-cli -D</code></pre><p>with <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a>:</p><pre><code>npm i webpack webpack-cli --save-dev</code></pre><p>Once this is done, add this to your <code>package.json</code> file:</p><pre><code>{
//...
"scripts": {
"build": "webpack"
}
}</code></pre><p>once this is done, you can run webpack by typing</p><pre><code>yarn build</code></pre><p>in the project root.</p><h4 id="webpack-configuration">Webpack configuration</h4><p>By default, webpack (starting from version 4) does not require any config if you respect these conventions:</p><ul><li>the <strong>entry point</strong> of your app is <code>./src/index.js</code></li><li>the output is put in <code>./dist/main.js</code>.</li><li>Webpack works in production mode</li></ul><p>You can customize every little bit of webpack of course, when you need. The webpack configuration is stored in the <code>webpack.config.js</code> file, in the project root folder.</p><h4 id="the-entry-point">The entry point</h4><p>By default the entry point is <code>./src/index.js</code> This simple example uses the <code>./index.js</code> file as a starting point:</p><pre><code>module.exports = {
/*...*/
entry: './index.js'
/*...*/
}</code></pre><h4 id="the-output">The output</h4><p>By default the output is generated in <code>./dist/main.js</code>. This example puts the output bundle into <code>app.js</code>:</p><pre><code>module.exports = {
/*...*/
output: {
path: path.resolve(__dirname, 'dist'),
filename: 'app.js'
}
/*...*/
}</code></pre><h4 id="loaders">Loaders</h4><p>Using webpack allows you to use <code>import</code> or <code>require</code> statements in your JavaScript code to not just include other JavaScript, but any kind of file, for example CSS.</p><p>Webpack aims to handle all our dependencies, not just JavaScript, and loaders are one way to do that.</p><p>For example, in your code you can use:</p><pre><code>import 'style.css'</code></pre><p>by using this loader configuration:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{ test: /\.css$/, use: 'css-loader' },
}]
}
/*...*/
}</code></pre><p>The <a href="https://flaviocopes.com/javascript-regular-expressions/" rel="noopener">regular expression</a> targets any CSS file.</p><p>A loader can have options:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.css$/,
use: [
{
loader: 'css-loader',
options: {
modules: true
}
}
]
}
]
}
/*...*/
}</code></pre><p>You can require multiple loaders for each rule:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.css$/,
use:
[
'style-loader',
'css-loader',
]
}
]
}
/*...*/
}</code></pre><p>In this example, <code>css-loader</code> interprets the <code>import 'style.css'</code> directive in the CSS. <code>style-loader</code> is then responsible for injecting that CSS in the DOM, using a <code>&lt;style&gt;</code> tag.</p><p>The order matters, and it’s reversed (the last is executed first).</p><p>What kind of loaders are there? Many! <a href="https://webpack.js.org/loaders/" rel="noopener">You can find the full list here</a>.</p><p>A commonly used loader is Babel, which is used to transpile modern JavaScript to ES5 code:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.js$/,
exclude: /(node_modules|bower_components)/,
use: {
loader: 'babel-loader',
options: {
presets: ['@babel/preset-env']
}
}
}
]
}
/*...*/
}</code></pre><p>This example makes Babel preprocess all our React/JSX files:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.(js|jsx)$/,
exclude: /node_modules/,
use: 'babel-loader'
}
]
},
resolve: {
extensions: [
'.js',
'.jsx'
]
}
/*...*/
}</code></pre><p><a href="https://webpack.js.org/loaders/babel-loader/" rel="noopener">See the <code>babel-loader</code> options here</a>.</p><h4 id="plugins">Plugins</h4><p>Plugins are like loaders, but on steroids. They can do things that loaders can’t do, and they are the main building block of webpack.</p><p>Take this example:</p><pre><code>module.exports = {
/*...*/
plugins: [
new HTMLWebpackPlugin()
]
/*...*/
}</code></pre><p>The <code>HTMLWebpackPlugin</code> plugin has the job of automatically creating an HTML file, adding the output JS bundle path, so the JavaScript is ready to be served.</p><p>There are <a href="https://webpack.js.org/plugins/" rel="noopener">lots of plugins available</a>.</p><p>One useful plugin, <code>CleanWebpackPlugin</code>, can be used to clear the <code>dist/</code> folder before creating any output, so you don't leave files around when you change the name of the output file:</p><pre><code>module.exports = {
/*...*/
plugins: [
new CleanWebpackPlugin(['dist']),
]
/*...*/
}</code></pre><h4 id="the-webpack-mode">The webpack mode</h4><p>This mode (introduced in webpack 4) sets the environment on which webpack works. It can be set to <code>development</code> or <code>production</code> (defaults to production, so you only set it when moving to development)</p><pre><code>module.exports = {
entry: './index.js',
mode: 'development',
output: {
path: path.resolve(__dirname, 'dist'),
filename: 'app.js'
}
"build": "webpack"
}</code></pre><p>allows us to run <code>webpack</code> by running</p><pre><code class="language-bash">npm run build</code></pre><p>or</p><pre><code class="language-bash">yarn run build</code></pre><p>or simply</p><pre><code class="language-bash">yarn build</code></pre><h4 id="watching-changes">Watching changes</h4><p>Webpack can automatically rebuild the bundle when a change in your app happens, and keep listening for the next change.</p><p>Just add this script:</p><pre><code class="language-js">"scripts": {
"watch": "webpack --watch"
}</code></pre><p>and run</p><pre><code class="language-bash">npm run watch</code></pre><p>or</p><pre><code class="language-bash">yarn run watch</code></pre><p>or simply</p><pre><code>yarn watch</code></pre><p>One nice feature of the watch mode is that the bundle is only changed if the build has no errors. If there are errors, <code>watch</code> will keep listening for changes, and try to rebuild the bundle, but the current, working bundle is not affected by those problematic builds.</p><h4 id="handling-images">Handling images</h4><p>Webpack allows us to use images in a very convenient way, using the <code><a href="https://webpack.js.org/loaders/file-loader/" rel="noopener">file-loader</a></code> loader.</p><p>This simple configuration:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.(png|svg|jpg|gif)$/,
use: [
'file-loader'
]
}
]
}
/*...*/
}</code></pre><p>Allows you to import images in your JavaScript:</p><pre><code>import Icon from './icon.png'
const img = new Image()
img.src = Icon
element.appendChild(img)</code></pre><p>(<code>img</code> is an HTMLImageElement. Check the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image" rel="noopener">Image docs</a>)</p><p><code>file-loader</code> can handle other asset types as well, like fonts, CSV files, xml, and more.</p><p>Another nice tool to work with images is the <code>url-loader</code> loader.</p><p>This example loads any PNG file smaller than 8KB as a <a href="https://flaviocopes.com/data-urls/" rel="noopener">data URL</a>.</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.png$/,
use: [
{
loader: 'url-loader',
options: {
limit: 8192
}
}
]
}
]
}
/*...*/
}</code></pre><h4 id="process-your-sass-code-and-transform-it-to-css">Process your SASS code and transform it to CSS</h4><p>Using <code>sass-loader</code>, <code>css-loader</code> and <code>style-loader</code>:</p><pre><code>module.exports = {
/*...*/
module: {
rules: [
{
test: /\.scss$/,
use: [
'style-loader',
'css-loader',
'sass-loader'
]
}
]
}
/*...*/
}</code></pre><h4 id="generate-source-maps">Generate Source Maps</h4><p>Since webpack bundles the code, Source Maps are mandatory to get a reference to the original file that raised an error, for example.</p><p>You tell webpack to generate source maps using the <code>devtool</code> property of the configuration:</p><pre><code>module.exports = {
/*...*/
devtool: 'inline-source-map',
/*...*/
}</code></pre><p><code>devtool</code> has <a href="https://webpack.js.org/configuration/devtool/" rel="noopener">many possible values</a>, the most used probably are:</p><ul><li><code>none</code>: adds no source maps</li><li><code>source-map</code>: ideal for production, provides a separate source map that can be minimized, and adds a reference into the bundle, so development tools know that the source map is available. Of course you should configure the server to avoid shipping this, and just use it for debugging purposes</li><li><code>inline-source-map</code>: ideal for development, inlines the source map as a Data URL</li></ul><h3 id="section-7-testing">SECTION 7: TESTING</h3><h3 id="jest">Jest</h3><p>Jest is a library for testing JavaScript code.</p><p>It’s an open source project maintained by Facebook, and it’s especially well suited for React code testing, although not limited to that: it can test any JavaScript code. Its strengths are:</p><ul><li>it’s fast</li><li>it can perform <strong>snapshot testing</strong></li><li>it’s opinionated, and provides everything out of the box without requiring you to make choices</li></ul><p>Jest is a tool very similar to Mocha, although they have differences:</p><ul><li>Mocha is less opinionated, while Jest has a certain set of conventions</li><li>Mocha requires more configuration, while Jest works usually out of the box, thanks to being opinionated</li><li>Mocha is older and more established, with more tooling integrations</li></ul><p>In my opinion the biggest feature of Jest is it’s an out of the box solution that works without having to interact with other testing libraries to perform its job.</p><h4 id="installation-1">Installation</h4><p>Jest is automatically installed in <code>create-react-app</code>, so if you use that, you don’t need to install Jest.</p><p>Jest can be installed in any other project using <a href="https://flaviocopes.com/yarn/" rel="noopener">Yarn</a>:</p><pre><code>yarn add --dev jest</code></pre><p>or <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a>:</p><pre><code>npm install --save-dev jest</code></pre><p>notice how we instruct both to put Jest in the <code>devDependencies</code> part of the <code>package.json</code> file, so that it will only be installed in the development environment and not in production.</p><p>Add this line to the scripts part of your <code>package.json</code> file:</p><pre><code>{
"scripts": {
"test": "jest"
}
}</code></pre><p>so that tests can be run using <code>yarn test</code> or <code>npm run test</code>.</p><p>Alternatively, you can install Jest globally:</p><pre><code>yarn global add jest</code></pre><p>and run all your tests using the <code>jest</code> command line tool.</p><h4 id="create-the-first-jest-test">Create the first Jest test</h4><p>Projects created with <code>create-react-app</code> have Jest installed and preconfigured out of the box, but adding Jest to any project is as easy as typing</p><pre><code>yarn add --dev jest</code></pre><p>Add to your <code>package.json</code> this line:</p><pre><code>{
"scripts": {
"test": "jest"
}
const mul = (a, b) =&gt; a * b
const sub = (a, b) =&gt; a - b
const div = (a, b) =&gt; a / b
export default { sum, mul, sub, div }</code></pre><p>Now create a <code>math.test.js</code> file, in the same folder, and there we’ll use Jest to test the functions defined in <code>math.js</code>:</p><pre><code>const { sum, mul, sub, div } = require('./math')
test('Adding 1 + 1 equals 2', () =&gt; {
expect(sum(1, 1)).toBe(2)
})
test('Multiplying 1 * 1 equals 1', () =&gt; {
expect(mul(1, 1)).toBe(1)
})
test('Subtracting 1 - 1 equals 0', () =&gt; {
expect(sub(1, 1)).toBe(0)
})
test('Dividing 1 / 1 equals 1', () =&gt; {
expect(div(1, 1)).toBe(1)
expect(sum(1, 1)).toBe(2)
})</code></pre><p>A matcher is a method that lets you test values.</p><p>Most commonly used matchers, comparing the value of the result of <code>expect()</code> with the value passed in as argument, are:</p><ul><li><code>toBe</code> compares strict equality, using <code>===</code></li><li><code>toEqual</code> compares the values of two variables. If it’s an object or array, it checks the equality of all the properties or elements</li><li><code>toBeNull</code> is true when passing a null value</li><li><code>toBeDefined</code> is true when passing a defined value (opposite to the above)</li><li><code>toBeUndefined</code> is true when passing an undefined value</li><li><code>toBeCloseTo</code> is used to compare floating values, avoiding rounding errors</li><li><code>toBeTruthy</code> true if the value is considered true (like an <code>if</code> does)</li><li><code>toBeFalsy</code> true if the value is considered false (like an <code>if</code> does)</li><li><code>toBeGreaterThan</code> true if the result of expect() is higher than the argument</li><li><code>toBeGreaterThanOrEqual</code> true if the result of expect() is equal to the argument, or higher than the argument</li><li><code>toBeLessThan</code> true if the result of expect() is lower than the argument</li><li><code>toBeLessThanOrEqual</code> true if the result of expect() is equal to the argument, or lower than the argument</li><li><code>toMatch</code> is used to compare strings with <a href="https://flaviocopes.com/javascript-regular-expressions/" rel="noopener">regular expression</a> pattern matching</li><li><code>toContain</code> is used in arrays, true if the expected array contains the argument in its elements set</li><li><code>toHaveLength(number)</code>: checks the length of an array</li><li><code>toHaveProperty(key, value)</code>: checks if an object has a property, and optionally checks its value</li><li><code>toThrow</code> checks if a function you pass throws an exception (in general) or a specific exception</li><li><code>toBeInstanceOf()</code>: checks if an object is an instance of a class</li></ul><p>All those matchers can be negated using <code>.not.</code> inside the statement, for example:</p><pre><code class="language-js">test('Adding 1 + 1 does not equal 3', () =&gt; {
expect(sum(1, 1)).not.toBe(3)
})</code></pre><p>For use with promises, you can use <code>.resolves</code> and <code>.rejects</code>:</p><pre><code>expect(Promise.resolve('lemon')).resolves.toBe('lemon')
expect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus')</code></pre><h4 id="setup">Setup</h4><p>Before running your tests you will want to perform some initialization.</p><p>To do something once before all the tests run, use the <code>beforeAll()</code> function:</p><pre><code>beforeAll(() =&gt; {
//do something
})</code></pre><p>To perform something before each test runs, use <code>beforeEach()</code>:</p><pre><code>beforeEach(() =&gt; {
//do something
})</code></pre><h4 id="teardown">Teardown</h4><p>Just as you can do with setup, you can also perform something after each test runs:</p><pre><code>afterEach(() =&gt; {
//do something
})</code></pre><p>and after all tests end:</p><pre><code>afterAll(() =&gt; {
//do something
})</code></pre><h4 id="group-tests-using-describe-">Group tests using describe()</h4><p>You can create groups of tests, in a single file, that isolate the setup and teardown functions:</p><pre><code>describe('first set', () =&gt; {
beforeEach(() =&gt; {
//do something
})
afterAll(() =&gt; {
//do something
})
test(/*...*/)
test(/*...*/)
})
describe('second set', () =&gt; {
beforeEach(() =&gt; {
//do something
})
beforeAll(() =&gt; {
//do something
})
test(/*...*/)
test(/*...*/)
}) </code></pre><h4 id="testing-asynchronous-code">Testing asynchronous code</h4><p>Asynchronous code in modern JavaScript can have basically 2 forms: callbacks and promises. On top of promises we can use async/await.</p><h4 id="callbacks-1">Callbacks</h4><p>You can’t have a test in a callback, because Jest won’t execute it — the execution of the test file ends before the callback is called. To fix this, pass a parameter to the test function, which you can conveniently call <code>done</code>. Jest will wait until you call <code>done()</code> before ending that test:</p><pre><code>//uppercase.js
function uppercase(str, callback) {
callback(str.toUpperCase())
}
module.exports = uppercase
//uppercase.test.js
const uppercase = require('./src/uppercase')
test(`uppercase 'test' to equal 'TEST'`, (done) =&gt; {
uppercase('test', (str) =&gt; {
expect(str).toBe('TEST')
done()
}
const uppercase = str =&gt; {
return new Promise((resolve, reject) =&gt; {
if (!str) {
reject('Empty string')
return
}
resolve(str.toUpperCase())
})
}
module.exports = uppercase
//uppercase.test.js
const uppercase = require('./uppercase')
test(`uppercase 'test' to equal 'TEST'`, () =&gt; {
return uppercase('test').then(str =&gt; {
expect(str).toBe('TEST')
})
const uppercase = str =&gt; {
return new Promise((resolve, reject) =&gt; {
if (!str) {
reject('Empty string')
return
}
resolve(str.toUpperCase())
})
}
module.exports = uppercase
//uppercase.test.js
const uppercase = require('./uppercase')
test(`uppercase 'test' to equal 'TEST'`, () =&gt; {
return uppercase('').catch(e =&gt; {
expect(e).toMatch('Empty string')
})
const uppercase = require('./uppercase')
test(`uppercase 'test' to equal 'TEST'`, async () =&gt; {
const str = await uppercase('test')
expect(str).toBe('TEST')
test(`The mathjs log function`, () =&gt; {
const spy = jest.spyOn(mathjs, 'log')
const result = mathjs.log(10000, 10)
expect(mathjs.log).toHaveBeenCalled()
expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})</code></pre><h4 id="mock-an-entire-package">Mock an entire package</h4><p>Jest provides a convenient way to mock an entire package. Create a <code>__mocks__</code>folder in the project root, and in this folder create one JavaScript file for each of your packages.</p><p>Say you import <code>mathjs</code>. Create a <code>__mocks__/mathjs.js</code> file in your project root, and add this content:</p><pre><code>module.exports = {
log: jest.fn(() =&gt; 'test')
}</code></pre><p>This will mock the log() function of the package. Add as many functions as you want to mock:</p><pre><code>const mathjs = require('mathjs')
test(`The mathjs log function`, () =&gt; {
const result = mathjs.log(10000, 10)
expect(result).toBe('test')
expect(mathjs.log).toHaveBeenCalled()
expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})</code></pre><h4 id="mock-a-single-function">Mock a single function</h4><p>More simply, you can mock a single function using <code>jest.fn()</code>:</p><pre><code>const mathjs = require('mathjs')
mathjs.log = jest.fn(() =&gt; 'test')
test(`The mathjs log function`, () =&gt; {
const result = mathjs.log(10000, 10)
expect(result).toBe('test')
expect(mathjs.log).toHaveBeenCalled()
expect(mathjs.log).toHaveBeenCalledWith(10000, 10)
})</code></pre><p>You can also use <code>jest.fn().mockReturnValue('test')</code> to create a simple mock that does nothing except returning a value.</p><h4 id="pre-built-mocks">Pre-built mocks</h4><p>You can find pre-made mocks for popular libraries. For example this package <a href="https://github.com/jefflau/jest-fetch-mock" rel="noopener">https://github.com/jefflau/jest-fetch-mock</a> allows you to mock <code>fetch()</code> calls, and provide sample return values without interacting with the actual server in your tests.</p><h4 id="snapshot-testing">Snapshot testing</h4><p>Snapshot testing is a pretty cool feature offered by Jest. It can memorize how your UI components are rendered, and compare it to the current test, raising an error if there’s a mismatch.</p><p>This is a simple test on the App component of a simple <code>create-react-app</code> application (make sure you install <code>react-test-renderer</code>):</p><pre><code>import React from 'react'
import App from './App'
import renderer from 'react-test-renderer'
it('renders correctly', () =&gt; {
const tree = renderer.create(&lt;App /&gt;).toJSON()
expect(tree).toMatchSnapshot()
})</code></pre><p>the first time you run this test, Jest saves the snapshot to the <code>__snapshots__</code>folder. Here’s what App.test.js.snap contains:</p><pre><code class="language-js">// Jest Snapshot v1, https://goo.gl/fbAQLP
exports[`renders correctly 1`] = `
&lt;div
className="App"
&gt;
&lt;header
className="App-header"
&gt;
&lt;img
alt="logo"
className="App-logo"
src="logo.svg"
/&gt;
&lt;h1
className="App-title"
&gt;
Welcome to React
&lt;/h1&gt;
&lt;/header&gt;
&lt;p
className="App-intro"
&gt;
To get started, edit
&lt;code&gt;
src/App.js
&lt;/code&gt;
and save to reload.
&lt;/p&gt;
&lt;/div&gt;
› Press u to update failing snapshots.
› Press p to filter by a filename regex pattern.
› Press t to filter by a test name regex pattern.
› Press q to quit watch mode.
› Press Enter to trigger a test run.</code></pre><p>If your change is intended, pressing <code>u</code> will update the failing snapshots, and make the test pass.</p><p>You can also update the snapshot by running <code>jest -u</code> (or <code>jest --updateSnapshot</code>) outside of watch mode.</p><h3 id="testing-react-components">Testing React components</h3><p>The easiest way to start with testing React components is doing snapshot testing, a testing technique that lets you test components in isolation.</p><p>If you are familiar with testing software, it’s just like unit testing you do for classes: you test each component functionality.</p><p>I assume you created a React app with <code>create-react-app</code>, which already comes with <strong>Jest</strong> installed, the testing package we'll need.</p><p>Let’s start with a simple test. CodeSandbox is a great environment to try this out. Start with a React sandbox, and create an <code>App.js</code> component in a <code>components</code> folder, and add an <code>App.test.js</code> file.</p><pre><code>import React from 'react'
export default function App() {
return (
&lt;div className="App"&gt;
&lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;
&lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;
&lt;/div&gt;
)
}</code></pre><p>Our first test is dumb:</p><pre><code>test('First test', () =&gt; {
expect(true).toBeTruthy()
import Button from './Button'
const App = () =&gt; {
const [count, setCount] = useState(0)
const incrementCount = increment =&gt; {
setCount(count + increment)
}
return (
&lt;div&gt;
&lt;Button increment={1} onClickFunction={incrementCount} /&gt;
&lt;Button increment={10} onClickFunction={incrementCount} /&gt;
&lt;Button increment={100} onClickFunction={incrementCount} /&gt;
&lt;Button increment={1000} onClickFunction={incrementCount} /&gt;
&lt;span&gt;{count}&lt;/span&gt;
&lt;/div&gt;
)
}
export default App</code></pre><p>and the <code>Button.js</code> file:</p><pre><code>import React from 'react'
const Button = ({ increment, onClickFunction }) =&gt; {
const handleClick = () =&gt; {
onClickFunction(increment)
}
return &lt;button onClick={handleClick}&gt;+{increment}&lt;/button&gt;
}
export default Button</code></pre><p>We are going to use the <code>react-testing-library</code>, which is a great help as it allows us to inspect the output of every component and to apply events on them. You can read more about it on <a href="https://github.com/kentcdodds/react-testing-library" rel="noopener">https://github.com/kentcdodds/react-testing-library</a> or watch <a href="https://www.youtube.com/watch?v=JKOwJUM4_RM" rel="noopener">this video</a>.</p><p>Let’s test the Button component first.</p><p>We start by importing <code>render</code> and <code>fireEvent</code> from <code>react-testing-library</code>, two helpers. The first lets us render JSX. The second lets us emit events on a component.</p><p>Create a <code>Button.test.js</code> and put it in the same folder as <code>Button.js</code>.</p><pre><code>import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import Button from './Button'</code></pre><p>Buttons are used in the app to accept a click event and then they call a function passed to the <code>onClickFunction</code> prop. We add a <code>count</code> variable and we create a function that increments it:</p><pre><code>let count
const incrementCount = increment =&gt; {
count += increment
}</code></pre><p>Now off to the actual tests. We first initialize count to 0, and we render a <code>+1</code> <code>Button</code> component passing a <code>1</code> to <code>increment</code> and our <code>incrementCount</code> function to <code>onClickFunction</code>.</p><p>Then we get the content of the first child of the component, and we check it outputs <code>+1</code>.</p><p>We then proceed to clicking the button, and we check that the count got from 0 to 1:</p><pre><code>test('+1 Button works', () =&gt; {
count = 0
const { container } = render(
&lt;Button increment={1} onClickFunction={incrementCount} /&gt;
)
const button = container.firstChild
expect(button.textContent).toBe('+1')
expect(count).toBe(0)
fireEvent.click(button)
expect(count).toBe(1)
})</code></pre><p>Similarly we test a +100 button, this time checking the output is <code>+100</code> and the button click increments the count of 100.</p><pre><code class="language-js">test('+100 Button works', () =&gt; {
count = 0
const { container } = render(
&lt;Button increment={100} onClickFunction={incrementCount} /&gt;
)
const button = container.firstChild
expect(button.textContent).toBe('+100')
expect(count).toBe(0)
fireEvent.click(button)
expect(count).toBe(100)
})</code></pre><p>Let’s test the App component now. It shows 4 buttons and the result in the page. We can inspect each button and see if the result increases when we click them, clicking multiple times as well:</p><pre><code>import React from 'react'
import { render, fireEvent } from 'react-testing-library'
import App from './App'
test('App works', () =&gt; {
const { container } = render(&lt;App /&gt;)
console.log(container)
const buttons = container.querySelectorAll('button')
expect(buttons[0].textContent).toBe('+1')
expect(buttons[1].textContent).toBe('+10')
expect(buttons[2].textContent).toBe('+100')
expect(buttons[3].textContent).toBe('+1000')
const result = container.querySelector('span')
expect(result.textContent).toBe('0')
fireEvent.click(buttons[0])
expect(result.textContent).toBe('1')
fireEvent.click(buttons[1])
expect(result.textContent).toBe('11')
fireEvent.click(buttons[2])
expect(result.textContent).toBe('111')
fireEvent.click(buttons[3])
expect(result.textContent).toBe('1111')
fireEvent.click(buttons[2])
expect(result.textContent).toBe('1211')
fireEvent.click(buttons[1])
expect(result.textContent).toBe('1221')
fireEvent.click(buttons[0])
expect(result.textContent).toBe('1222')
})</code></pre><p>Check the code working on this CodeSandbox: <a href="https://codesandbox.io/s/pprl4y0wq" rel="noopener">https://codesandbox.io/s/pprl4y0wq</a></p><h3 id="section-8-the-react-ecosystem">SECTION 8: THE REACT ECOSYSTEM</h3><p>The ecosystem around React is huge. Here I introduce you to 4 of the most popular projects based upon React: React Router, Redux, Next.js, Gatsby.</p><h3 id="react-router">React Router</h3><p>React Router is the de-facto React routing library, and it’s one of the most popular projects built on top of React.</p><p>React at its core is a very simple library, and it does not dictate anything about routing.</p><p>Routing in a Single Page Application is the way to introduce some features to navigating the app through links, which are <strong>expected</strong> in normal web applications:</p><ol><li>The browser should <strong>change the URL</strong> when you navigate to a different screen</li><li><strong>Deep linking</strong> should work: if you point the browser to a URL, the application should reconstruct the same view that was presented when the URL was generated.</li><li>The <strong>browser back (and forward) button</strong> should work like expected.</li></ol><p><strong>Routing links together your application navigation with the navigation features offered by the browser</strong>: the <strong>address bar</strong> and the <strong>navigation buttons</strong>.</p><p>React Router offers a way to write your code so that <strong>it will show certain components of your app only if the route matches what you define</strong>.</p><h3 id="installation-2">Installation</h3><p>With <a href="https://flaviocopes.com/npm/" rel="noopener">npm</a>:</p><pre><code>npm install react-router-dom</code></pre><p>With <a href="https://flaviocopes.com/yarn/" rel="noopener">Yarn</a>:</p><pre><code class="language-bash">yarn add react-router-dom</code></pre><h3 id="types-of-routes">Types of routes</h3><p>React Router provides two different kind of routes:</p><ul><li><code>BrowserRouter</code></li><li><code>HashRouter</code></li></ul><p>One builds classic URLs, the other builds URLs with the hash:</p><pre><code>https://application.com/dashboard   /* BrowserRouter */
https://application.com/#/dashboard /* HashRouter    */</code></pre><p>Which one to use is mainly dictated by the browsers you need to support. <code>BrowserRouter</code> uses the <a href="https://flaviocopes.com/history-api/" rel="noopener">History API</a>, which is relatively recent, and not supported in IE9 and below. If you don't have to worry about older browsers, it's the recommended choice.</p><h3 id="components-1">Components</h3><p>The 3 components you will interact the most when working with React Router are:</p><ul><li><code>BrowserRouter</code>, usually aliased as <code>Router</code></li><li><code>Link</code></li><li><code>Route</code></li></ul><p><code>BrowserRouter</code> wraps all your Route components.</p><p><code>Link</code> components are - as you can imagine - used to generate links to your routes</p><p><code>Route</code> components are responsible for showing - or hiding - the components they contain.</p><h3 id="browserrouter">BrowserRouter</h3><p>Here’s a simple example of the BrowserRouter component. You import it from react-router-dom, and you use it to wrap all your app:</p><pre><code class="language-jsx">import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router } from 'react-router-dom'
ReactDOM.render(
&lt;Router&gt;
&lt;div&gt;
&lt;!-- --&gt;
&lt;/div&gt;
&lt;/Router&gt;,
document.getElementById('app')
)</code></pre><p>A BrowserRouter component can only have one child element, so we wrap all we’re going to add in a <code>div</code> element.</p><h3 id="link">Link</h3><p>The Link component is used to trigger new routes. You import it from <code>react-router-dom</code>, and you can add the Link components to point at different routes, with the <code>to</code> attribute:</p><pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Link } from 'react-router-dom'
ReactDOM.render(
&lt;Router&gt;
&lt;div&gt;
&lt;aside&gt;
&lt;Link to={`/dashboard`}&gt;Dashboard&lt;/Link&gt;
&lt;Link to={`/about`}&gt;About&lt;/Link&gt;
&lt;/aside&gt;
&lt;!-- --&gt;
&lt;/div&gt;
&lt;/Router&gt;,
document.getElementById('app')
)</code></pre><h3 id="route">Route</h3><p>Now let’s add the Route component in the above snippet to make things actually work as we want:</p><pre><code>import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Link, Route } from 'react-router-dom'
const Dashboard = () =&gt; (
&lt;div&gt;
&lt;h2&gt;Dashboard&lt;/h2&gt;
...
&lt;/div&gt;
)
const About = () =&gt; (
&lt;div&gt;
&lt;h2&gt;About&lt;/h2&gt;
...
&lt;/div&gt;
)
ReactDOM.render(
&lt;Router&gt;
&lt;div&gt;
&lt;aside&gt;
&lt;Link to={`/`}&gt;Dashboard&lt;/Link&gt;
&lt;Link to={`/about`}&gt;About&lt;/Link&gt;
&lt;/aside&gt;
&lt;main&gt;
&lt;Route exact path="/" component={Dashboard} /&gt;
&lt;Route path="/about" component={About} /&gt;
&lt;/main&gt;
&lt;/div&gt;
&lt;/Router&gt;,
document.getElementById('app')
)</code></pre><p>Check this example on Glitch: <a href="https://flaviocopes-react-router-v4.glitch.me/" rel="noopener">https://flaviocopes-react-router-v4.glitch.me/</a></p><p>When the route matches <code>/</code>, the application shows the <strong>Dashboard</strong> component.</p><p>When the route is changed by clicking the “About” link to <code>/about</code>, the Dashboard component is removed and the <strong>About</strong> component is inserted in the DOM.</p><p>Notice the <code>exact</code> attribute. Without this, <code>path="/"</code> would also match <code>/about</code>, since <code>/</code> is contained in the route.</p><h3 id="match-multiple-paths">Match multiple paths</h3><p>You can have a route respond to multiple paths simply using a regex, because <code>path</code> can be a regular expressions string:</p><pre><code>&lt;Route path="/(about|who)/" component={Dashboard} /&gt;</code></pre><h3 id="inline-rendering">Inline rendering</h3><p>Instead of specifying a <code>component</code> property on <code>Route</code>, you can set a <code>render</code> prop:</p><pre><code class="language-jsx">&lt;Route
path="/(about|who)/"
render={() =&gt; (
&lt;div&gt;
&lt;h2&gt;About&lt;/h2&gt;
...
&lt;/div&gt;
)}
/&gt;</code></pre><h3 id="match-dynamic-route-parameter">Match dynamic route parameter</h3><p>You already saw how to use static routes like</p><pre><code>const Posts = () =&gt; (
&lt;div&gt;
&lt;h2&gt;Posts&lt;/h2&gt;
...
&lt;/div&gt;
)
//...
&lt;Route exact path="/posts" component={Posts} /&gt;</code></pre><p>Here’s how to handle dynamic routes:</p><pre><code>const Post = ({match}) =&gt; (
&lt;div&gt;
&lt;h2&gt;Post #{match.params.id}&lt;/h2&gt;
...
&lt;/div&gt;
)
//...
&lt;Route exact path="/post/:id" component={Post} /&gt;</code></pre><p>In your Route component you can lookup the dynamic parameters in <code>match.params</code>.</p><p><code>match</code> is also available in inline rendered routes, and this is especially useful in this case, because we can use the <code>id</code> parameter to lookup the post data in our data source before rendering Post:</p><pre><code>const posts = [
{ id: 1, title: 'First', content: 'Hello world!' },
{ id: 2, title: 'Second', content: 'Hello again!' }
]
const Post = ({post}) =&gt; (
&lt;div&gt;
&lt;h2&gt;{post.title}&lt;/h2&gt;
{post.content}
&lt;/div&gt;
)
//...
&lt;Route exact path="/post/:id" render={({match}) =&gt; (
&lt;Post post={posts.find(p =&gt; p.id === match.params.id)} /&gt;
)} /&gt;</code></pre><h3 id="redux">Redux</h3><p>Redux is a state manager that’s usually used along with React, but it’s not tied to that library — it can be used with other technologies as well, but we’ll stick to React for the sake of the explanation..</p><p>Redux is a way to manage an application state, and move it to an <strong>external global store</strong>.</p><p>There are a few concepts to grasp, but once you do, Redux is a very simple approach to the problem.</p><p>Redux is very popular with React applications, but it’s in no way unique to React: there are bindings for nearly any popular framework. That said, I’ll make some examples using React as it is its primary use case.</p><h4 id="when-should-you-use-redux">When should you use Redux?</h4><p>Redux is ideal for medium to big apps, and you should only use it when you have trouble managing the state with the default state management of React, or the other library you use.</p><p>Simple apps should not need it at all (and there’s nothing wrong with simple apps).</p><h4 id="immutable-state-tree">Immutable State Tree</h4><p>In Redux, the whole state of the application is represented by <strong>one</strong> <a href="https://flaviocopes.com/javascript/" rel="noopener">JavaScript</a> object, called <strong>State</strong> or <strong>State Tree</strong>.</p><p>We call it <strong>Immutable State Tree</strong> because it is read only: it can’t be changed directly.</p><p>It can only be changed by dispatching an <strong>Action</strong>.</p><h4 id="actions">Actions</h4><p>An <strong>Action</strong> is <strong>a JavaScript object that describes a change in a minimal way</strong> (with just the information needed):</p><pre><code class="language-js">{
type: 'CLICKED_SIDEBAR'
}
// e.g. with more data
{
type: 'SELECTED_USER',
userId: 232
}</code></pre><p>The only requirement of an action object is having a <code>type</code> property, whose value is usually a string.</p><h4 id="actions-types-should-be-constants">Actions types should be constants</h4><p>In a simple app an action type can be defined as a string, as I did in the example in the previous lesson.</p><p>When the app grows is best to use constants:</p><pre><code>const ADD_ITEM = 'ADD_ITEM'
const action = { type: ADD_ITEM, title: 'Third item' }</code></pre><p>and to separate actions in their own files, and import them</p><pre><code>import { ADD_ITEM, REMOVE_ITEM } from './actions'</code></pre><h4 id="action-creators">Action creators</h4><p><strong>Actions Creators</strong> are functions that create actions.</p><pre><code>function addItem(t) {
return {
type: ADD_ITEM,
title: t
}
}</code></pre><p>You usually run action creators in combination with triggering the dispatcher:</p><pre><code>dispatch(addItem('Milk'))</code></pre><p>or by defining an action dispatcher function:</p><pre><code>const dispatchAddItem = i =&gt; dispatch(addItem(i))
dispatchAddItem('Milk')</code></pre><h4 id="reducers">Reducers</h4><p>When an action is fired, something must happen, the state of the application must change.</p><p>This is the job of <strong>reducers</strong>.</p><p>A <strong>reducer</strong> is a <strong>pure function</strong> that calculates the next State Tree based on the previous State Tree, and the action dispatched.</p><pre><code class="language-jsx">;(currentState, action) =&gt; newState</code></pre><p>A pure function takes an input and returns an output without changing the input or anything else. Thus, a reducer returns a completely new state tree object that substitutes the previous one.</p><h4 id="what-a-reducer-should-not-do">What a reducer should not do</h4><p>A reducer should be a pure function, so it should:</p><ul><li>never mutate its arguments</li><li>never mutate the state, but instead create a new one with <code>Object.assign({}, ...)</code></li><li>never generate side-effects (no API calls changing anything)</li><li>never call non-pure functions, functions that change their output based on factors other than their input (e.g. <code>Date.now()</code> or <code>Math.random()</code>)</li></ul><p>There is no reinforcement, but you should stick to the rules.</p><h4 id="multiple-reducers">Multiple reducers</h4><p>Since the state of a complex app could be really wide, there is not a single reducer, but many reducers for any kind of action.</p><h4 id="a-simulation-of-a-reducer">A simulation of a reducer</h4><p>At its core, Redux can be simplified with this simple model:</p><h4 id="the-state">The state</h4><pre><code>{
list: [
{ title: "First item" },
{ title: "Second item" },
],
title: 'Groceries list'
}</code></pre><h4 id="a-list-of-actions">A list of actions</h4><pre><code>{ type: 'ADD_ITEM', title: 'Third item' }
{ type: 'REMOVE_ITEM', index: 1 }
{ type: 'CHANGE_LIST_TITLE', title: 'Road trip list' }</code></pre><h4 id="a-reducer-for-every-part-of-the-state">A reducer for every part of the state</h4><pre><code>const title = (state = '', action) =&gt; {
if (action.type === 'CHANGE_LIST_TITLE') {
return action.title
} else {
return state
}
}
const list = (state = [], action) =&gt; {
switch (action.type) {
case 'ADD_ITEM':
return state.concat([{ title: action.title }])
case 'REMOVE_ITEM':
return state.map((item, index) =&gt;
action.index === index
? { title: item.title }
: item
default:
return state
}
}</code></pre><h4 id="a-reducer-for-the-whole-state">A reducer for the whole state</h4><pre><code>const listManager = (state = {}, action) =&gt; {
return {
title: title(state.title, action),
list: list(state.list, action)
}
}</code></pre><h4 id="the-store">The Store</h4><p>The <strong>Store</strong> is an object that:</p><ul><li><strong>holds the state</strong> of the app</li><li><strong>exposes the state</strong> via <code>getState()</code></li><li>allows us to <strong>update the state</strong> via <code>dispatch()</code></li><li>allows us to (un)register a <strong>state change listener</strong> using <code>subscribe()</code></li></ul><p>A store is <strong>unique</strong> in the app.</p><p>Here is how a store for the listManager app is created:</p><pre><code>import { createStore } from 'redux'
import listManager from './reducers'
let store = createStore(listManager)</code></pre><h4 id="can-i-initialize-the-store-with-server-side-data">Can I initialize the store with server-side data?</h4><p>Sure, <strong>just pass a starting state</strong>:</p><pre><code>let store = createStore(listManager, preexistingState)</code></pre><h4 id="getting-the-state">Getting the state</h4><pre><code>store.getState()</code></pre><h4 id="update-the-state">Update the state</h4><pre><code>store.dispatch(addItem('Something'))</code></pre><h4 id="listen-to-state-changes">Listen to state changes</h4><pre><code>const unsubscribe = store.subscribe(() =&gt;
const newState = store.getState()
)
unsubscribe()</code></pre><h4 id="data-flow">Data Flow</h4><p>Data flow in Redux is always <strong>unidirectional</strong>.</p><p>You call <code>dispatch()</code> on the Store, passing an Action.</p><p>The Store takes care of passing the Action to the Reducer, generating the next State.</p><p>The Store updates the State and alerts all the Listeners.</p><h3 id="next-js">Next.js</h3><p>Working on a modern <a href="https://flaviocopes.com/javascript/" rel="noopener">JavaScript</a> application powered by <a href="https://flaviocopes.com/react/" rel="noopener">React</a> is awesome until you realize that there are a couple problems related to rendering all the content on the client-side.</p><p>First, the page takes longer to the become visible to the user, because before the content loads, all the JavaScript must load, and your application needs to run to determine what to show on the page.</p><p>Second, if you are building a publicly available website, you have a content SEO issue. Search engines are getting better at running and indexing JavaScript apps, but it’s much better if we can send them content instead of letting them figure it out.</p><p>The solution to both of those problems is <strong>server rendering</strong>, also called <strong>static pre-rendering</strong>.</p><p>Next.js is one React framework to do all of this in a very simple way, but it’s not limited to this. It’s advertised by its creators as a <strong>zero-configuration, single-command toolchain for React apps</strong>.</p><p>It provides a common structure that allows you to easily build a frontend React application, and transparently handle server-side rendering for you.</p><p>Here is a non-exhaustive list of the main Next.js features:</p><ul><li><strong>Hot Code Reloading</strong>: Next.js reloads the page when it detects any change saved to disk.</li><li><strong>Automatic Routing</strong>: any URL is mapped to the filesystem, to files put in the <code>pages</code> folder, and you don’t need any configuration (you have customization options of course).</li><li><strong>Single File Components</strong>: using <a href="https://github.com/zeit/styled-jsx" rel="noopener">styled-jsx</a>, completely integrated as built by the same team, it’s trivial to add styles scoped to the component.</li><li><strong>Server Rendering</strong>: you can (optionally) render React components on the server side, before sending the HTML to the client.</li><li><strong>Ecosystem Compatibility</strong>: Next.js plays well with the rest of the JavaScript, Node and React ecosystem.</li><li><strong>Automatic Code Splitting</strong>: pages are rendered with just the libraries and JavaScript that they need, no more.</li><li><strong>Prefetching</strong>: the <code>Link</code> component, used to link together different pages, supports a <code>prefetch</code> prop which automatically prefetches page resources (including code missing due to code splitting) in the background.</li><li><strong>Dynamic Components</strong>: you can import JavaScript modules and React Components dynamically (<a href="https://github.com/zeit/next.js#dynamic-import" rel="noopener">https://github.com/zeit/next.js#dynamic-import</a>).</li><li><strong>Static Exports</strong>: using the <code>next export</code> command, Next.js allows you to export a fully static site from your app.</li></ul><h4 id="installation-3">Installation</h4><p>Next.js supports all the major platforms: Linux, macOS, Windows.</p><p>A Next.js project is started easily with npm:</p><pre><code>npm install next react react-dom</code></pre><p>or with <a href="https://flaviocopes.com/yarn/" rel="noopener">Yarn</a>:</p><pre><code>yarn add next react react-dom</code></pre><h4 id="getting-started">Getting started</h4><p>Create a <code>package.json</code> file with this content:</p><pre><code>{
"scripts": {
"dev": "next"
}
&lt;div&gt;
&lt;p&gt;Hello World!&lt;/p&gt;
&lt;/div&gt;
)</code></pre><p>If you visit <code>localhost:3000</code>, this component will automatically be rendered.</p><p>Why is this so simple?</p><p>Next.js uses a declarative pages structure, which is based on the filesystem structure.</p><p>Simply put, pages are inside a <code>pages</code> folder, and the page URL is determined by the page file name. The filesystem is the pages API.</p><h4 id="server-side-rendering-1">Server-side rendering</h4><p>Open the page source, <code>View -&gt; Developer -&gt; View </code>Source with Chrome.</p><p>As you can see, the HTML generated by the component is sent directly in the page source. It’s not rendered client-side, but instead it’s rendered on the server.</p><p>The Next.js team wanted to create a developer experience for server rendered pages similar to the one you get when creating a basic PHP project, where you simply drop PHP files and you call them, and they show up as pages. Internally of course it’s all very different, but the apparent ease of use is clear.</p><h4 id="add-a-second-page">Add a second page</h4><p>Let’s create another page, in <code>pages/contact.js</code></p><pre><code>export default () =&gt; (
&lt;div&gt;
&lt;p&gt;
&lt;a href="mailto:my@email.com"&gt;Contact us!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
)</code></pre><p>If you point your browser to <code>localhost:3000/contact</code> this page will be rendered. As you can see, also this page is server rendered.</p><h4 id="hot-reloading">Hot reloading</h4><p>Note how you did not have to restart the <code>npm</code> process to load the second page. Next.js does this for you under the hood.</p><h4 id="client-rendering">Client rendering</h4><p>Server rendering is very convenient in your first page load, for all the reasons we saw above, but when it comes to navigating inside the website, client-side rendering is key to speeding up the page load and improving the user experience.</p><p>Next.js provides a <code>Link</code> component you can use to build links. Try linking the two pages above.</p><p>Change <code>index.js</code> to this code:</p><pre><code class="language-jsx">import Link from 'next/link'
export default () =&gt; (
&lt;div&gt;
&lt;p&gt;Hello World!&lt;/p&gt;
&lt;Link href="/contact"&gt;
&lt;a&gt;Contact me!&lt;/a&gt;
&lt;/Link&gt;
&lt;/div&gt;
)</code></pre><p>Now go back to the browser and try this link. As you can see, the Contact page loads immediately, without a page refresh.</p><p>This is client-side navigation working correctly, with complete support for the <a href="https://flaviocopes.com/history-api/" rel="noopener"><strong>History API</strong></a>, which means your users back button won’t break.</p><p>If you now <code>cmd-click</code> the link, the same Contact page will open in a new tab, now server rendered.</p><h4 id="dynamic-pages">Dynamic pages</h4><p>A good use case for Next.js is a blog, as it’s something that all developers know how it works, and it’s a good fit for a simple example of how to handle dynamic pages.</p><p>A dynamic page is a page that has no fixed content, but instead display some data based on some parameters.</p><p>Change <code>index.js</code> to</p><pre><code class="language-jsx">import Link from 'next/link'
const Post = props =&gt; (
&lt;li&gt;
&lt;Link href={`/post?title=${props.title}`}&gt;
&lt;a&gt;{props.title}&lt;/a&gt;
&lt;/Link&gt;
&lt;/li&gt;
)
export default () =&gt; (
&lt;div&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;Post title="Yet another post" /&gt;
&lt;Post title="Second post" /&gt;
&lt;Post title="Hello, world!" /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
const Post = props =&gt; (
&lt;li&gt;
&lt;Link as={`/${props.slug}`} href={`/post?title=${props.title}`}&gt;
&lt;a&gt;{props.title}&lt;/a&gt;
&lt;/Link&gt;
&lt;/li&gt;
)
export default () =&gt; (
&lt;div&gt;
&lt;h2&gt;My blog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;Post slug="yet-another-post" title="Yet another post" /&gt;
&lt;Post slug="second-post" title="Second post" /&gt;
&lt;Post slug="hello-world" title="Hello, world!" /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
)</code></pre><h4 id="css-in-js">CSS-in-JS</h4><p>Next.js by default provides support for <a href="https://github.com/zeit/styled-jsx" rel="noopener">styled-jsx</a>, which is a CSS-in-JS solution provided by the same development team, but you can use whatever library you prefer, like Styled Components.</p><p>Example:</p><pre><code class="language-jsx">export default () =&gt; (
&lt;div&gt;
&lt;p&gt;
&lt;a href="mailto:my@email.com"&gt;Contact us!&lt;/a&gt;
&lt;/p&gt;
&lt;style jsx&gt;{`
p {
font-family: 'Courier New';
}
a {
text-decoration: none;
color: black;
}
a:hover {
opacity: 0.8;
}
`}&lt;/style&gt;
&lt;/div&gt;
)</code></pre><p>Styles are scoped to the component, but you can also edit global styles adding <code>global</code> to the <code>style</code> element:</p><pre><code class="language-jsx">export default () =&gt; (
&lt;div&gt;
&lt;p&gt;
&lt;a href="mailto:my@email.com"&gt;Contact us!&lt;/a&gt;
&lt;/p&gt;
&lt;style jsx global&gt;{`
body {
font-family: 'Benton Sans', 'Helvetica Neue';
margin: 2em;
}
h2 {
font-style: italic;
color: #373fff;
}
`}&lt;/style&gt;
&lt;/div&gt;
)</code></pre><h4 id="exporting-a-static-site">Exporting a static site</h4><p>A Next.js application can be easily exported as a static site, which can be deployed on one of the super fast static site hosts, like <a href="https://flaviocopes.com/netlify/" rel="noopener">Netlify</a> or <a href="https://flaviocopes.com/firebase-hosting/" rel="noopener">Firebase Hosting</a>, without the need to set up a Node environment.</p><p>The process requires you to declare the URLs that compose the site, but it’s <a href="https://github.com/zeit/next.js/#static-html-export" rel="noopener">a straightforward process</a>.</p><h4 id="deploying">Deploying</h4><p>Creating a production-ready copy of the application, without source maps or other development tooling that aren’t needed in the final build, is easy.</p><p>At the beginning of this tutorial you created a <code>package.json</code> file with this content:</p><pre><code class="language-json">{
"scripts": {
"dev": "next"
}
}</code></pre><p>which was the way to start up a development server using <code>npm run dev</code>.</p><p>Now just add the following content to <code>package.json</code> instead:</p><pre><code class="language-json">{
"scripts": {
"dev": "next",
"build": "next build",
"start": "next start"
}
margin: '0 auto',
padding: '20px'
}}&gt;Hello world&lt;/p&gt;</code></pre><h4 id="using-plugins">Using plugins</h4><p>Gatsby provides lots of things out of the box, but many other functionalities are provided by <a href="https://www.gatsbyjs.org/plugins/" rel="noopener">plugins</a>.</p><p>There are 3 kind of plugins:</p><ul><li><strong>source plugins</strong> fetch data from a source. Create nodes that can be then filtered by transformer plugins</li><li><strong>transformer plugins</strong> transform the data provided by source plugins into something Gatsby can use</li><li><strong>functional plugins</strong> implement some kind of functionality, like adding sitemap support or more</li></ul><p>Some commonly used plugins are:</p><ul><li><a href="https://www.gatsbyjs.org/packages/gatsby-plugin-react-helmet/" rel="noopener">gatsby-plugin-react-helmet</a> which allows to edit the <code>head</code> tag content</li><li><a href="https://www.gatsbyjs.org/packages/gatsby-plugin-catch-links/" rel="noopener">gatsby-plugin-catch-links</a> which uses the <a href="https://flaviocopes.com/history-api/" rel="noopener">History API</a> to prevent the browser reloading the page when a link is clicked, loading the new content using AJAX instead</li></ul><p>A Gatsby plugin is installed in 2 steps. First you install it using <code>npm</code>, then you add it to the Gatsby configuration in <code>gatsby-config.js</code>.</p><p>For example you can install the Catch Links plugin:</p><pre><code>npm install gatsby-plugin-catch-links</code></pre><p>In <code>gatsby-config.js</code> (create it if you don’t have it, in the website root folder), add the plugin to the <code>plugins</code> exported array:</p><pre><code>module.exports = {
plugins: ['gatsby-plugin-catch-links']
}</code></pre><p>That’s it, the plugin will now do its job.</p><h4 id="building-the-static-website">Building the static website</h4><p>Once you are done tweaking the site and you want to generate the production static site, you will call</p><pre><code class="language-jsx">gatsby build</code></pre><p>At this point you can check that it all works as you expect by starting a local Web Server using</p><pre><code class="language-jsx">gatsby serve</code></pre><p>which will render the site as close as possible to how you will see it in production.</p><h4 id="deployment">Deployment</h4><p>Once you build the site using <code>gatsby build</code>, all you need to do is to deploy the result contained in the <code>public</code> folder.</p><p>Depending on the solution you choose, you’ll need different steps here, but generally you’ll push to a Git repository and let the Git post-commit hooks do the job of deploying. <a href="https://www.gatsbyjs.org/docs/deploying-and-hosting/" rel="noopener">Here are some great guides for some popular hosting platforms</a> where you can deploy Gatsby.</p><h3 id="wrapping-up">Wrapping up</h3><p>I hope this book has helped you get started with React, and maybe it gave you a head start in exploring some of the most advanced aspects of React programming. That’s my hope, at least.</p><blockquote>You can get this ebook in PDF, ePub and Mobi format at <a href="https://reacthandbook.com" rel="noopener">reacthandbook.com</a></blockquote>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
