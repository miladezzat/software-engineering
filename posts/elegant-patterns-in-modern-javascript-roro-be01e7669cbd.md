---
card: "https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg"
tags: [JavaScript]
description: "I wrote my first few lines of JavaScript not long after the l"
author: "Milad E. Fahmy"
title: "Elegant patterns in modern JavaScript: RORO"
created: "2021-08-16T10:16:55+02:00"
modified: "2021-08-16T10:16:55+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-javascript tag-programming tag-web-development tag-learning-to-code tag-software-development ">
<header class="post-full-header">
<h1 class="post-full-title">Elegant patterns in modern JavaScript: RORO</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg 300w,
https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg 600w,
https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg 1000w,
https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*8VFNi44ikZ172fiUYz5pGA.jpeg" alt="Elegant patterns in modern JavaScript: RORO">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
<p>I wrote my first few lines of JavaScript not long after the language was invented. If you told me at the time that I would one day be writing <a href="https://medium.com/search?q=Elegant%20patterns%20in%20JavaScript" rel="noopener">a series of articles</a> about <strong>elegant</strong> patterns in JavaScript, I would have laughed you out of the room. I thought of JavaScript as a strange little language that barely even qualified as “real programming.”</p><p>Well, a lot has changed in the 20 years since then. I now see in JavaScript what <a href="https://en.wikipedia.org/wiki/Douglas_Crockford" rel="noopener">Douglas Crockford</a> saw when he wrote <em>JavaScript: The Good Parts</em>: “An outstanding, dynamic programming language … with enormous, expressive power.”</p><p>So, without further ado, here is a wonderful little pattern I’ve been using in my code lately. I hope you come to enjoy it as much as I have.</p><blockquote><strong><em>Please note</em></strong><em>: I’m pretty sure I did not invent any of this. Chances are I came across it in other people’s code and eventually adopted it myself.</em></blockquote><h3 id="receive-an-object-return-an-object-roro-">Receive an object, return an object (RORO).</h3><p>Most of my functions now accept a single parameter of type <code>object</code> and many of them return or resolve to a value of type <code>object</code> as well.</p><p>Thanks in part to the <em>destructuring</em> feature introduced in ES2015, I’ve found this to be a powerful pattern. I’ve even given it the silly name, “RORO” because… branding? ¯\_(ツ)_/¯</p><blockquote><strong><em>Note: </em></strong><em>Destructuring is one of my favorite features of modern JavaScript. We’re going to be taking advantage of it quite a bit throughout this article, so if you’re not familiar with it, here’s a quick video to get you up to speed.</em></blockquote><p>Here are some reasons why you’ll love this pattern:</p><ul><li>Named parameters</li><li>Cleaner default parameters</li><li>Richer return values</li><li>Easy function composition</li></ul><p>Let’s look at each one.</p><h4 id="named-parameters">Named Parameters</h4><p>Suppose we have a function that returns a list of Users in a given Role and suppose we need to provide an option for including each User’s Contact Info and another option for including Inactive Users, traditionally we might write:</p><pre><code>function findUsersByRole (  role,   withContactInfo,   includeInactive) {...}</code></pre><p>A call to this function might then look like:</p><pre><code>findUsersByRole(  'admin',   true,   true)</code></pre><p>Notice how ambiguous those last two parameters are. What does “true, true” refer to?</p><p>What happens if our app almost never needs Contact Info but almost always needs Inactive Users? We have to contend with that middle parameter all the time, even though it’s not really relevant (more on that later).</p><p>In short, this traditional approach leaves us with potentially ambiguous, noisy code that’s harder to understand and trickier to write.</p><p>Let’s see what happens when we receive a single object instead:</p><pre><code>function findUsersByRole ({  role,  withContactInfo,   includeInactive}) {...}</code></pre><p>Notice our function looks almost identical except that <strong>we’ve put braces around our parameters</strong>. This indicates that instead of receiving three distinct parameters, our function now expects a single object with properties named <code>role</code>, <code>withContactInfo</code>, and <code>includeInactive</code>.</p><p>This works because of a JavaScript feature introduced in ES2015 called <em>Destructuring</em>.</p><p>Now we can call our function like this:</p><pre><code>findUsersByRole({  role: 'admin',   withContactInfo: true,   includeInactive: true})</code></pre><p>This is far less ambiguous and a lot easier to read and understand. Plus, omitting or re-ordering our parameters is no longer an issue since they are now the named properties of an object.</p><p>For example, this works:</p><pre><code>findUsersByRole({  withContactInfo: true,  role: 'admin',   includeInactive: true})</code></pre><p>And so does this:</p><pre><code>findUsersByRole({  role: 'admin',   includeInactive: true})</code></pre><p>This also makes it possible to add new parameters without breaking old code.</p><p>One important note here is that if we want all the parameters to be optional, in other words, if the following is a valid call…</p><pre><code>findUsersByRole()</code></pre><p>… we need to set a default value for our parameter object, like so:</p><pre><code>function findUsersByRole ({  role,  withContactInfo,   includeInactive} = {}) {...}</code></pre><p>An added benefit of using destructuring for our parameter object is that it promotes immutability. When we destructure the <code>object</code> on its way into our function we assign the object’s properties to new variables. Changing the value of those variables will not alter the original object.</p><p>Consider the following:</p><pre><code>const options = {  role: 'Admin',  includeInactive: true}</code></pre><pre><code>findUsersByRole(options)</code></pre><pre><code>function findUsersByRole ({  role,  withContactInfo,   includeInactive} = {}) {  role = role.toLowerCase()  console.log(role) // 'admin'  ...}</code></pre><pre><code>console.log(options.role) // 'Admin'</code></pre><p>Even though we change the value of <code>role</code> the value of <code>options.role</code> remains unchanged.</p><blockquote><strong><em>Edit:</em></strong><em> It’s worth noting that destructuring makes a <strong>shallow</strong> copy so if any of the properties of our parameter object are of a complex type (e.g. <code>array</code> or <code>object</code>) changing them would indeed affect the original.</em></blockquote><blockquote><em>(Hat tip to <a href="undefined" rel="noopener">Yuri Homyakov</a> for <a href="https://medium.com/@yurik1776/hey-bill-569e596030b7" rel="noopener">pointing this out</a>)</em></blockquote><p>So far, so good, yeah?</p><h4 id="cleaner-default-parameters">Cleaner Default Parameters</h4><p>With ES2015 JavaScript functions gained the ability to define default parameters. In fact, we recently used a default parameter when we added <code>={}</code> to the parameter object on our <code>findUsersByRole</code> function above.</p><p>With traditional default parameters, our <code>findUsersByRole</code> function might look like this.</p><pre><code>function findUsersByRole (  role,   withContactInfo = true,   includeInactive) {...}</code></pre><p>If we want to set <code>includeInactive</code> to <code>true</code> we have to explicitly pass <code>undefined</code> as the value for <code>withContactInfo</code> to preserve the default, like this:</p><pre><code>findUsersByRole(  'Admin',   undefined,   true)</code></pre><p>How hideous is that?</p><p>Compare it to using a parameter object like so:</p><pre><code>function findUsersByRole ({  role,  withContactInfo = true,   includeInactive} = {}) {...}</code></pre><p>Now we can write…</p><pre><code>findUsersByRole({  role: ‘Admin’,  includeInactive: true})</code></pre><p>… and our default value for <code>withContactInfo</code> is preserved.</p><h4 id="bonus-required-parameters">BONUS: Required Parameters</h4><p>How often have you written something like this?</p><pre><code>function findUsersByRole ({  role,   withContactInfo,   includeInactive} = {}) {  if (role == null) {      throw Error(...)  }  ...}</code></pre><blockquote><strong><em>Note:</em></strong><em> We use <code>==</code> (double equals) above to test for both <code>null</code> and <code>undefined</code> with a single statement.</em></blockquote><p>What if I told you that you could use default parameters to validate required parameters instead?</p><p>First, we need to define a <code>requiredParam()</code> function that throws an Error.</p><p>Like this:</p><pre><code>function requiredParam (param) {  const requiredParamError = new Error(   `Required parameter, "${param}" is missing.`  )</code></pre><pre><code>  // preserve original stack trace  if (typeof Error.captureStackTrace === ‘function’) {    Error.captureStackTrace(      requiredParamError,       requiredParam    )  }</code></pre><pre><code>  throw requiredParamError}</code></pre><blockquote><em>I know, I know. requiredParam doesn’t RORO. That’s why I said <strong>many</strong> of my functions — not <strong>all</strong>.</em></blockquote><p>Now, we can set an invocation of <code>requiredParam</code> as the default value for <code>role</code>, like so:</p><pre><code>function findUsersByRole ({  role = requiredParam('role'),  withContactInfo,   includeInactive} = {}) {...}</code></pre><p>With the above code, if anyone calls <code>findUsersByRole</code> without supplying a <code>role</code> they will get an <code>Error</code> that says <code>Required parameter, “role” is missing.</code></p><p>Technically, we can use this technique with regular default parameters as well; we don’t necessarily need an object. But this trick was too useful not to mention.</p><h4 id="richer-return-values">Richer Return Values</h4><p>JavaScript functions can only return a single value. If that value is an <code>object</code> it can contain a lot more information.</p><p>Consider a function that saves a <code>User</code> to a database. When that function returns an object it can provide a lot of information to the caller.</p><p>For example, a common pattern is to “upsert” or “merge” data in a save function. Which means, we insert rows into a database table (if they do not already exist) or update them (if they do exist).</p><p>In such cases, it would be handy to know wether the operation performed by our Save function was an <code>INSERT</code> or an <code>UPDATE</code>. It would also be good to get an accurate representation of exactly what was stored in the database, and it would be good to know the status of the operation; did it succeed, is it pending as part of a larger transaction, did it timeout?</p><p>When returning an object, it’s easy to communicate all of this info at once.</p><p>Something like:</p><pre><code>async saveUser({  upsert = true,  transaction,  ...userInfo}) {  // save to the DB  return {    operation, // e.g 'INSERT'    status, // e.g. 'Success'    saved: userInfo  }}</code></pre><p>Technically, the above returns a <code>Promise</code> that resolves to an <code>object</code> but you get the idea.</p><h4 id="easy-function-composition">Easy Function Composition</h4><blockquote>“Function composition is the process of combining two or more functions to produce a new function. Composing functions together is like snapping together a series of pipes for our data to flow through.” — <a href="undefined" rel="noopener">Eric Elliott</a></blockquote><p>We can compose functions together using a <code>pipe</code> function that looks something like this:</p><pre><code>function pipe(...fns) {   return param =&gt; fns.reduce(    (result, fn) =&gt; fn(result),     param  )}</code></pre><p>The above function takes a list of functions and returns a function that can apply the list from left to right, starting with a given parameter and then passing the result of each function in the list to the next function in the list.</p><p>Don’t worry if you’re confused, there’s an example below that should clear things up.</p><p>One limitation of this approach is that each function in the list must only receive a single parameter. Luckily, when we RORO that’s not a problem!</p><p>Here’s an example where we have a <code>saveUser</code> function that pipes a <code>userInfo</code> object through 3 separate functions that validate, normalize, and persist the user information in sequence.</p><pre><code>function saveUser(userInfo) {  return pipe(    validate,    normalize,    persist  )(userInfo)}</code></pre><p>We can use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener">rest parameter</a> in our <code>validate</code>, <code>normalize</code>, and <code>persist</code> functions to destructure only the values that each function needs and still pass everything back to the caller.</p><p>Here’s a bit of code to give you the gist of it:</p><pre><code>function validate({  id,  firstName,  lastName,  email = requiredParam(),  username = requiredParam(),  pass = requiredParam(),  address,  ...rest}) {  // do some validation  return {    id,    firstName,    lastName,    email,    username,    pass,    address,    ...rest  }}</code></pre><pre><code>function normalize({  email,  username,  ...rest}) {  // do some normalizing  return {    email,    username,    ...rest  }}</code></pre><pre><code>async function persist({  upsert = true,  ...info}) {  // save userInfo to the DB  return {    operation,    status,    saved: info  }}</code></pre><h4 id="to-ro-or-not-to-ro-that-is-the-question-">To RO or not to RO, that is the question.</h4><p>I said at the outset, <strong>most</strong> of my functions receive an object and <strong>many </strong>of them return an object too.</p><p>Like any pattern, RORO should be seen as just another tool in our tool box. We use it in places where it adds value by making a list of parameters more clear and flexible and by making a return value more expressive.</p><p>If you’re writing a function that will only ever need to receive a single parameter, then receiving an <code>object</code> is overkill. Likewise, if you’re writing a function that can communicate a clear and intuitive response to the caller by returning a simple value, there is no need to return an <code>object</code>.</p><p>An example where I almost never RORO is assertion functions. Suppose we have a function <code>isPositiveInteger</code> that checks wether or not a given parameter is a positive integer, such a function likely wouldn’t benefit from RORO at all.</p><p>If you enjoyed this article, please smash the applause icon a bunch of times to help spread the word. And if you want to read more stuff like this, please sign up for my Dev Mastery newsletter below.</p>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
