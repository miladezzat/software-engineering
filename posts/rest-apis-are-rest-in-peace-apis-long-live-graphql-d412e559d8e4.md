---
card: "https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png"
tags: [GraphQL]
description: "After years of dealing with REST APIs, when I first learned a"
author: "Milad E. Fahmy"
title: "REST APIs are REST-in-Peace APIs. Long Live GraphQL."
created: "2021-08-16T11:50:30+02:00"
modified: "2021-08-16T11:50:30+02:00"
---
<div class="site-wrapper">
<main id="site-main" class="site-main outer">
<div class="inner">
<article class="post-full post tag-graphql tag-javascript tag-web-development tag-technology tag-programming ">
<header class="post-full-header">
<h1 class="post-full-title">REST APIs are REST-in-Peace APIs. Long Live GraphQL.</h1>
</header>
<figure class="post-full-image">
<picture>
<source media="(max-width: 700px)" sizes="1px" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 1w">
<source media="(min-width: 701px)" sizes="(max-width: 800px) 400px,
(max-width: 1170px) 700px,
1400px" srcset="https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png 300w,
https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png 600w,
https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png 1000w,
https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png 2000w">
<img onerror="this.style.display='none'" src="https://cdn-media-1.freecodecamp.org/images/1*2mTYU2RCJHagQrqQokYpww.png" alt="REST APIs are REST-in-Peace APIs. Long Live GraphQL.">
</picture>
</figure>
<section class="post-full-content">
<div class="post-content">
"data":{
"person":{
"name":"Darth Vader",
"birthYear":"41.9BBY",
"planet":{
"name":"Tatooine"
},
"films":[
{
"title":"A New Hope"
},
{
"title":"The Empire Strikes Back"
},
{
"title":"Return of the Jedi"
},
{
"title":"Revenge of the Sith"
}
]
}
}
}</code></pre><p>Assuming a data service gave us this exact structure for the data, here’s one possible way to represent its view with React.js:</p><pre><code>// The Container Component:&lt;PersonProfile person={data.person} &gt;&lt;/PersonProfile&gt;</code></pre><pre><code>// The PersonProfile Component:Name: {person.name}Birth Year: {person.birthYear}Planet: {person.planet.name}Films: {person.films.map(film =&gt; film.title)}</code></pre><p>This is a simple example, and while our experience with Star Wars might have helped us here a bit, the relationship between the UI and the data is very clear. The UI used all the “keys” from the JSON data object we imagined.</p><p>Let’s now see how we can ask for this data using a RESTful API.</p><p>We need a single person’s information, and assuming that we know the ID of that person, a RESTful API is expected to expose that information as:</p><pre><code>GET - /people/{id}</code></pre><p>This request will give us the name, birthYear, and other information about the person. A good RESTful API will also give us the ID of this person’s planet and an array of IDs for all the films this person appeared in.</p><p>The JSON response for this request could be something like:</p><pre><code>{  "name": "Darth Vader",  "birthYear": "41.9BBY",  "planetId": 1  "filmIds": [1, 2, 3, 6],  *** other information we do not need ***}</code></pre><p>Then to read the planet’s name, we ask:</p><pre><code>GET - /planets/1</code></pre><p>And to read the films titles, we ask:</p><pre><code>GET - /films/1GET - /films/2GET - /films/3GET - /films/6</code></pre><p>Once we have all 6 responses from the server, we can combine them to satisfy the data needed by our view.</p><p>Besides the fact that we had to do 6 round-trips to satisfy a simple data need for a simple UI, our approach here was imperative. We gave instructions for <em>how</em> to fetch the data and <em>how</em> to process it to make it ready for the view.</p><p>You can try this yourself if you want to see what I mean. The Star Wars data has a RESTful API currently hosted at <a href="http://swapi.co/" rel="noopener">http://swapi.co/</a>. Go ahead and try to construct our data person object there. The keys might be a bit different, but the API endpoints will be the same. You will need to do exactly 6 API calls. Furthermore, you will have to over-fetch information that the view does not need.</p><p>Of course, this is just one implementation of a RESTful API for this data. There could be better implementations that will make this view easier to implement. For example, if the API server implemented nested resources and understood the relationship between a person and a film, we could read the films data with:</p><pre><code>GET - /people/{id}/films</code></pre><p>However, a pure RESTful API server would most likely not implement that, and we would need to ask our backend engineers to create this custom endpoint for us. That’s the reality of scaling a RESTful API — we just add custom endpoints to efficiently satisfy the growing clients needs. Managing custom endpoints like these is hard.</p><p>Let’s now look at the GraphQL approach. GraphQL on the server embraces the custom endpoints idea and takes it to its extreme. The server will be just a single endpoint and the channel does not matter. If we’re doing this over HTTP, the HTTP method certainly wouldn’t matter either. Let’s assume we have a single GraphQL endpoint exposed over HTTP at <code>/graphql</code>.</p><p>Since we want to ask for the data we need in a single round-trip, we’ll need a way to express our complete data needs for the server. We do this with a GraphQL query:</p><pre><code>GET or POST - /graphql?query={...}</code></pre><p>A GraphQL query is just a string, but it will have to include all the pieces of the data that we need. This is where the declarative power comes in.</p><p>In English, here’s how we declare our data requirement: <em>we need a person’s name, birth year, planet’s name, and the titles of all their films</em>. In GraphQL, this translates to:</p><pre><code>{  person(ID: ...) {    name,    birthYear,    planet {name    },    films {      title    }  }}</code></pre><p>Read the English-expressed requirements one more time and compare it to the GraphQL query. It’s as close as it can get. Now, compare this GraphQL query with the original JSON data that we started with. The GraphQL query is the exact structure of the JSON data, except without all the “values” parts. If we think of this in terms of a question-answer relation, the question is the answer statement without the answer part.</p><p>If the answer statement is:</p><blockquote><em>The closest planet to the Sun is Mercury.</em></blockquote><p>A good representation of the question is the same statement without the answer part:</p><blockquote><em>(What is) the closest planet to the Sun?</em></blockquote><p>The same relationship applies to a GraphQL query. Take a JSON response, remove all the “answer” parts (which are the values), and you end up with a GraphQL query very suitable to represent a question about that JSON response.</p><p>Now, compare the GraphQL query with the declarative React UI we defined for the data. Everything in the GraphQL query is used in the UI, and everything used in the UI appears in the GraphQL query.</p><p>This is the great mental model of GraphQL. The UI knows the exact data it needs and extracting that requirement is fairly easy. Coming up with a GraphQL query is simply the task of extracting what’s used as variables directly from the UI.</p><p>If we invert this model, it would still hold the power. If we have a GraphQL query, we know exactly how to use its response in the UI because the query will be the same “structure” as the response. We don’t need to inspect the response to know how to use it and we don’t need any documentation about the API. It’s all built-in.</p><p>Star Wars data has a GraphQL API hosted at <a href="https://github.com/graphql/swapi-graphql" rel="noopener">https://github.com/graphql/swapi-graphql</a>. Go ahead and try to construct our data person object there. There are a few minor differences that we’ll explain later, but here’s the official query you can use against this API to read our data requirement for the view (with Darth Vader as an example):</p><pre><code>{  person(personID: 4) {    name,    birthYear,    homeworld {      name    },    filmConnection {      films {        title      }    }  }}</code></pre><p>This request gives us a response structure very close to what our view used, and remember, we’re getting all of this data in a single round-trip.</p><h3 id="the-cost-of-graphql-s-flexibility">The Cost of GraphQL’s Flexibility</h3><p>Perfect solutions are fairy tales. With the flexibility GraphQL introduces, a door opens on some clear problems and concerns.</p><p>One important threat that GraphQL makes easier is resource exhaustion attacks (AKA Denial of Service attacks). A GraphQL server can be attacked with overly complex queries that will consume all the resources of the server. It’s very simple to query for deep nested relationships (user -&gt; friends -&gt; friends …), or use field aliases to ask for the same field many times. Resource exhaustion attacks are not specific to GraphQL, but when working with GraphQL we have to be extra careful about them.</p><p>There are some mitigations we can do here. We can do cost analysis on the query in advance and enforce some kind of limits on the amount of data one can consume. We can also implement a time-out to kill requests that take too long to resolve. Also, since GraphQL is just a resolving layer, we can handle the rate limits enforcement at a lower level under GraphQL.</p><p>If the GraphQL API endpoint we’re trying to protect is not public and is meant for internal consumption of our own clients (web or mobile), we can use a whitelist approach and pre-approve queries that the server can execute. Clients can just ask the servers to execute pre-approved queries using a query unique identifier. Facebook seems to be using this approach.</p><p>Authentication and authorization are other concerns that we need to think about when working with GraphQL. Do we handle them before, after, or during a GraphQL resolve process?</p><p>To answer this question, think of GraphQL as a DSL (domain specific language) on top of your own backend data fetching logic. It’s just one layer that we could put between the clients and our actual data service (or multiple services).</p><p>Think of authentication and authorization as another layer. GraphQL will not help with the actual implementation of the authentication or authorization logic. It’s not meant for that. But if we want to put these layers behind GraphQL, we can use GraphQL to communicate the access tokens between the clients and the enforcing logic. This is very similar to the way we do authentication and authorization with RESTful APIs.</p><p>One other task that GraphQL makes a bit more challenging is client data caching. RESTful APIs are easier to cache because of their dictionary nature. This location gives that data. We can use the location itself as the cache key.</p><p>With GraphQL, we can adopt a similar basic approach and use the query text as a key to cache its response. But this approach is limited, not very efficient, and can cause problems with data consistency. The results of multiple GraphQL queries can easily overlap, and this basic caching approach would not account for the overlap.</p><p>There is a brilliant solution to this problem though. A Graph Query means a <em>Graph Cache</em>. If we normalize a GraphQL query response into a flat collection of records, giving each record a global unique ID, we can cache those records instead of caching the full responses.</p><p>This is not a simple process though. There will be records referencing other records and we will be managing a cyclic graph there. Populating and reading the cache will need query traversal. We need to code a layer to handle the cache logic. But this method will overall be a lot more efficient than response-based caching. <a href="https://facebook.github.io/relay/" rel="noopener">Relay.js</a> is one framework that adopts this caching strategy and auto-manages it internally.</p><p>Possibly the most important problem that we should be concerned about with GraphQL is the problem that’s commonly referred to as N+1 SQL queries. GraphQL query fields are designed to be stand-alone functions and resolving those fields with data from a database might result in a new database request per resolved field.</p><p>For a simple RESTful API endpoint logic, it’s easy to analyze, detect, and solve N+1 issues by enhancing the constructed SQL queries. For GraphQL dynamically resolved fields, it’s not that simple. Luckily Facebook is pioneering one possible solution to this problem: <a href="https://github.com/facebook/dataloader" rel="noopener">DataLoader</a>.</p><p>As the name implies, DataLoader is a utility one can use to read data from databases and make it available to GraphQL resolver functions. We can use DataLoader instead of reading the data directly from databases with SQL queries, and DataLoader will act as our agent to reduce the actual SQL queries we send to the database.</p><p>DataLoader uses a combination of batching and caching to accomplish that. If the same client request resulted in a need to ask the database about multiple things, DataLoader can be used to consolidate these questions and batch-load their answers from the database. DataLoader will also cache the answers and make them available for subsequent questions about the same resources.</p><p>Thanks for reading.</p><p>Learning React or Node? Checkout my books:</p><ul><li><a href="http://amzn.to/2peYJZj" rel="noopener">Learn React.js by Building Games</a></li><li><a href="http://amzn.to/2FYfYru" rel="noopener">Node.js Beyond the Basics</a></li></ul>
</div>
<hr>
<hr>
</section>
</article>
</div>
</main>
</div>
<!-- Google Tag Manager (noscript) -->
<!-- End Google Tag Manager (noscript) -->
